{"meta":{"title":"ChinTi's Blog","subtitle":"欢迎来到我的个人站","description":null,"author":"Chinti","url":"http://chinti.xyz"},"pages":[{"title":"about","date":"2017-12-19T04:34:07.000Z","updated":"2017-12-19T04:39:35.350Z","comments":true,"path":"about/index.html","permalink":"http://chinti.xyz/about/index.html","excerpt":"","text":"关于我占个坑 等博客完善之后再说"},{"title":"分类","date":"2017-12-19T05:01:02.000Z","updated":"2017-12-25T06:15:28.627Z","comments":true,"path":"categories/index.html","permalink":"http://chinti.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-12-25T06:01:53.000Z","updated":"2017-12-25T06:15:48.366Z","comments":true,"path":"tags/index.html","permalink":"http://chinti.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 高级程序设计 阅读笔记（10-12）","slug":"JavaScript-高级程序设计-阅读笔记（10-12）","date":"2018-03-02T05:46:12.000Z","updated":"2018-03-08T13:15:35.519Z","comments":true,"path":"2018/03/02/JavaScript-高级程序设计-阅读笔记（10-12）/","link":"","permalink":"http://chinti.xyz/2018/03/02/JavaScript-高级程序设计-阅读笔记（10-12）/","excerpt":"前言&#160; &#160;&#160; &#160;10、11、12章研究都是DOM相关的知识点，在之前DOM编程艺术这本书中有过一定的了解；DOM:文档对象模型，是针对HTML和XML文档的一个API（应用程序接口）；描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的一部分","text":"前言&#160; &#160;&#160; &#160;10、11、12章研究都是DOM相关的知识点，在之前DOM编程艺术这本书中有过一定的了解；DOM:文档对象模型，是针对HTML和XML文档的一个API（应用程序接口）；描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的一部分 第十章 DOM","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（8-9）","slug":"JavaScript-高级程序设计-阅读笔记（8-9）","date":"2018-02-18T14:16:32.000Z","updated":"2018-03-07T15:32:31.405Z","comments":true,"path":"2018/02/18/JavaScript-高级程序设计-阅读笔记（8-9）/","link":"","permalink":"http://chinti.xyz/2018/02/18/JavaScript-高级程序设计-阅读笔记（8-9）/","excerpt":"前言&#160; &#160;&#160; &#160;8、9章主要讲解BOM和客户端检测的知识，以浏览器客户端作为对象进行控制；BOM、DOM与事件将会是在开发中接触最多的东西","text":"前言&#160; &#160;&#160; &#160;8、9章主要讲解BOM和客户端检测的知识，以浏览器客户端作为对象进行控制；BOM、DOM与事件将会是在开发中接触最多的东西 第八章 BOM&#160; &#160;&#160; &#160;BOM，浏览器对象模型；BOM提供了许多对象，用于访问浏览器的功能，这些功能与任何网页内容无关 window对象&#160; &#160;&#160; &#160;BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JS访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象 全局作用域&#160; &#160;&#160; &#160;所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法；定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以 12345678910111213141516var age = 29;window.color = &quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined//尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在var newValue = oldValue;//errorvar newValue = window.oldValue; //undefined 窗口位置&#160; &#160;&#160; &#160;使用以下代码可以跨浏览器取得窗口左边和上边的位置 12var leftPos = (typeof window.screenLeft == &quot;number&quot;) ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == &quot;number&quot;) ? window.screenTop : window.screenY; &#160; &#160;&#160; &#160;无法再跨浏览器的条件下取得窗口左边和上边的精确坐标值&#160; &#160;&#160; &#160;利用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。前者接受的是新位置的x和y坐标值；后者接受的是在水平和垂直方向移动的像素数 窗口大小&#160; &#160;&#160; &#160;跨浏览器确定一个窗口的大小不是一件简单的事情；虽然各个浏览器均提供了4个属性（innerWidth、innerHeight、outerWidth和outerHeight），但是这些属性返回的却有所不同&#160; &#160;&#160; &#160;但是可以取得页面视口的大小123456789var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth != &quot;number&quot;) &#123; //compatMode用来确定页面是否处于标准模式（第10章） if (document.compatMode == &quot;CSS1Compat&quot;) &#123; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小；移动IE浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight提供了相同的信息 其他移动浏览器中，document.documentElement度量的是布局视口；移动IE浏览器中则存在document.body.clientWidth和document.body.clientHeight中 resizeTo()和resizeBy()方法可以用来调整浏览器窗口的大小 导航和打开窗口&#160; &#160;&#160; &#160;window.open()方法，既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口；接受4个参数：要加载的URL、窗口目标（已有窗口或框架的名称或者是_self、_parent、_top或_black）、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些的特性 设置 值 说明 fullscreen yes或no 表示浏览器窗口是否最大化。仅IE height 数值 表示新窗口的高度。不能小于100 left 数值 表示新窗口的左坐标。不能是负值 location yes或no 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） menubar yes或no 标识是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也有可能会被禁用（取决于浏览器） resizable yes或no 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no scrollbars yes或no 表示如果内容在视口中显示不下，是否允许滚动。默认值为no status yes或no 表示是否在浏览器窗口中显示状态栏。默认值为no toolbar yes或no 表示是否在浏览器窗口中显示工具栏。默认值为no top 数值 表示新窗口的上坐标。不能是负值 width 数值 表示新窗口的宽度。不能小于100 &#160; &#160;&#160; &#160;例如：window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=1-,left=10,left=10,resizable=yes&quot;); close()方法可以关闭新打开的窗口 安全限制及弹出窗口屏蔽程序 &#160; &#160;&#160; &#160;由于滥用弹出窗口，浏览器给弹出窗口配置方面增加了限制 12345678910111213141516171819var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;);if (wroxWin == null)&#123; alert(&quot;The popup was blocked!&quot;);&#125;//若果是浏览器扩展或其他程序阻止的弹出窗口，window.open()通常会抛出错误，在必须检测返回值的同时，将对window.open()的调用封装在一个try-catch块中var blocked = false; try &#123; var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if (wroxWin == null) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; alert(&quot;The popup was blocked!&quot;);&#125; 间歇调用和超时调用&#160; &#160;&#160; &#160;JS是单线程语言，但是通过设置超时值和间歇时间值来调度代码在特定的时刻执行；前者是在指定的事件过后执行，后者则是每隔指定的时间就执行一次代码；超时调用的代码都是在全局作用域执行的 setTimeout()方法，超时调用，接受两个参数：执行的代码和以毫秒标识的时间；第一个参数类似eval()中所使用的字符串，也可以是一个函数 1234567//不建议传递字符串(性能损失)setTimeout(&quot;alert(&apos;Hello world!&apos;)&quot;, 1000);//推荐的调用方式setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;,1000); clearTimeout()方法，取消超时调用，setTimeout()会返回一个超时调用id，将该id作为参数传给clearTimeout()可以取消未执行的超时调用计划 123456//设置超时调用var timeoutId = setTimeout(function &#123; alert(&quot;Hello world!&quot;);&#125;,1000);//取消clearTimeout(timeoutId); setInterval()，间歇调用，传入的参数与setTimeout()类似 clearInterval()，取消间歇调用 系统对话框&#160; &#160;&#160; &#160;通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息；外观由浏览器决定；第一个是警告，第二个可用于确定或者取消，第三个是提示，用于提示用户输入一些文本，接受两个参数，要显示给用户的文本提示和文本输入域的默认值 123456789101112//confirm()if (confirm(&quot;Are you sure?&quot;)) &#123; alert(&quot;I&apos;m so glad you&apos;re sure!&quot;);&#125; else &#123; alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;);&#125;//prompt()var result = prompt(&quot;What is your name? &quot;, &quot;&quot;);if (result !== null) &#123; alert(&quot;Welcome, &quot; + result);&#125; window.print()，显示“打印”对话框 window.find()，显示“查找”对话框 location 对象&#160; &#160;&#160; &#160;location是最有用的BOM对象之一，它既是window对象的属性也是document对象的属性；location对象的用处不只表现在它保存当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员通过不同属性访问这些片段 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80” 返回服务器名称和端口号（如果有） hostname “www.wrox.com” 返回不带端口号的服务器名称 href “http:/www.wrox.com” 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的的目录和（或）文件名 port “8080” 返回URL中指定的端口号。不包含端口号则返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 查询字符串参数&#160; &#160;&#160; &#160;用于解析查询字符串，然后返回包含所有参数的一个对象1234567891011121314151617181920212223242526272829303132function getQueryStringArgs() &#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, //在for循环中使用 i = 0, len = items.length; //逐个将每一项添加到args对象中 for (i=0; i &lt; len; i++) &#123; item = items[].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length) &#123; args[name] = value; &#125; &#125; return args;&#125;//示例//假设查询字符串是?q=javascript&amp;num=10var args = getQueryStringArgs();alert(args[&quot;q&quot;]); //&quot;javascript&quot;alert(args[&quot;num&quot;]); //&quot;10&quot; 位置操作&#160; &#160;&#160; &#160;location对象可以通过很多方式改变浏览器位置 首先使用assign()方法并传递一个URL 1234location.assign(&quot;http://www.wrox.com&quot;);//也可以通过以下方法，同样会调用assign()window.location = &quot;http://www.wrox.com&quot;;location.href = &quot;http://www.wrox.com&quot;; 修改location对象的其他属性同样也会改变当前加载的页面；以上任何一种方法修改URL后，浏览器的历史记录就会生成一条新纪录，调用replace()方法，不会形成新纪录，但是用户不能回到前一个页面 reload()方法，重载当前显示页面；不传递参数，页面会以最有效方式重载，通常来说是从缓存中加载，若向该方法传递参数true，则强制从服务器加载 navigator对象&#160; &#160;&#160; &#160;用于识别客户端浏览器的事实标准；通常用于检测显示网页的浏览器类型；在第九章会详细讨论 ####检测插件&#160; &#160;&#160; &#160;一种常见例程用于检测浏览器中是否安装了特定的插件；非IE浏览器，通过plugins数组达成这个目的，该数组包含下列属性 name： 插件的名字（通常回包含检测插件必要的所有信息，但有时并不如此） description：插件的描述 filename：插件的文件名 length：插件所处理的MIME类型数量 &#160; &#160;&#160; &#160;IE浏览器相对比较麻烦，需要通过专有的ActiveXObject类型；IE通过COM对象的方式实现插件，所以检查特定插件必须知道标识符，Flash的标识符ShockwaveFlash.ShockwaveFlash；refresh()可以刷新plugins，传递true会重新加载所有界面，否则只更新集合123456789101112131415161718192021222324252627282930313233343536373839//检测插件（IE中无效）funciton hasPlugin(name) &#123; name = name.toLowerCase(); for (var i=0; i&lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125;//检查IE中的插件function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125;//检测所有浏览器中的Flashfunction hasFlash() &#123; var result = hasPlugin(&quot;Flash&quot;); if (!result) &#123; result = hasIEPlugin(&quot;ShockwaveFlash.shockwaveFlash&quot;); &#125; return result;&#125;//检测所有浏览器中的QuickTimefunction hasQuickTime() &#123; var result = hasPlugin(&quot;QuickTime&quot;); if(!result) &#123; result = hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; result result;&#125;//检测Flashalert(hasFlash());//检测QuickTimealert(hasQuickTime()); 注册处理程序&#160; &#160;&#160; &#160;registerContentHandler()和registerProtocolHandler()方法（22章，HTML5），这两个方法可以让一个站点指明它可以处理特定类型的信息；registerContentHandler()方法接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称；registerProtocolHandler()方法，接受三个参数：要处理的协议、处理该协议的页面的URL和应用程序的名称 123navigator.registerContentHandler(&quot;application/rss+xml&quot;,&quot;http://www.somereader.com?feed=%s&quot;,&quot;Some Reader&quot;);navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;, &quot;Some Mail Client&quot;); screen对象&#160; &#160;&#160; &#160;screen对象主要用于表明客户端的能力，包括浏览器窗口外部的显示器的信息，如像素宽度和高度等；每个浏览器中的screen对象有所不同，P214 history对象&#160; &#160;&#160; &#160;history对象保存着用户上网的历史记录，从打开窗口被打开的那一刻起；history是window对象的属性，因此每个浏览器窗口、标签页乃至框架都有自己的history；go()方法可以在用户的历史记录中跳转，可以向前或向后，正负数相当于向前或向后，也可以传递一个字符串参数，跳转至位置最近的页面；当然可以用back()和forward()来代替go() 第九章 客户端检测&#160; &#160;&#160; &#160;现实中，浏览器之间的差异极大，客户端检测既是一种补救措施，也是一种开发策略；先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案 能力检测&#160; &#160;&#160; &#160;通过识别浏览器支持的特定能力，给出解决方案 更可靠的能力检测&#160; &#160;&#160; &#160;在可能的情况下，要尽可能使用typeof进行能力检测；当然许多时候，IE比较例外 1234//在IE8及之前版本中不行，会返回falsefunction hasCreateElement() &#123; return typeof document.createElement == &apos;funciton&apos;;&#125; &#160; &#160;&#160; &#160;P219页介绍了一个IE浏览器中的例子 能力检测，不是浏览器检测&#160; &#160;&#160; &#160;实际开发中，应将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器1234//确定浏览器是否支持Netscape风格的插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);//确定浏览器是否具有DOM1级规定的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementsByTagName); 怪癖检测&#160; &#160;&#160; &#160;目标是识别浏览器的特殊行为，与能力检测不同，是想知道浏览器存在什么缺陷（bug）；P220-221举了IE8及更早版本和safari3以前版本的例程 用户代理检测&#160; &#160;&#160; &#160;该方法争议很大，它通过检测用户代理字符串确定实际使用的浏览器，该字符串可以通过JS的navigator.userAgent属性访问；在客户端，该方法优先级在前两者之后 用户代理字符串检测技术&#160; &#160;&#160; &#160;浏览器对应的引擎：Gecko：Firefox，Webkit：Safari，Chrome，Presto：Opera；移动浏览器都是基于Webkit，但是会有辅助确定的记号，比如：辅助确定Mac操作系统的“like Mac OS X”，以及确定移动端的：Mobile 识别呈现引擎、平台、window操作系统、移动设备、游戏系统&#160; &#160;&#160; &#160;五大呈现引擎：IE、Gecko、WebKit、KHTML和Opera123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181var client = function()&#123; //呈现引擎 var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera)&#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\\/(\\S+)/.test(ua))&#123; engine.ver = RegExp[&quot;$1&quot;]; engine.webkit = parseFloat(engine.ver); //确定是chrome还是safari if (/Chrome\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.safari = parseFloat(browser.ver); &#125; else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[&quot;$1&quot;]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp[&quot;$1&quot;]; engine.gecko = parseFloat(engine.ver); //确定是不是Firefox if (/Firefox\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[&quot;$1&quot;]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf(&quot;Win&quot;) == 0; system.mac = p.indexOf(&quot;Mac&quot;) == 0; system.x11 = (p == &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) == 0); //检测Window操作系统 if (system.win)&#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(ua))&#123; if (RegExp[&quot;$1&quot;] == &quot;NT&quot;)&#123; switch(RegExp[&quot;$2&quot;])&#123; case &quot;5.0&quot;: system.win = &quot;2000&quot;; break; case &quot;5.1&quot;: system.win = &quot;XP&quot;; break; case &quot;6.0&quot;: system.win = &quot;Vista&quot;; break; case &quot;6.1&quot;: system.win = &quot;7&quot;; break; default: system.win = &quot;NT&quot;; break; &#125; &#125; else if (RegExp[&quot;$1&quot;] == &quot;9x&quot;)&#123; system.win = &quot;ME&quot;; &#125; else &#123; system.win = RegExp[&quot;$1&quot;]; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf(&quot;iPhone&quot;) &gt; -1; system.ipod = ua.indexOf(&quot;iPod&quot;) &gt; -1; system.ipad = ua.indexOf(&quot;iPad&quot;) &gt; -1; system.nokiaN = ua.indexOf(&quot;NokiaN&quot;) &gt; -1; //windows mobile if (system.win == &quot;CE&quot;)&#123; system.winMobile = system.win; &#125; else if (system.win == &quot;Ph&quot;)&#123; if(/Windows Phone OS (\\d+.\\d+)/.test(ua))&#123;; system.win = &quot;Phone&quot;; system.winMobile = parseFloat(RegExp[&quot;$1&quot;]); &#125; &#125; //检测iOS版本 if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1)&#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;)); &#125; else &#123; system.ios = 2; //can&apos;t really detect - so guess &#125; &#125; //检测Andriod版本 if (/Android (\\d+\\.\\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125; //游戏系统 system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 使用方法&#160; &#160;&#160; &#160;用户代理检测是客户端的最后一个选择，优先采用能力检测和怪癖检测；用户代理检测一般适用于下列情形 不能直接准确地使用能力检测或怪癖检测，比如某些浏览器预留了函数但并没有实现，仅测试函数无法得出信息 同一款浏览器在不同平台下的不同表现 为了跟踪分析等","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（6-7）","slug":"JavaScript-高级程序设计-阅读笔记（6-7）","date":"2018-02-02T15:46:52.000Z","updated":"2018-02-24T14:15:23.961Z","comments":true,"path":"2018/02/02/JavaScript-高级程序设计-阅读笔记（6-7）/","link":"","permalink":"http://chinti.xyz/2018/02/02/JavaScript-高级程序设计-阅读笔记（6-7）/","excerpt":"前言&#160; &#160;&#160; &#160;4，6，7章主要讲解作用域链、JavaScript面向对象、原型-构造函数机制、闭包等概念，这些都是JavaScript的重中之重","text":"前言&#160; &#160;&#160; &#160;4，6，7章主要讲解作用域链、JavaScript面向对象、原型-构造函数机制、闭包等概念，这些都是JavaScript的重中之重 第六章 面向对象的程序设计&#160; &#160;&#160; &#160;面向对象语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象，但是ES没有类，所以它的对象也与其他语言中的对象有所不同，每个对象都是基于一个引用类型创建的，可以是原生类型，也可以是自己定义的 理解对象&#160; &#160;&#160; &#160;可以创建一个Object对象，但现在对象字面量称为创建对象的首选模式 属性类型 数据属性，包含一个数据值的位置，在这个位置可以读取和写入值 数据属性 默认值 说明 [[Configurable]] true 表示能否通过delete删除属性从而重新定义属性 [[Enumerable]] true 表示可否通过for-in循环返回属性 [[Writable]] true 表示可否修改属性的值 [[Value]] undefined 包含这个属性的数据值，读取属性值的时候从这个位置读，写入的新值保存在这个位置 若要改变属性默认的特性，ES5提供了一个方法：Object.defineProperty()方法，该方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value，不要在ie8上使用 12345var person = &#123;&#125;;Object.defineProperty(person,&quot;name&quot;,&#123; writable: false, value: &quot;Nicholas&quot;&#125;); 访问器属性，ES5：Object.defineProperty()方法，旧方法：__defineGetter__()，__defineSetter__ 访问器属性 默认值 说明 [[Configurable]] true 表示能否通过delete删除属性从而重新定义属性 [[Enumerable]] true 表示可否通过for-in循环返回属性 [[Get]] undefined 在读取属性时调用的函数 [[Set]] undefined 在写入属性时调用的函数 123456789101112131415var book = &#123; _year: 2004; edition: 1;&#125;;Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edtion += newValue - 2004; &#125; &#125;&#125;); 定义多个属性&#160; &#160;&#160; &#160;Object.defineProperties()方法 读取属性的特性&#160; &#160;&#160; &#160;Object.getOwnPropertyDescriptor()方法1234var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);alert(descriptor.value); //2004alert(descriptor.configurable); //false... 创建对象&#160; &#160;&#160; &#160;Object构造函数或对象字面量都可以用来创建单个对象，但是同一个接口创建多个对象，会产生大量重复代码 工厂模式&#160; &#160;&#160; &#160;该设计模式抽象了创建具体对象的过程，ES无法创建类，于是发明了一种函数，可以封装以特定接口创建对象的细节 1234567891011function createPerson(name,age,job) &#123; var o = new Project(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person = createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;); &#160; &#160;&#160; &#160;该方法虽然解决了创建多个相似对象的问题，但是却没解决对象识别的问题 构造函数模式&#160; &#160;&#160; &#160;构造函数可用来创建特定类型的对象，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person = new Person(&quot;Grey&quot;,&quot;27&quot;,&quot;Doctor&quot;);alert(person.constructor == Person); //truealert(person instanceof Object); //truealert(person instanceof Person); //true &#160; &#160;&#160; &#160;创建自定义的构造函式可以将它的实例标识为一种特定的类型，这是构造函数模式胜过工厂模式的地方。使用构造函数模式的主要问题是，每个方法都要在每个实例上重新创建一遍，而将这个方法转移到构造函数外部，但是又存在一个问题全局作用域中定义的函数实际上只被某个对象调用，尤其是如果有多个这样的函数存在，整个引用类型就毫无封装性可言。 原型模式&#160; &#160;&#160; &#160;我们所创建的每个函数都有一个prototype属性，该属性是一个指针指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法1234567891011121314function Person() &#123; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); //Nicholasvar person2 = new Person();person2.sayName(); //Nicholasalert(person1.sayName == person2.sayName); //true 理解原型对象 &#160; &#160;&#160; &#160;只要创建了一个新函数，就会根据一组特定规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象会自动获取一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。 &#160; &#160;&#160; &#160;比如之前的代码，Person的prototype属性以及Person1与Person2的[[Prototype]]属性指向Person Prototype，然后Person Prototype的constructor属性指向Person 函数名 说明 示例 isPrototypeOf() 确定对象之间是否存在原型关系 alert(Person.prototype.isPrototypeOf(person1)); //true Object.getPrototypeOf() 该方法返回[[Prototype]]的值 alert(Object.getPrototypeOf(person1) == Person.prototype); //true hasOwnProperty() 检测一个属性是否存在于实例中（存在于原型中返回false） alert(person1.hasOwnProperty(“name”)); //false in 通过对象能够访问给定属性时返回true(无论是实例还是原型中) alert(“name” in person1); //true for-in 返回的是所有能够通过对象访问的、可枚举属性(无论是实例中的还是原型中的) Object.keys() 接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组 alert(Object.keys(person.prototype)); //“name,age,job,sayName” Object.getOwnPropertyName() 可以取得所有实例属性，无论是否枚举 alert(Object.getOwnPropertyNames(Person.prototype)); //“constructor,name,age,job,sayName” &#160; &#160;&#160; &#160;可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果在实例中添加了一个同名属性，该属性将会屏蔽原型中的那个属性，使用delete操作符可以删除实例属性，从而恢复访问 更简单的原型语法 &#160; &#160;&#160; &#160;每添加一个属性和方法就要敲一遍Person.prototype，为了视觉上更好的封装原型，可以采用一个包含所有属性和方法的对象字面量来重写整个原型&#160; &#160;&#160; &#160;[注]使用该方法封装原型，本质上完全重写了prototype对象，因此constructor属性变成了新对象的属性，即指向了Object 1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123; //constructor: Person, //包含这句，可以确保该属性的值为Person，但是同样会变为可枚举 name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function() &#123; alert(this.name); &#125;&#125;;var friend = new Person();alert(friend instanceof Person); //true 检测是否存在prototype属性alert(friend instanceof Object); //truealert(friend.constructor == Person); //false //若加上之前那条，该属性会变成truealert(friend.constructor == Object); //true &#160; &#160;&#160; &#160;ES5之后可以使用Object.defineProperty()将construct属性改为不可枚举 1234Object.defineProperty(Person.prototype,&quot;constructor&quot;, &#123; enumerable: false; value: Person&#125;); 原型的动态性，尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来；重写整个原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍是最初的原型，P157，有点绕 原生对象的原型，所有原生的引用类型也是采用这种模式创建的；通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法，但是最好不要这么干 原型对象的问题，它省略了构造函数传递初始化参数，导致默认情况下会取得相同的属性，但最大的问题还是它共享的本性导致的 组合使用构造模式和原型模式&#160; &#160;&#160; &#160;该方法是最为常见的创建自定义类型的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性；此外，该模式也支持向构造函数传递参数 1234567891011121314151617181920function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;court&quot;]&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Count,Van&quot;alert(person2.friends); //&quot;Shelby,Count&quot;alert(person1.friends === person2.friends); //falsealert(person2.friends === person2.sayName); //true 动态原型模式&#160; &#160;&#160; &#160;动态原型模式将所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点 1234567891011121314function Person(name, age, job) &#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != &quot;function&quot;) &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造模式&#160; &#160;&#160; &#160;该模式与工厂模式其实一摸一样，除了使用new操作符并把使用的包装函数叫做构造函数；该方法不能依赖instanceof操作符来确定对象类型，所以尽量不要使用这种模式 123456789101112131415function SpecialArray() &#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function() &#123; return this.join(&quot;|&quot;); &#125;; //返回数组 return values;&#125;var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);alert(colors.toPipedString()); //&quot;red|blue|green&quot; 稳妥构造函数模式&#160; &#160;&#160; &#160;稳妥对象，指的是没有公共属性，也不引用this的对象，其他与寄生构造函数类似 123456789101112function Person(name, age, job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); &#125;; //返回对象 return o;&#125; 继承&#160; &#160;&#160; &#160;由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，且主要依靠原型链实现 原型链※&#160; &#160;&#160; &#160;ES中将原型链作为实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法；让原型对象等于另一个类型的实例，层层递进&#160; &#160;&#160; &#160;构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针 12345678910111213141516171819202122232425function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//SuperType实例中的所有方法和属性，现也存在于SubType.prototype中SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //truealert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //truealert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //truealert(Subtype.prototype.isPrototypeOf(instance)); //true 别忘记默认的原型，所有引用类型默认继承了Object，该继承方式也是通过原型链 确定原型和实例的关系，两种方式，第一种是instanceof操作符；第二种方式是采用isPrototypeOf()方法 谨慎地定义方法，给原型添加方法的代码（覆盖或添加）一定要放在替换原型的语句之后；在通过原型链继承之时不要使用字面量创建原型方法，会重写原型链 123456789//继承了SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;SubType.prototype.getSuperValue = function() &#123; return false;&#125;; 原型链的问题：其一，通过原型实现继承时，原型实际上会成为另一个类型的实例，所以原先的实例属性顺利成长的变成现在的原型属性，最终这些属性会被现有原型的实例所共享；其二，在不影响所有对象实例的情况下，给超类型的构造函数传递参数；因此，实践中很少会单独使用原型链 1234567891011121314function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;//继承了SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 借用构造函数&#160; &#160;&#160; &#160;该技术的基本思想是在子类型构造函数的内部调用超类型构造函数（apply()方法和call()方法） 12345678910111213function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123; //继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green&quot; 传递参数 123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; //继承了SuperType， 同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //&quot;Nicholas&quot;alert(instance.age); //29 借用构造函数的问题，无法函数复用，所以也不会单独使用 组合继承※&#160; &#160;&#160; &#160;思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承；最常用的方式，且instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27 原型式继承&#160; &#160;&#160; &#160;在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例；相当于object()对传入其中的对象进行了一次浅复制（只复制了一层对象的属性） 123456789101112131415161718192021222324252627282930var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;//Example01function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;//Example02，ES5新增了object.create()方法规范了原型式继承，该方法第二参数与Object.defineProperties()方法的第二个参数格式相同var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 寄生式继承&#160; &#160;&#160; &#160;创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象 123456789101112131415function createAnother(orignal) &#123; var clone = object(orignal); //通过调用函数创建一个新对象 clone.sayHi = function() &#123; //以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone; //返回这个对象 &#125;var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 寄生组合式继承※&#160; &#160;&#160; &#160;组合继承最大的问题是不论什么情况下，都会调用两次超类型构造函数；寄生组合式继承，本质上就是使用寄生式继承来继承超类型的的原型，然后将结果制定给与子类型的原型，基本模式如下： 123456789101112131415161718192021222324function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype;&#125;//Examplefunction SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; &#160; &#160;&#160; &#160;该模式下，只调用了一次SuperType构造函数，因此避免在SubType.prototype上面创建不必要的属性；该方式是实现基于类型继承的最有效的方式 第七章 函数表达式&#160; &#160;&#160; &#160;本章主要介绍函数表达式的特征，如何使用函数实现递归，以及使用闭包定义私有变量 &#160; &#160;&#160; &#160;定义函数的方法有两种：函数声明和函数表达式 123456789101112//函数声明function functionName(arg0, arg1, arg2) &#123; //函数体&#125;//只在Firefox、Safari、Chrome和Opera有效alert(functionName.name); //&quot;functionName&quot;//函数表达式，这种情况下创建的函数也被称为匿名函数（拉姆达函数）var functionName = function(arg0, arg1, arg2)&#123; //函数体&#125;； 递归12345678910111213141516171819202122232425262728function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;//该方法表面没什么问题，但是如下调用会导致出错var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //error//非严格模式下，可以使用argument.callee解决这个问题，它是一个指向正在执行的函数的指针function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125;//严格模式var factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包※&#160; &#160;&#160; &#160;闭包是指有权访问另一个函数作用域中的变量的函数；创建闭包的常见方式，就是在一个函数内部创建另一个函数&#160; &#160;&#160; &#160;注意作用域链的关系！！！ P179&#160; &#160;&#160; &#160;如何创建作用域链以及作用域链有什么作用对于理解闭包至关重要 ；当某个函数被调用时，会创建一个执行环境及相应的作用域链，然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链中点的全局执行环境&#160; &#160;&#160; &#160;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部环境的变量对象，则只在函数执行的过程中存在。创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域的前端。对于该例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，他只引用但不实际包含变量对象&#160; &#160;&#160; &#160;无论何时在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。通常，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）；闭包的情况则有所不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中；匿名函数的作用域被销毁后，外部函数的活动对象才会被销毁；过度使用闭包可能导致内存占用过多，请谨慎使用 闭包与变量&#160; &#160;&#160; &#160;作用域链的配置机制有个副作用，即闭包只能取得包含函数中任何变量的最后一个值；闭包保存的是整个变量对象，而不是某特殊变量 1234567891011121314151617181920212223//该函数会返回一个函数数组，但是由于每个函数的作用域链中都保存着createFunctions()函数的活动对象，也就是说引用的都是同一个变量i，那么当最后createFunction返回后，变量的值为10，则result每个值都是10function createFunctions() &#123; var result = new Array(); for (var i=0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result;&#125;//可以创建另一个匿名函数强制使闭包行为符合预期;调用每个匿名函数时我们传入了变量i，这样result中每个函数都有自己num变量的一个副本，因此可以返回不同值function createFunctions() &#123; var result = new array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function(num) &#123; return funciton() &#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 关于this对象&#160; &#160;&#160; &#160;匿名函数的执行环境具有全局性；全局函数中，this等于window 12345678910var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc : function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The Window&quot; （非严格模式下） &#160; &#160;&#160; &#160;这段我稍微有点绕进去，不是很理解为什么两个括号，我尝试将getNameFunc()()删去一个()后，返回如下结果 1234此网页显示：function() &#123; return this.name;&#125; &#160; &#160;&#160; &#160;书上是这样描述的，该代码首先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含了一个方法——getNameFunc()，它返回一个匿名函数，该匿名函数又返回this.name。由于getNameFunc()返回一个函数，所以调用object.getNameFunc()()会立即调用它所返回的函数，从而返回一个字符串。 &#160; &#160;&#160; &#160;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时只能搜索到他的活动对象，所以无法直接访问外部函数中的这两个变量，不过可以将外部作用域中的this对象保存在一个闭包能够访问到的变量里 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;My Object&quot; &#160; &#160;&#160; &#160;特殊情况下，this的值会意外的改变，不过一般不会这么使用12345678910111213var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getName: function()&#123; return this.name; &#125;&#125;; alert(object.getName()); //&quot;My Object&quot;alert((object.getName)()); //&quot;My Object&quot;alert((object.getName = object.getName)()); //&quot;The Window&quot; 非严格模式 内存泄漏&#160; &#160;&#160; &#160;闭包在ie的某些版本中会导致一些特殊的问题，比如说闭包的作用域链中保存这一个HTML元素，那么该元素将无法被销毁；不过只需稍作修改即可12345678910111213141516171819//element的引用数至少为1，占用的内存永远不会被回收function assignHandler() &#123; var element = document.getElementById(&quot;someElement&quot;); element.onclick = function() &#123; alert(element.id); &#125;;&#125;//稍作修改，解除对DOM对象的直接引用function assignHandler() &#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function() &#123; alert(id); &#125;; element = null;&#125; 模仿块级作用域&#160; &#160;&#160; &#160;JS块级作用域不存在的；块语句中定义的变量，实际上是包含函数中而非语句中创建的；所以一旦变量有定义开始，就可以在函数内部随处访问，即使错误的重新声明，该声明会被无视掉；匿名函数可以用来模仿块级作用域，在函数声明外加上一对圆括号可以转换为函数表达式 123456789101112var someFunction = function() &#123; //这里是块级作用域&#125;;someFunction();function() &#123; //块级作用域&#125;(); //出错，函数声明后不能跟圆括号(function() &#123; //块级作用域&#125;)(); //可以模仿一个块级作用域（私有作用域），该方法可以减少闭包占用的内存问题，函数执行完毕，就可以立即销毁其作用域链 私有变量&#160; &#160;&#160; &#160;严格来说，JS是没有私有成员的概念的，所有的对象属性都是公有的&#160; &#160;&#160; &#160;任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。而那些有权访问私有变量和私有函数的公有方法被称为特权方法 1234567891011121314151617181920212223242526//第一种是在构造函数中定义特权方法function MyObject() &#123; //私有变量和私有函数 var privatedVariable = 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; //利用私有和特权成员，可以隐藏那些不应该被直接修改的数据 function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; &#125; &#125; var person = new Person(&quot;Nicholas&quot;); alert(person.getName()); //&quot;Nicholas&quot; person.setName(&quot;Grey&quot;); alert(person.getName()); //&quot;Grey&quot; &#160; &#160;&#160; &#160;由于采用构造函数的方法导致具有构造函数模式的缺点 静态私有变量123456789101112131415161718192021222324252627282930313233343536373839404142434445//基本模式(function() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //构造函数，初始化未经声明的变量总会创建一个全局变量 MyObject = function() &#123; &#125;; //公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;) &#123;&#125;;//例如(function()&#123; //私有变量和私有函数 var name = &quot;&quot;; //静态的、由所有实例共享的属性 Person = function(value)&#123; name = value; &#125;; //公有/特权方法 Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)(); var person1 = new Person(&quot;Nicholas&quot;); alert(person1.getName()); //&quot;Nicholas&quot; person1.setName(&quot;Greg&quot;); alert(person1.getName()); //&quot;Greg&quot; var person2 = new Person(&quot;Michael&quot;); alert(person1.getName()); //&quot;Michael&quot; alert(person2.getName()); //&quot;Michael&quot; &#160; &#160;&#160; &#160;多查找作用域链中的一个层次，就会一定程度上影响查找速度；这就是闭包和私有变量的一个不足之处 模块模式（module pattern）&#160; &#160;&#160; &#160;模块模式为单例（只有一个实例的对象）创建私有变量和特权方法；如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，就可以使用模块模式 12345678910111213141516var singleton = function() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //特权/公有方法和属性 return &#123; publicProperty: true; publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 增强的模块模式&#160; &#160;&#160; &#160;可以在返回对象前加入对其增强的代码 123456789101112131415161718192021222324252627function BaseComponent()&#123;&#125;function OtherComponent()&#123;&#125;var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == &quot;object&quot;)&#123; components.push(component); &#125; &#125;; //返回副本 return app;&#125;();alert(application instanceof BaseComponent);application.registerComponent(new OtherComponent());alert(application.getComponentCount()); //2","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（1-5）","slug":"JavaScript-高级程序设计-阅读笔记（1-5）","date":"2018-01-25T13:52:27.000Z","updated":"2018-02-02T15:37:59.483Z","comments":true,"path":"2018/01/25/JavaScript-高级程序设计-阅读笔记（1-5）/","link":"","permalink":"http://chinti.xyz/2018/01/25/JavaScript-高级程序设计-阅读笔记（1-5）/","excerpt":"前言&#160; &#160; &#160;&#160;700页。。好厚啊。。慢慢读吧，完整把javaScript过一遍再去学jQuery还有vue什么的框架和库吧（等一个月后百度前端学院开班。。不知道今年开不开），本书源代码可以在www.wrox.com中下载，第一到第五章是语言基础知识","text":"前言&#160; &#160; &#160;&#160;700页。。好厚啊。。慢慢读吧，完整把javaScript过一遍再去学jQuery还有vue什么的框架和库吧（等一个月后百度前端学院开班。。不知道今年开不开），本书源代码可以在www.wrox.com中下载，第一到第五章是语言基础知识 第一章 JavaScript 简介&#160; &#160; &#160;&#160;首先一个完整的JavaScript实现包含了三个部分，核心（ECMAScript，由ECMA-262定义），文档对象模型（DOM），浏览器对象模型（BOM）&#160; &#160; &#160;&#160;其中，ECMAScript包含了语法、类型、语句、关键字、保留字、操作符以及对象&#160; &#160; &#160;&#160;而DOM是提供了一个针对XML但经过扩展用于HTML的应用程序编程接口（API），DOM包含DOM1级，DOM2级，DOM3级，其中DOM1级又由两个模块组成，DOM Core与DOM HTML，而DOM2级则是再次智商扩充了新的模块，如：DOM视图、DOM事件、DOM样式、DOM遍历和范围，在DOM3级中引入了DOM加载和保存模块，还有DOM验证模块&#160; &#160; &#160;&#160;BOM一般值处理浏览器窗口和框架，但是习惯上所有针对浏览器的JS扩展皆算作BOM的一部分 第二章 在HTML中使用JavaScript&#160; &#160; &#160;&#160;这章稍作了解好了，正常不会再HTML直接使用JS的了吧 defer 延迟脚本，HTML5中明确规定内嵌脚本将会忽视这个属性 async 异步脚本 由于HTML5在这个时间点已经被广泛应用，之后XHTML部分就直接略过了 文档模式，有多种模式，使用HTML5用：&lt;!DOCTYPE html&gt; noscript元素 第三章 基本概念&#160; &#160; &#160;&#160;本章主要介绍ES3，并对ES5的变化进行一些说明（ES6是2015年新制定的标准，按需再去了解吧） 语法 区分大小写 标识符，第一个字符必须是一个字母、一个下划线（_）或一个美元符号（$），其他字符可以是字幕、下划线、美元符号或数字 按照惯例采用驼峰大小写格式 注释，//单行注释，/*...*/多行注释 严格模式（strict mode），在脚本顶部或者制定函数内部&quot;use strict&quot;; 语句，以一个分号结尾，若省略分号，则有解析器确定 关键字和保留字，关键字是一组具有特殊用途的的字，保留字则为一组可能在将来使用的关键字 变量，弱类型，松散类型，才用var进行定义 数据类型，5种简单数据类型：Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object typeof操作符，特别：null会返回Object，因为被认为是一个空的对象引用，未初始化的变量会自动赋予undefined值 相等性测试时，null与undefined会返回true Boolean类型，利用Boolean()可以把任何其他值转型，一般来说空字符串、0和NaN、null还有undefined会被转换成false Number类型，八进制必须以0开头，十六进制必须以0x开头，存在+0与-0，可以采用科学记数法，即3.125e7，同时不要使用浮点数值做判断，因为精度不能保证（IEEE754） 数值范围，Number.MIN_VALUE == 5e-324，Number.MAX_VALUE == 1.7976931348623157e+308，Infinity表示无穷值，isFinite()判断有穷性 NaN，Not a Number，NaN与任何值不相等包括自己，任何对NaN的操作都会返回NaN，任何数值除以非数值就会返回NaN，isNaN()判断不是数值，无法被转换为数值就会返回true 数值转换，Number()、parseInt()、parseFloat() 函数 八进制 十六进制 字符串 空字符串 Number() 忽略前导0，转换为十进制 转换为相同大小的十进制 包含其他格式的转换为NaN 0 parseInt() 转换为相同大小的十进制，指定基数为8 同前，基数指定为16 若第一个字符为数字，则会一直解析到非数值为止，若第一个字符为非数字，转化为NaN NaN parseFloat() 忽略0，理解为十进制 转化为0 同上 同上 string类型，”\\”转义字符，例如\\n \\t \\b \\r \\f \\\\ \\&#39; \\&quot; \\xnn \\unnnn，字符串一旦创建，值就是不可改变的，需要重新创建，toString()方法，该方法可以指定基数，将数值转化为对应进制的字符串值，null和undefined没有这个方法 Object类型，对象，其实就是一组数据和功能的集合，var o = new Object();省略括号有效，但不推荐，每个Object实例都拥有下列属性和方法 属性和方法名 说明 constructor 保存着用于创建当前对象的函数 hasOwnProperty(propertyName) 用于检查给定属性在当前对象实例中是否存在 isPrototypeOf(object) 用于检查传入的对象是否是当前对象的原型 propertyIsEnumerable(propertyName) 用于检查给定的属性是否能够使用for-in语句来枚举 toLocalString() 返回对象的字符串表示，该字符串与执行环境的地区对应 toString() 返回对象的字符串表示 valueOf() 返回对象的字符串、数值或布尔值表示 操作符 一元操作符，递增递减操作符++age; --age;和C差不多，一元加和一元减，用在数值前表示正负，用于其他的值会强制执行一次Number() 位操作符，按位非（NOT），~，相当于操作数的负值减一，按位与（AND），&amp;，按位或（OR），|，按位异或（XOR），^，左移，&lt;&lt;，例：var newValue = oldValue &lt;&lt; 5;，有符号右移，&gt;&gt;，无符号右移，&gt;&gt;&gt; 布尔操作符，逻辑非，!，逻辑与（短路操作，若第一个为false后一条语句不执行），&amp;&amp;，逻辑或，||，可以利用这个避免为后一个变量赋值 乘性操作符，乘法，*，除法，/，其中零被零除为NaN，求模，% 加性操作符，加法，+，正负无穷相加为NaN，减法，- 关系操作符，&lt; &gt; &lt;= &gt;=，可以比较字符串，每个字符编码的大小 相等操作符，相等(==)和不相等(!=)——先转换再比较，全等(===)和不全等(!==)——仅比较而不转换 条件操作符，variable = boolean_expression ? true_value : false_value;，例如：var max = (num1&gt;num2) ? num1 : num2; 赋值操作符，=，还有一些复合赋值操作符 逗号操作符 语句 if语句，do-while语句，while语句，for语句，for-in语句，建议使用for-in之前，先检测确认该对象的值不是null或undefined label语句，可以在代码中添加标签，label： statement，该标签可以由break或continue语句引用 with语句，将代码的作用域设置到一个特定的对象中，with(expression) statement;，不建议使用，且严格模式下会报错 switch语句，采用的是全等操作符 函数，function，可以向函数传递任意数量的参数，在函数体内可以通过arguments对象来访问这个参数数组，不存在重载 第四章 变量、作用域和内存问题&#160; &#160; &#160;&#160;本章主要介绍基本类型和引用类型的值，以及理解执行环境和垃圾收集 基本类型和引用类型的值，基本类型指的是简单数据段，引用类型指的是由多个值构成的对象 动态的属性，只能给引用类型值动态的添加属性，以便将来使用 复制变量值，引用类型相当于创建了一个副本到原副本的指针 传递参数，访问变量有按值和按引用两种方式，而参数只能按值传递 检测类型，typeof操作符可以确定一个变量是字符串、数值、布尔值还是undefined的最佳工具，若变量的值是null或对象，都会返回object instanceof用于确定一个值使用哪种引用类型，alert(person instanceof Object);，基本类型则返回false 执行环境及作用域 全局执行环境被认为是window对象 每个函数都有自己的执行环境，作用域链用于保证对执行环境有权访问的所有变量和函数的有序访问 延长作用域链，try-catch语句的catch块和with语句会在作用域的前端临时增加一个变量对象 没有块级作用域，所以在if和for语句中所声明的变量在执行完毕后不会被销毁 函数中声明的变量，若没有使用var声明，该变量会自动被添加到全局环境 查询标识符 垃圾收集，JS具有自动垃圾收集机制，原理很简单，具体到浏览器中，则通常有两种策略 标记清除（mark-and-sweap），当变量进入环境时，将这个变量标记为“进入环境”，该方法较为常见 引用计数（reference counting），会造成很多麻烦，例如循环引用 性能问题，可以直接调用window.CollectGarbage()触发垃圾收集过程，但是最好不要这么做 管理内存，使用具备垃圾收集机制的语言，一般开发人员不需要操心内存管理，优化内存的最佳方式，就是为执行中的代码只保存必要的数据，一旦数据不再用，最好将其设为null来释放引用。不过，解除一个值的引用并不意味着自动回收该值所占用的内存，接触引用的真正作用是让值脱离执行环境，便于垃圾收集器下次运行时回收 第五章 引用类型&#160; &#160; &#160;&#160;要注意，虽然引用类型与类看起来相似，但是他们并不是相同的概念，虽然技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构 Object类型，创建Object实例的方式有两种，第一种使用new操作符后跟Object()，另一种方式是对象字面量表示法，一般来说访问对象属性时使用的是点表示法，除非必须使用变量来访问属性才使用方括号表示法 Array类型，同样使用字面量表示法时，也不会调用函数，数组的length不是只读的，所以可以通过修改它在末尾移除项或者添加新项，利用colors[colors.length]=&#39;black&#39;;可以在尾端添加一个值并length自动加一，数组最多可以包含4294967295项 检测数组，两种方法，if (value instanceof Array) {...}和if (Array.isArray(value)){...}，前种方法假定只有一个全局执行环境 转换方法，toLocaleString() toString() valueOf()，用join方法可以返回不同的分隔符构建的字符串，alert(colors.join(&#39;||&#39;)); 栈方法，push() pop()，队列方法，push() shift()，unshift作用与shift相反，用于在前端推入项，利用unshift和pop可以反向模拟队列 重排序方法，reserve()，反转数组，sort()，会调用toString()方法，所以比较的是字符串，而且sort可以接受一个比较函数作为参数，实现降序升序排列，这两个方法的返回值是经过排序之后的数组 操作方法，concat()方法可以基于当前数组中的所有项创建一个新数组，若给它传递参数，则会将参数添加到结果数组的末尾，var colors2 = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);；slice()方法可以给予当前数组中的一个或多个项创建一个新数组，接收一个或者两个参数，即要返回项的起始和结束位置，该方法返回起始和结束位置之间的项，但是不包括结束位置的项；splice()方法功能强大，可以实现数组中元素的删除，插入，替换。该方法接受两个或者三个参数，起始项的位置，要删除的个数，带插入的元素，该方法始终会返回一个数组，该数组包含从原始数组中删除的项 位置方法，ES5添加了两个位置方法：indexOf()和lastIndexOf()，前者从前往后查找，后者从后往前查找，这两个方法都可以接受两个参数：要查找的项和（可选的）表示查找起点位置的索引，没有找到则返回-1 迭代方法，以下均是对数组中的每一项运行给定函数，并且这些方法都不会修改数组中包含的值，参数似乎全是function(item,index,array){...}， every()，如果该函数对每一项都返回true，则返回true filter()，返回该函数会返回true的项组成的数组 forEach()，这个方法没有返回值 map()，返回每次函数调用的结果组成的数组 some()，如果该函数对任一项返回true，则返回true 归并方法：reduce()和reduceRight()，这两个方法都接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值，这个函数接收4个参数：前一个值、当前值、项的索引和数组对象。fucntion(prev,cur,index,array){...} Date类型 var now = new Date();，在调用Date构造函数而不传递参数的情况下，新创建的对象自动获取当前日期和时间 若想根据特定日期和时间创建日期对象，必须传入表示改日期的毫秒数，提供了两个方法：Date.parse()和Date.UTC()，例如：var someDate(Date.parse(&quot;May 25, 2004&quot;));，var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));，月份中的天数从1开始，其他都是从0开始，P99页 ES5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数 继承的方法，在不同浏览器中返回的日期和时间会略有不同 日期/时间组件方法P102，有一大把，按需查阅 日期格式化方法 方法 作用 toDateString() 以特定实现的格式显示星期几、月、日和年 toTimeString() 以特定于实现的格式显示时、分、秒和时区 toLocaleDateString() 以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString() 以特定于实现的格式显示时、分、秒 toUTCString() 以特定于实现的格式完整的UTC日期 RegExp类型 var expression = / pattern / flags ; 其中，模式（pattern）部分可以是任何简单或者复杂的正则表达式 正则表达式的匹配模式支持3个标志（flags） 标志 说明 g 表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 ES3中，正则表达式字面量始终会共享一个RegExp实例，ES5明确规定，始终正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例 RegExp实例属性 属性 说明 global 布尔值，表示是否设置了g标志 ignoreCase 布尔值，表示是否设置了i标志 lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0算起 multiline 布尔值，表示是否设置了m标志 source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法，该对象的主要方法是exec()，该方法是专门为捕获组而设计的，该方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者返回null，返回的数组包含两个额外的属性：index和input，前者表示匹配项在字符串中的位置，后者表示应用正则表达式的字符串，该方法即使使用g也只会返回一个匹配项，但是再次调用会继续往下匹配 test()方法，接受一个字符串参数，匹配的话返回true，否则是false 模式的局限性，高级正则表达式特性部分不支持 RegExp构造函数属性，具有一个长属性名和一个短属性名，opera不支持短属性名，貌似现在高版本都支持了吧，一般短属性不是有效的ES标识符，所以需要用方括号法调用 长属性名 短属性名 说明 input &#36;&#95; 最近一次要匹配的字符串 lastMatch &#36;&#38; 最近一次的匹配项 lastParen &#36;&#43; 最近一次匹配的捕获组 leftContext &#36;&#96; input字符串中lastMatch之前的文本 multiline &#36;&#42; 布尔值，表示是否所有表达式都是用多行模式 rightContext &#36;&#39; Input字符串中lastMatch之后的文本 Function类型 函数实际上是对象，每个函数都是Function类型的实例，所以函数名实际上也是一个指向函数对象的指针 没有重载（深入理解），因为函数名只是指针罢了 函数声明与函数表达式，函数声明会被提升到代码树顶部，并添加入执行环境中，但是等价的函数表达式不会，所以在执行语句放在函数表达式前的话会报错，除此之外没有区别 作为值的函数 函数内部属性，有两个特殊属性，arguments和this，前者主要用途是保存函数参数，是一个类数组对象，它还拥有一个属性，叫做callee，是一个指针，指向拥有该arguments对象的函数，可以消除类似递归函数中与函数名紧密耦合的现象，arguments.callee(num-1) this引用的是函数执行的环境对象 ES5规范了另一个函数对象的属性caller，该属性保存着调用当前函数的函数的引用 1234567function outer()&#123; inner(); &#125;function inner()&#123; alert(arguments.callee.caller)&#125;outer(); //弹出outer()的源代码 在严格模式下arguments.callee以及arguments.caller都会报错，而非严格模式下后者始终为undefined 函数属性和方法，每个函数都包含两个属性，length和prototype，其中前者表示函数希望接受的命名参数的个数，prototype属性是保存引用类型所有实例方法的真正所在，它是不可枚举的 每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值，前者接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组（可以是Array的实例，也可以是arguments对象），后者的第一个参数是this没有变化，变化的是其余参数都直接传递给函数，也就是传递的参数必须逐个列举出来 事实上，传参并不是apply()和call()真正的用武之地，他们可以扩充函数赖以运行的作用域，sayColor.call(o); //blue ES5还定义了一个方法，bind()，该方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值 基本包装类型 为了便于操作基本类型，ES提供了3个特殊的引用类型，Boolean、Number和String，引用类型与基本包装类型的主要区别在于对象的生存期，自动创建的基本类型对象只存在于一行代码的执行瞬间，然后即被销毁，要注意通过new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的（建议永远不要使用Boolean对象） toFixed()方法会按照指定的小数位返回数值的字符串表示，alert(num.toFixed(2)); //&quot;10.00&quot; toExponential()，该方法返回以指数表示法表示的数值的字符串形式 toPrecision()方法会返回最合适的的格式 字符方法，字符串操作方法，字符串位置方法，字符串大小写转换方法，字符串的模式匹配方法， 方法 说明 charAt() 以单字符字符串的形式返回给定位置的那个字符（位置从0开始） charCodeAt() 同上，但返回的是字符编码 concat() 用于将一或多个字符串拼接起来，返回拼接得到的新字符串（还是加号操作符常用） slice() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定结束位置，输入的负值会与长度相加 substring() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定结束位置，将负值转为0 substr() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定返回字符个数，第一个负值与长度相加，第二个负值转为0 indexOf() 从字符串开头向后搜索子字符串的位置，没找到返回-1，接受可选的第二个参数表示从哪个位置开始 lastIndexOf() 从字符串末尾向后搜索子字符串的位置，没找到返回-1，接受可选的第二个参数表示从哪个位置开始 trim() 该方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 toLowerCase() toLocaleLowerCase() 转换为小写 toUpperCase() toLocaleUpperCase() 转换为大写 match() 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，只接受一个参数，正则表达式或者RegExp对象 search() 返回字符串中第一个匹配项的索引 replace() 替换子字符串，该方法接受两个参数，第一个参数可以是个RegExp对象或者一个字符串（不会被转化为正则表达式），第二个参数可以是一个字符串或者函数（在下面又列了一个表，表示字符串可用的一些特殊字符序列） split() 接受两个参数，第一个参数可以是字符串也可以是RegExp对象，是指定的分隔符，第二个可选的参数，用于指定数组的大小，返回一个数组 localeCompare() 一个字符串，字符串参数在字母表排前面返回1，相等返回0，之后返回-1 fromCharCode() 一个或多个字符编码，然后转化成对应的字符或字符串 特殊字符序列 字符序列 替换文本 &#36;&#36; &#36; &#36;&#38; 匹配整个模式的子字符串。与RegExp.lastMatch的值相同 &#36;&#39; 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同 &#36;&#96; 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同 &#36;n 匹配第n个捕获组的子字符串，其中n等于0~9 &#36;nn 同上，nn等于01~99 单体内置对象 内置对象，开发人员不必显示地实例化内置对象，因为它们已经实例化了，例如Object、Array、String 单体内置对象，Global和Math Global对象，兜底对象，不属于任何其他对象的属性和方法，最终都是它的属性和方法，事实上，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性 URL编码方法encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便于发送给浏览器，有效的URI中不能包含某些字符，例如空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解；前者作用与整个URI，后者作用于URI中的一段进行编码；对应解码方式为decodeURI()和decodeURIComponent() eval()方法eval()就像一个完整的ECMASCript解析器，它只接受一个参数，即要执行的ECMAScript字符串，eval()中创建的任何变量或函数都不会被提升，严格模式下报错，而且可能会被代码注入，请谨慎使用 Global对象的属性undefined、NaN、Infinity、Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError window对象ECMASript没有指出如何访问Global()对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性 单体内置对象 Math()对象 Math对象的属性Math对象包含的属性大都是数学计算中可能会用到的一些特殊值，属性表 min()和max()方法var max = Math.max(3,54,32,16) //54var values = [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math, values) //Math作为apply()的第一个参数，从而正确的设置this值，然后将任何数组作为第二个参数 舍入方法Math.ceil()上舍，Math.floor()下舍，Math.round()四舍五入 random()方法返回一个大于0小于1的随机数例如：值 = Math.floor(Math.random()*可能值的总数+第一个可能的值) 其他方法，方法表 属性 说明 Math.E 自然对数的底数，即常量e的值 Math.LN10 10的自然对数 Math.LN2 2的自然对数 Math.LOG2E 以2为底e的对数 Math.LOG10E 以10为底e的对数 Math.PI &pi;的值 Math.SQRT1_2 1/2的平方根（即2的平方根的倒数） Math.SQRT2 2的平方根 方法 说明 方法 说明 Math.abs(num) 返回num的绝对值 Math.asin(x) 返回x的反正弦值 Math.exp(num) 返回Math.E的num次幂 Math.atan(x) 返回x的反正切值 Math.log(num) 返回num的自然对数 Math.atan2(y,x) 返回y/x的反正切值 Math.pow(num,power) 返回num的power次幂 Math.cos(x) 返回x的余弦值 Math.sqrt(num) 返回num的平方根 Math.sin(x) 返回x的正弦值 Math.acos(x) 返回x的反余弦值 Math.tan(x) 返回x的正弦值","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript DOM 编程艺术 阅读笔记","slug":"JavaScript-DOM-编程艺术-阅读笔记","date":"2018-01-07T08:03:38.000Z","updated":"2018-01-23T14:28:19.521Z","comments":true,"path":"2018/01/07/JavaScript-DOM-编程艺术-阅读笔记/","link":"","permalink":"http://chinti.xyz/2018/01/07/JavaScript-DOM-编程艺术-阅读笔记/","excerpt":"前言&#160; &#160; &#160;&#160;开始正式起步JavaScript的学习了，根据知乎的建议买了两本书《JavaScript DOM编程艺术》以及《JavaScript高级程序设计》，我打算先从编程艺术入手，全书将会围绕着一个具体的网页效果展开，使读者对JavaScript有个整体的了解。","text":"前言&#160; &#160; &#160;&#160;开始正式起步JavaScript的学习了，根据知乎的建议买了两本书《JavaScript DOM编程艺术》以及《JavaScript高级程序设计》，我打算先从编程艺术入手，全书将会围绕着一个具体的网页效果展开，使读者对JavaScript有个整体的了解。 第一章：JavaScript简史&#160; &#160; &#160;&#160;正如其名，本章主要介绍了JavaScript的起源，还有浏览器战争和DOM演变史。 JavaScript的起源，它是由Netscape公司与Sun公司合作开发的。在它出现之后，网页的可交互性得到了显著改善。JavaScript是一种脚本语言。 DOM是一套对文档的内容进行抽象和概念化的方法。 浏览器战争 DHTML，是Dynamic HTML(动态HTML)的缩写，它不是一个新技术，而是描述HTML、CSS和JavaScript技术组合的术语，其含义为 利用HTML把网页标记为各种元素 利用CSS设置元素样式和它们的显示位置 利用JavaScript实时的操控页面和改变样式 浏览器之间的冲突，Netscape公司的DOM和微软公司的DOM采用了不一样的方式，导致脚本不得不编写两次，并且为了确保正确向浏览器提供脚本，程序员必须写一些代码去探查在客户端运行的浏览器是哪一种 制定标准，W3C结合大家的优点推出了一个标准化的DOM 浏览器以外的考虑，DOM是一种API（应用编程接口），它可以使人们更方便的交流与合作 浏览器战争的结局，微软战胜了Netscape只是因为IE随系统附带而已 崭新的起点，现今几乎所有的浏览器都内置了对DOM的支持，只要遵循最新的DOM标准，就可以大胆去做 第二章：JavaScript语法&#160; &#160; &#160;&#160;本章主要是介绍JS语法，其实大多数与其他语言差不多，稍微记一些差别就行 准备工作，只需要文本编辑器（嗯 继续用记事本）和一个浏览器，可以通过两种方式执行JS代码 第一种方式是将JS代码放入head标签中的script标签之间 第二种方式是将代码存在一个扩展名为.js的独立文件，典型方式为在head放一个script并将它的src指向该文件，例如：&lt;script src = &quot;file.js&quot;&gt;&lt;/script&gt;,但是更好的方式是将script放在HTML文档末尾，&lt;/body&gt;之前，可以使浏览器更快的加载页面 本章给了一个text.html其中&lt;html lang = &quot;en&quot;&gt;用于向搜索引擎表示该页面为html语言，且语言为英语，lang代表language，若想改成中文，可使用zh-CN 语法，语句，注释（//,/*...*/,&lt;!--）推荐使用前两个 变量（variable）与赋值（assignment），JS允许程序员直接对变量赋值无需事先声明，但是提前声明是一种良好的编程习惯,在JS中是区分大小写的，变量名中不允许包含空格或标点符号（美元符号$除外），同时第一位不允许是数字 1var mood = &quot;happy&quot;,age = 33; 为了使变量易于阅读，可以在变量名中的适当位置插入下划线，例如var my_mood = &quot;happy&quot;;另一种方式称为驼峰式（camel case）,删除下划线，后面的新单词改用大写字母开头，例如var myMood = &quot;happy&quot;;,其中happy被称为字面量（literal），我想用何种命名方式主要还是靠实际工作中的团队约定吧 数据类型，JS是一种弱类型（weakly typed）语言，所以不需要进行类型声明（typing），所以程序员可随时改变变量的数据类型 字符串，需要用单引号或者双引号包裹住，但是若字符串中包含所用引号，则需要在此之前加一个”\\”进行转义（escaping） 12var height = &quot;about 5&apos;10\\&quot; tall&quot;;alert(height); 数值，布尔值 1234var age = 33.5;var temperature = -20.33333;var sleeping = true; 数组，之前三个都是标量（scalar），而存储一组值则需要数组（array） 123456var beatles = Array(4);var beatles = Array();//不知道元素个数时也能用array[index] = element; //填充（populating）var beatles = Array(&quot;John&quot;,&quot;Paul&quot;,&quot;George&quot;,&quot;Ringo&quot;);var beatles = [&quot;John&quot;,&quot;Paul&quot;,&quot;George&quot;,&quot;Ringo&quot;]//略随便 关联数组，可以使用明确下标，例如字符串,但这种方式不推荐1234var lennon = Array();lennon[&quot;name&quot;] = &quot;John&quot;;lennon[&quot;year&quot;] = 1940;lennon[&quot;living&quot;] = false; 对象(Object)，与数组类似 包含在对象中的数据可以通过两种形式访问，属性（property）和方法（method），为了使对象描述特定的人，需要通过new创建实例 内建对象，比如Array，和它的length属性，还有类似Math对象和Date对象 宿主对象，由浏览器提供的预定义对象被称为宿主对象（host object）12345678var lennon = Object();lennon.name = &quot;John&quot;;lennon.year = 1940;lennon.living = false;var lennon = &#123;name:&quot;John&quot;, year:1940; living:false &#125;; //花括号法Person.mood; Person.walk();var jeremy = new Person; 操作（operation），进行计算和处理数据，和其他的语言差不多，除了要记住字符串与数值拼接在一起会自动转化为字符串，以及记住JS是弱类型语言 条件语句（if…else）,比较操作符（==, &gt;=, &lt;=, &gt;, &lt;, !=, ===, !==）,全等和严格不相等是在比较某些类似false 与””的情况下 逻辑操作符（&amp;&amp;, ||, !）,为了避免歧义”!”后面最好跟（） 循环语句（if, while, do…while, for） 函数，若多次使用同一段代码可以将他们封装为一个函数，通过function定义一个函数的语法（参数argument），且JS拥有许多内建函数，例如alert 书中作者推荐利用下划线命名变量，驼峰法命名函数 变量的作用域，即全局变量和局部变量，在函数内定义变量避免二义性 第三章：DOM 文档：DOM中的”D” 对象：DOM中的”O”,分为三种类型 用户定义对象（user-defined object）：由程序员自行创建的对象 内建对象（naive object）：内建在JS中的对象 宿主对象（host object）：由浏览器提供的对象在JS最初的版本，提供了window对象，通称为BOM（浏览器对象模型），它提供了window.open和window.blur等方法，这些方法实现了到处被滥用的各种弹出窗口和下拉菜单 模型：DOM中的”M”,它代表着”Model”模型，DOM将一份文档表示为一棵树，称为节点树 节点（node） 元素节点 文本节点 属性节点 CSS （class属性 和 id属性） 获取元素，3种DOM方法可以获取元素节点，分别是通过元素ID、通过标签名字和通过类名字 getElementById，文档中每个元素都是一个对象 12345document.getElementById(id)//下面是个例子document.getElementByID(&quot;purchases&quot;)//你可以用typeof操作符验证返回的操作数alert(typeof document.getElementById(&quot;purchases&quot;)); getElementsByTagName，返回一个对象数组，通配符”*” 1234567891011121314 element.getElementsByTagName(tag) //下面是个例子 document.getElementsByTagName(&quot;li&quot;) //再例 alert(document.getElementsByTagName(&quot;li&quot;).length); //再再例 for (var i=0; i&lt;document.getElementsByTagName(&quot;li&quot;).length;i++)&#123; alert(typeof document.getElementsByTagName(&quot;li&quot;)[i])；&#125; //再再再例 var items = document.getElementsByTagName(&quot;li&quot;); for (var i=0; i&lt;items.length;i++)&#123; alert(typeof items[i])； &#125; getElementsByClassName，可以通过类名寻找元素，指定多个类，只需要在两者间加上空格 123getElementByClassName(class)//例alert(document.getElementsByClassName(&quot;important sale&quot;).length); [注]书中P42这里有一段函数用于匹配新老浏览器，现在已无用，但向后兼容性的思想应当记住 获取和设置属性 getAttribute，用于查询属性object.getAttribute(attribute),它不属于document对象，它只能通过元素节点对象调用 setAttribute，允许我们对属性节点值做出修改object.setAttribute(attribute,value)，同样只能用于元素节点 第四章：案例研究：JavaScript图片库&#160; &#160; &#160;&#160;本章将会被带着使用JS和DOM去建立一个图片库，首先编写一个优秀的标记文件，其次编写一个JS函数用以显示用户想要查看的图片，然后利用标记触发函数调用 标记 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;utf-8&quot;&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = &quot;images/fireworks.jpg&quot; title = &quot;A fireworks display&quot;&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/coffee.jpg&quot; title = &quot;A cup of black coffee&quot;&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/rose.jpg&quot; title = &quot;A red,red rose&quot;&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/bigben.jpg&quot; title = &quot;The famous clock&quot;&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = &quot;placeholder&quot; src = &quot;images/placeholder.gif&quot; alt = &quot;my image gallery&quot;&gt;//占位 &lt;script type = &quot;text/javascript&quot; src = &quot;showPic.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 12345678 //DOM方法如下 function showPic(whichpic)&#123; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = whichpic.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,source);&#125; //非DOM方法如下,推荐使用DOM方法 placeholder.src = source; 应用这个JavaScript函数，添加事件处理函数（event handler）,这里需要注意的是，当你JS打错了会不执行然后页面正常跳转，我傻乎乎的找了半天html哪里写错了。。。 1&lt;a href = &quot;images/fireworks.jpg&quot; title = &quot;A fireworks display&quot; onclick = &quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt; //在每个链接中加入onclick 对这个函数进行扩展 childNodes属性，可以用来获取任何一个元素的所有子元素，使用：element.childNodes,按书中要求我获得了9，是因为空格和换行符也会被解释为节点 nodeType属性，这个属性可以告诉我们节点是哪一种节点，它一共拥有12种值，但其中只有三个有实用价值，元素节点为1，属性节点为2，文本节点为3 nodeValue属性，用于得到和设置一个节点的值：node.nodeValue,这里要注意p元素本身的属性是个空值，你要找它的子节点，例如alert(description.childNodes[0].nodeValue); firstchild和lastchild属性 加上CSS样式 第五章：最佳实践&#160; &#160; &#160;&#160;本章将介绍一些最佳实践，同时向读者介绍了四种思想：平稳退化，分离JavaScript，向后兼容性，性能考虑 过去的错误，很多书中介绍的遗留问题在如今已经得到了解决 不要怪罪JavaScript Flash的遭遇 质疑一切，利用JS改变网页行为，必须三思而后行，确认是否必要 平稳退化，若JS不被浏览器支持，虽然某些功能无法使用，但基本操作仍能顺利完成（现今基本不用担心支持问题） window.open(url,name,features)，第三个参数是利用逗号分割的字符串，用于设定属性，例如尺寸显示位置等 “javascript:”伪协议，用于通过一个链接调用JavaScript函数，例如：&lt;a href = &quot;javascript:popUp(&#39;http://www.example.com/&#39;);&quot;&gt;Example&lt;/a&gt;，在html文档中通过伪协议调用JS代码并不好 内嵌的事件处理函数，类似onclick，&lt;a href = &quot;#&quot; onclick = &quot;popUp(&#39;http://www.example.com&#39;); return false;&quot;&gt;Example&lt;/a&gt;，若用户禁用JS这条链接将毫无作用 谁关心这个，除了禁用JS的浏览器的用户以外，你可以想象用户是搜索机器人，只有极少数搜索机器人可以理解JS代码，若你的网页无法平稳退化，它在搜索引擎上的排名会受到损害12345&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(&apos;http://www.example.com&apos;); return false;&quot;&gt;Example&lt;/a&gt;//精简下&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(this.getAttribute(&apos;href&apos;)); return false;&quot;&gt;Example&lt;/a&gt;//利用DOM提供的的this.href&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(this.href); return false;&quot;&gt;Example&lt;/a&gt; 向CSS学习 结构与样式的分离 渐进增强，“标记良好的内容就是一切” 分离JavaScript，利用id或class作为挂钩&lt;a href = &quot;http://www.example.com/&quot; class = &quot;popup&quot;&gt;Example&lt;/a&gt;，在外部JS文件中完成事件动作element.event = action...，具体步骤： 把文档里的所有链接放入一个数组 遍历数组 若果某个链接的class属性等于popup，就表示这个链接被点击时应该调用popUp()函数 于是，把这个连接的href传给popUp()函数，取消这个链接的默认行为12345678910111213window.load = prepareLinks; //必须function prepareLinks() &#123; var links = document.getElementsByTagName(&quot;a&quot;); for(var i=0; i&lt;links.length; i++)&#123; if(links[i].getAttribute(&quot;class&quot;) == &quot;popup&quot;)&#123; popUp(this.getAttribute(&quot;href&quot;)); return false; &#125; &#125;&#125;function popUp(winURL) &#123; window.open(winURL,&quot;popup&quot;,&quot;width=320,height=480&quot;);&#125; 向后兼容 对象检测，if(method){statements}，但是可读性较差，可以采用逻辑非的方式，if(!method) return false; 浏览器嗅探技术（browser sniffung），这个风险很大，因为浏览器有时会说谎，将自己报告成另外一种浏览器（我想到edge报告自己是chrome） 性能考虑 尽量少访问DOM和尽量减少标记，只要查询某些元素就要遍历整个DOM树，最好的方法就是将第一次结果保存在一个变量中 合并和放置脚本 压缩脚本，代码压缩工具：Douglas Crockford的JSMin、雅虎的YUI Compressor、谷歌的Closure Compiler 第六章：案例研究：图片库改进版&#160; &#160;&#160;&#160;本章是将上一章内容运用进之前所做的图片库 快速回顾，确认它能否支持平稳退化 JS是否分离 结构化程序设计备忘，通常认为函数只有一个出口和入口，但是过分拘泥这点会使代码难以阅读 添加事件处理函数 检查点，检查浏览器是否支持函数 变量名里有什么，用一些有意义的单词命名一长串代码，使代码更加易读和理解 遍历 改变行为 完成JavaScript函数 共享onload事件，将函数与onclick事件绑定，可以采用一个弹性的解决方案addLoadEvent123456789101112function addLoadEvent(func) &#123; var oldonload = window.onload; if(typeof window.onload != &apos;function&apos;) &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 不要做太多假设，在实际工作中，检查需要根据具体情况来做出 键盘访问，onkeypress，但是最好不要用它，且onclick的支持已经够完美 prepareGallery和showPic代码段 12345678910111213141516171819202122232425262728function showPic(whichpic) &#123; if (!document.getElementById(&quot;placeholder&quot;)) return false; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = document.getElementById(&quot;placeholder&quot;); if (placeholder.nodeName != &quot;IMG&quot;) return false; placeholder.setAttribute(&quot;src&quot;,source); if (document.getElementById(&quot;description&quot;)) &#123; var text = whichpic.getAttribute(&quot;title&quot;) ? whichpic.getAttribute(&quot;title&quot;):&quot;&quot;; var description = document.getElementById(&quot;description&quot;); if (description.firstChild.nodeType == 3)&#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125;function prepareGallery() &#123; if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; if (!document.getElementById(&quot;imagegallery&quot;)) return false; var gallery = document.getElementById(&quot;imagegallery&quot;); var links = gallery.getElementsByTagName(&quot;a&quot;); for(var i=0; i &lt; links.length; i++) &#123; links[i].onclick = function() &#123; return showPic(this)? false:true; &#125; &#125;&#125; 把JavaScript与CSS结合起来 DOM Core和HTML-DOM 第七章：动态创建标记&#160; &#160; &#160;&#160;本章主要是介绍一些传统方法和DOM方法 一些传统方法 document.write，最大的缺点是它违背了“行为应该与表现分离”的原则 innerHTML，用它读取内容毫无细节可言，会将标记和字符串一起读出，但是可以用来在js中把一段HTML内容完全替换进这个标签，无法做到插入，在XHTML中可能会忽略这个属性 DOM方法 createElement方法，使用：document.createElement(nodeName)，用于创建元素节点，创建后，它成为了一个文档碎片（document fragment），但它已经具有了一个nodeType和一个nodeName值 appendChild方法，使用：parent.appendChild(child)，用于插入某文档的节点树 createTextNode方法，使用：document.createTextNode(text)，用于创建一个文本节点 一个更复杂的组合12345678910111213 window.onload = function() &#123; var para = document.createElement(&quot;p&quot;); var txt1 = document.createTextNode(&quot;This is &quot;); para.appendChild(txt1); var emphasis = document.createElement(&quot;em&quot;); var txt2 = document.createTextNode(&quot;my&quot;); emphasis.appendChild(txt2); para.appendChild(emphasis); var txt3 = document.createTextNode(&quot; content. &quot;); para.appendChild(txt3); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para);&#125; 重回图片库 insetBefore()在已有元素前插入一个新元素，使用：parentElement.insertBefore(newElement,targetElement)，例如：var gallery = document.getElementById(&quot;imagegallery&quot;); gallery.parentNode.insertBefore(placeholder,gallery) 在已有元素后插入一个新元素，并没有现成的函数，但是可以自己写，具体原理：若此元素为父元素最后一个孩子，使用appendChild，若不是，则利用insertBefore插入这个元素的下一个兄弟元素之前12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; Ajax，这个词用于概括异步加载页面内容的技术 XMLHttpRequest对象，它是Ajax技术的核心，充当浏览器中的脚本与服务器之间的中间人的角色，以往请求都是由浏览器发出，而现在JS也可以通过这个对象自己发送请求和处理响应，书中给了一个ajax例子，这里需要注意，Chrome本地服务器上并不能处理异步，换成火狐浏览器即可解决这个问题 渐进增强与Ajax Hijax 第八章：充实文档的内容&#160; &#160; &#160;&#160;本章将继续实践上一章学到的内容 不应该做什么，不要把重要内容通过DOM技术添加到网页上 把“不可见”变成“可见”，可以利用DOM技术得到隐藏在属性里的信息，创建标记封装这些信息，把这些标记插入到文档 显示“缩略语列表”,并编写displayAbbreviations函数 for (variable in array)可以用于遍历关联数组 过去版本的ie可能无法正常支持abbr，所以需要通过一些判断条件，在不支持时不执行这些js代码，即使某种浏览器会引起问题，但还是尽量不要用嗅探代码 12345678910111213141516171819202122232425262728293031323334353637383940414243 function displayAbbreviations() &#123; if(!document.getElementsByTagName) return false; if(!document.createElement) return false; if(!document.createTextNode) return false; // 取得所有缩略词 var abbreviations = document.getElementsByTagName(&quot;abbr&quot;); if (abbreviations.length &lt; 1) return false; var defs = new Array(); //遍历 for (var i=0; i&lt;abbreviations.length; i++) &#123; if (abbreviations[i].childNodes.length &lt; 1) continue; var definition = abbreviations[i].getAttribute(&quot;title&quot;); var key = abbreviations[i].lastChild.nodeValue; defs[key] = definition; &#125; //创建定义列表 var dlist = document.createElement(&quot;dl&quot;); //遍历定义 for (key in defs) &#123; var definition = defs[key]; //创建定义标题 var dtitle = document.createElement(&quot;dt&quot;); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); //创建定义描述 var ddesc = document.createElement(&quot;dd&quot;); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); //把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; if (dlist.childNodes.length &lt; 1) return false; //创建标题 var header = document.createElement(&quot;h2&quot;); var header_text =document.createTextNode(&quot;Abbreviations&quot;); header.appendChild(header_text); //把标题添加到页面主体 document.body.appendChild(header); //把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 显示“文献来源链接表”，cite属性可以标识blockquote内容引自哪里，但是浏览器一般会完全忽略这个属性，在返回子节点时不要想当然，某些浏览器会将换行符也会解释为一个文本节点 1234567891011121314151617181920212223242526272829 function displayCitations() &#123; if (!document.getElementsByTagName) return false; if (!document.createElement) return false; if (!document.createTextNode) return false; //取得所有引用 var quotes = document.getElementsByTagName(&quot;blockquote&quot;); //遍历引用 for (var i=0; i&lt;quotes.length; i++)&#123; //如果没有cite属性，继续循环 if (!quotes[i].getAttribute(&quot;cite&quot;)) continue; //保存cite属性 var url = quotes[i].getAttribute(&quot;cite&quot;); //取得引用中所有元素节点 var quoteChildren = quotes[i].getElementsByTagName(&quot;*&quot;); //如果没有元素节点，继续循环 if (quoteChildren.length &lt; 1) continue; //取得引用中的最后一个元素节点 var elem = quoteChildren[quoteChildren.length - 1]; //创建标记 var link = document.createElement(&quot;a&quot;); var link_text = document.createTextNode(&quot;source&quot;); link.appendChild(link_text); link.setAttribute(&quot;href&quot;,url); var superscript = document.createElement(&quot;sup&quot;); superscript.appendChild(link); //把标记添加到引用中的最后一个元素节点 elem.appendChild(superscript); &#125;&#125; 显示“快捷键菜单”，accesskey属性可以把一个元素（如链接）与键盘上某个特定的按钮关联在一起，一般来说，Windows系统中，同时按下alt和特定按钮，在Mac中，是按下Ctrl，例Home，不要设置太多快捷键，会与浏览器内置快捷键冲突，常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142function displayAccessKeys() &#123; if(!document.getElementsByTagName) return false; if(!document.createElement) return false; if(!document.createTextNode) return false; //取得文档中所有链接 var links = document.getElementsByTagName(&quot;a&quot;); //创建一个数组 var akeys = new Array(); //便利链接 for(var i=0; i&lt;links.length; i++) &#123; var current_link = links[i]; //若没有accesskey继续循环 if(!current_link.getAttribute(&quot;accesskey&quot;)) continue; //取得accesskey的值 var key = current_link.getAttribute(&quot;accesskey&quot;); //取得链接文本 var text = current_link.lastChild.nodeValue; //存入数组 akeys[key] = text; &#125; //创建列表 var list = document.createElement(&quot;ul&quot;); //遍历访问键 for(key in akeys) &#123; var text = akeys[key]; //创建放到列表项中的字符串 var str = key + &quot;:&quot; + text; //创建列表项 var item = document.createElement(&quot;li&quot;); var item_text = document.createTextNode(str); item.appendChild(item_text); //将列表项添加入列表 list.appendChild(item); &#125; //创建标题 var header = document.createElement(&quot;h3&quot;); var header_text = document.createTextNode(&quot;Accesskeys&quot;); header.appendChild(header_text); //把标题添加到页面主体 document.body.appendChild(header); document.body.appendChild(list);&#125; 第九章：CSS-DOM&#160; &#160; &#160;&#160;本章介绍如何利用DOM技术获取和设置CSS信息 三位一体的网页，结构层、表示层、行为层 style属性，element.style.property，它也是一个对象 在调用诸如font-family这样的属性时，会将中间的连字符解释为减法操作符，需要将他变为驼峰命名法fontFamily，在火狐浏览器中，返回颜色值是以RGB（红，绿，蓝） style属性只能返回内嵌样式，所以几乎没有实用价值。。，但是可以用于设置样式 何时需要设置样式 根据元素在节点树里的位置来设置样式，nextSibling 根据某种条件反复设置某种样式，书中给了一个让表格反复变色的例子，这不是一个很好的做法在现在尽量用CSS完成，例如：tr:nth-child(odd) { background-color: #ffc} 响应事件，CSS提供了:hover等伪class属性，DOM也可以通过onmouseover等事件对HTML元素的状态变化作出响应,同样尽可能利用CSS完成 ClassName属性，之前让DOM直接设置或修改样式，这种做法让“行为层”干了“表示层”的活，不如用JS代码更新这个元素的类名element.className = value;，elem.setAttribute(&quot;class&quot;,&quot;intro&quot;);的方式也可以，用下面这个函数可以添加类 12345678910function addClass(element,value) &#123; if(!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName += &quot; &quot;; newClassName += value; element.className = newClassName; &#125;&#125; 同时，可以对复杂的函数更进一步的抽象，以便通用 1234567891011121314151617181920212223242526272829303132 function getNextElement(node) &#123; if(node.nodeType == 1) &#123; return node; &#125; if (node.nextSibling) &#123; return getNextElement(node.nextSibling); &#125; return null;&#125;function styleHeaderSiblings(tag,theclass) &#123; if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(tag); var elem; for (var i=0; i&lt;headers.length; i++) &#123; elem = getNextElement(headers[i].nextSibling); addClass(elem,theclass); &#125;&#125;function addClass(element,value) &#123; if(!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName += &quot; &quot;; newClassName += value; element.className = newClassName; &#125;&#125;addLoadEvent(function()&#123;styleHeaderSiblings(&quot;h1&quot;,&quot;intro&quot;);&#125;); 第十章：用JavaScript实现动画效果&#160; &#160; &#160;&#160;本章介绍了一些简单动画效果 动画基础知识 位置，static fixed relative absolute 时间，setTimeout(&quot;function&quot;,interval)，第二个是以毫秒为单位设定时间，variable = setTimeout(&quot;function&quot;,interval)，然后clearTimeout(variable)，可以用来取消“等待执行”队列中的某个函数，例：movement = setTimeout(&quot;moveMessage()&quot;,5000) 时间递增量，parseInt(string)和parseFloat(string)可以用于提取字符串中的数字 抽象，这里遇到一个var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+interval+&quot;)&quot;;，这句话一下子略难理解，实际上是repeat存入了一个字符串，然后其中所有的加号即为“和”，利用参数变量代替硬编码常数，你将可以随意重用它 实用的动画，尽量避免内容在页面中移动 提出问题，类似图片库那章，但是这次不是使用onclick事件，而是采用onmouseover事件，显示预览图片切换显示时多少会有点延时，若采用集体照的方式可以避免 overflow，CSS中的这个属性可以用于处理一个元素的尺寸超过容器尺寸的情况，可以用它进行裁剪，它具有四个属性值visible不裁剪，溢出显示，hidden，隐藏，scroll隐藏，但是给一个滚动条，auto，与前一个类似，但是只有在确实溢出时才给滚动条，其中position: relative很重要，可以将子元素的坐标固定在lideshow左上角 变量作用域问题，全局变量会造成冲突，JS允许我们为元素创建属性，element.property = value，而移动元素太慢了，在调节步进时，遇上我们无法把一个元素移动不到一像素的距离，Math.ceil(number)可以返回一个向上取整得数floor向下取整，round四舍五入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 function prepareSlideshow() &#123; if (!document.getElementById(&quot;linklist&quot;)) return false; var slideshow = document.createElement(&quot;div&quot;); slideshow.setAttribute(&quot;id&quot;,&quot;slideshow&quot;); var preview = document.createElement(&quot;img&quot;); preview.setAttribute(&quot;src&quot;,&quot;images/topics.gif&quot;); preview.setAttribute(&quot;alt&quot;,&quot;building blocks of web design&quot;); preview.setAttribute(&quot;id&quot;,&quot;preview&quot;); slideshow.appendChild(preview); var list = document.getElementById(&quot;linklist&quot;); insertAfter(slideshow,list); var links = list.getElementsByTagName(&quot;a&quot;); links[0].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-100,0,10); &#125; links[1].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-200,0,10); &#125; links[2].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-300,0,10); &#125; &#125;function moveElement(elementID,final_x,final_y,interval) &#123; if (!document.getElementById) return false; if (!document.getElementById(elementID)) return false; var elem = document.getElementById(elementID); if (elem.movement) &#123; clearTimeout(elem.movement); &#125; if(!elem.style.left||!elem.style.top) &#123; elem.style.left = &quot;0px&quot;; elem.style.top = &quot;0px&quot;; &#125; var xpos = parseInt(elem.style.left); var ypos = parseInt(elem.style.top); var dist = 0; if(xpos == final_x &amp;&amp; ypos == final_y) &#123; return true; &#125; if (xpos &lt; final_x) &#123; dist = Math.ceil((final_x - xpos)/10); xpos += dist; &#125; if (xpos &gt; final_x) &#123; dist = Math.ceil((xpos - final_x)/10); xpos -= dist; &#125; if (ypos &lt; final_y) &#123; dist = Math.ceil((final_y - ypos)/10); ypos += dist; &#125; if (ypos &gt; final_y) &#123; dist = Math.ceil((ypos - final_y)/10); ypos -= dist; &#125; elem.style.left = xpos + &quot;px&quot;; elem.style.top = ypos + &quot;px&quot;; var repeat = &quot;moveElement(&apos;&quot;+elementID+&quot;&apos;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;; elem.movement = setTimeout(repeat,interval);&#125; 第十一章：HTML5&#160; &#160; &#160;&#160;本章介绍了一些HTML5的新特性 Modernizr，它可以用于检测浏览器可能支持的特性，应用它最好放在head元素中 Canvas，画布，它可以动态创建和操作图形图像，使用规范 音频和视频，HTML5的video元素为在文档中嵌入影片以及与影片交互定义了一种标准方式，同时将这种操作简化为一个标签，格式问题在我看的前一本书《HF HTML&amp;CSS》中也有提及 自定义控件 currentTime，返回当前播放的位置，以秒表示 duration，返回媒体的总时长，以秒表示，对于流媒体返回无穷大 paused，表示媒体是否处于暂停状态 play，在媒体播放开始时发生 pause，在媒体暂停时发生 loadeddata，在媒体可以从当前播放位置开始播放时发生 ended，在媒体播放完成而停止时发生 control，这个属性不要忘记添加在video元素中，书中只给了一个写播放暂停按键的例子 表单，在不支持HTML5的浏览器上可以通过DOM实现 第十二章：综合示例&#160; &#160; &#160;&#160;将这本书所学的内容综合起来完成一个网站 原始资料 站点结构，images，styles，scripts，页面Home About Photos Lives Contact CSS，颜色color，布局layout，版式typography，在这个例子里 内边距放在布局中，外边距放在版式中 标记 JavaScript，先建立一个global.js用于保存一些通用函数例如之前所用到的addLoadEvent(func) insertAfter(newElement, targetElement) addClass(element, value) 页面突出显示highlightPage，利用getAttribute(&quot;href&quot;)获取链接的URL，利用window.location.href获取当前页面的url，indexOf可以用来在字符串中寻找子字符串的位置string.indexOf(substring)，返回-1即为失败 toLowerCase该方法可以将文本转换成小写 点击内部链接后，会在连接后包含一串字符串，以#为分隔符，about.html#jay，这里利用split方法可以便捷的将字符串分成多串，array = string.split(character) 1234567891011121314151617181920212223242526272829303132 function showSection(id) &#123; var sections =document.getElementsByTagName(&quot;section&quot;); for (var i=0; i&lt;sections.length; i++) &#123; if (sections[i].getAttribute(&quot;id&quot;) != id) &#123; sections[i].style.display = &quot;none&quot;; &#125; else &#123; sections[i].style.display = &quot;block&quot;; &#125; &#125;&#125;function prepareInternalnav() &#123; if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; var articles = document.getElementsByTagName(&quot;article&quot;); if (articles.length == 0) return false; var navs = articles[0].getElementsByTagName(&quot;nav&quot;); if (navs.length == 0) return false; var nav = navs[0]; var links = nav.getElementsByTagName(&quot;a&quot;); for (var i=0; i&lt;links.length; i++) &#123; var sectionId = links[i].getAttribute(&quot;href&quot;).split(&quot;#&quot;)[1]; if (!document.getElementById(sectionId)) continue; document.getElementById(sectionId).style.display = &quot;none&quot;; links[i].destination = sectionId; links[i].onclick = function() &#123; //一开始一下子没绕过弯，留个档 showSection(this.destination); return false; &#125; &#125;&#125; JavaScript图片库，将第六章第七章部分代码改一下 增强表格，将第九章代码进行改编 增强表单 字段标签，element.focus()单击一个标签可以将焦点转移到关联的表单字段中 占位符值，onfocus事件会在焦点移入表单字段触发，onblur事件则反之，现代浏览器应该不需要再检查占位符值了吧 replace替换，field.value.replace(&#39; &#39;,&#39;&#39;)将空格替换掉 同时，书上代码中有一段element.required == &#39;required&#39;代码，可能不太能用，required现在是一个bool型，在html中只需些&lt;input ... required&gt;即可，在js中的判断应改为element.required == true 提交表单，添加一点Ajax，首先创建一个加载图像，可以到http://ajaxload.info创建一个，并把此图像命名为loading.gif 假设表单中包含消息“Why does 2+2=4?”，然后根据name=value&amp;name2=value2&amp;name3=value3规则形成一个URL编码的表单数据字符串，例如message=Why does 2+2=4?&amp;name=me&amp;email=me@example.com的形式，但是其中诸如+、=、？可能会造成歧义，JS提供了一个函数encodeURIComponent可以用于把有歧义的字符转换成对应的ASCII码：message=Why%20does%202%2B2%3D4%3F%26&amp;name=Me%email=me%40example.com，join函数可以用来将数组中的所有元素通过一个分隔符进行连接并放入一个字符串中，例如dataParts.join(&#39;&amp;&#39;) 正则表达式，在JS中，正则表达式的每个模式都是以一个斜杠（/）开头和结尾，正则表达式部分待之后在看了书上也没具体写 这本书Ajax部分看的有点糊涂，感觉只是初步的了解，我打算看高级程序设计这本书的时候再结合起来好好理解下 压缩js代码，用以改进性能 书后附录中还简短的介绍了jQuery，不过我打算在《锋利的jQuery》中具体学习","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"2018素描","slug":"2018素描","date":"2018-01-04T04:56:04.000Z","updated":"2018-01-04T05:45:01.489Z","comments":true,"path":"2018/01/04/2018素描/","link":"","permalink":"http://chinti.xyz/2018/01/04/2018素描/","excerpt":"前言&#160; &#160; &#160;&#160;以前画了许多但是搬家什么的也遗失了，大学也没怎么画过，既然重新开始画了，就好好记录下，其实第一张应该是为所欲为，但画的太丑了，不传了","text":"前言&#160; &#160; &#160;&#160;以前画了许多但是搬家什么的也遗失了，大学也没怎么画过，既然重新开始画了，就好好记录下，其实第一张应该是为所欲为，但画的太丑了，不传了 作品2018-01-02 Taylor Swift","categories":[{"name":"绘画","slug":"绘画","permalink":"http://chinti.xyz/categories/绘画/"}],"tags":[{"name":"sketch","slug":"sketch","permalink":"http://chinti.xyz/tags/sketch/"}]},{"title":"Head First HTML与CSS 阅读笔记（CSS部分）","slug":"Head-First-HTML与CSS-阅读笔记（CSS部分）","date":"2017-12-31T08:54:53.000Z","updated":"2018-01-07T11:32:46.446Z","comments":true,"path":"2017/12/31/Head-First-HTML与CSS-阅读笔记（CSS部分）/","link":"","permalink":"http://chinti.xyz/2017/12/31/Head-First-HTML与CSS-阅读笔记（CSS部分）/","excerpt":"前言&#160; &#160; &#160;&#160;本文是《Head First HTML与CSS》的CSS部分，另一部分为Head First HTML与CSS 阅读笔记（HTML部分）。","text":"前言&#160; &#160; &#160;&#160;本文是《Head First HTML与CSS》的CSS部分，另一部分为Head First HTML与CSS 阅读笔记（HTML部分）。 概念常识 CSS验证工具 css中的每一个语句包括一个场所（如卧室），以及这个场所的一个属性（如窗帘或地毯），还要应用到这个属性的一个样式（如蓝色，或者1英寸的瓷砖），使用：1234p&#123; //需要增加样式的元素 background-color: red; //指定样式属性border: 1px solid gray;&#125; 使用方式 在html文件中指定样式，需要在&lt;head&gt;元素中增加&lt;style&gt;， 12345&lt;style&gt;p&#123; //选择器 p选择器会选择HTML中所有的段落 color: maroo; //color 代表文本颜色 maroon 茶红色&#125;&lt;/style&gt; 外部链接，将规则放在XXX.css中，css文件通常被称为”样式表”stylesheet,然后不再需要style元素，将其删除，然后添加外部链接，例如&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;lounge.css&quot;&gt; link用于链入外部信息，rel属性制定了链接的文件关系，这里是样式表所以是stylesheet 规则合并，共通样式合并起来写，特定样式写在另一个规则里 1234h1，h2&#123; font-family: sans-serif; color: gray;&#125; 可以使用多个样式表，按照顺序通过link元素将样式表链入HTML文件，最下面的样式表最优先 在link元素中添加media属性，可以适用于指定设备的样式文件，使用方式如下 123 &lt;link href=&quot;lounge-mobile.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 480px)&quot;&gt; //创建了一个查询，指定了一个有屏幕的设备，且屏幕宽度不超过480像素&lt;link href=&quot;lounge-print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt; //匹配了打印机 查询中还有很多属性可用，例如min-device-width、max-device-width，以及显示方向[orientation,这可以是横向（landscape）或纵向（portrait）]，此外还有许多其他属性，根据需要添加多个link，涵盖所要支持的全部设备 直接在CSS中增加媒体查询(IE8及以前版本不支持媒体查询)，例： 123456789101112131415161718@media screen and (min-device-width: 481px) &#123; #guarantee &#123; margin-right: 250px; &#125;&#125;@media screen and (max-device-width:480px) &#123; #guarantee &#123; margin-right: 30px; &#125;&#125;@media print &#123; body &#123; font-family: Times, &quot;Times New Roman&quot;, serif; &#125;&#125;p.special &#123; color: red;&#125; 选择器与类 只能为body添加样式 可以用于定义一类元素 首先，为HTML中的元素添加一个class属性，其次，在CSS中选择这个类 类选择器，先选择类中的元素，再用”.”指定一个类 1234567&lt;p class = &quot;greentea&quot;&gt;...&lt;/p&gt; //HTMLp.greentea&#123; color: green;&#125; //CSS id选择器，方法如类选择器，除了不用”.”改用用”#”指定id 子孙选择器，父元素和子孙元素名之间放一个空格，使用： 123#exlixirs h2 &#123; color: black;&#125; 属性选择器，可以根据属性值来选择元素，如： 123img[width] &#123; border: black thin solid; &#125;img[height = &quot;300&quot;] &#123; border: red thin solid; &#125;image[alt~=&quot;flowers&quot;] &#123; border: #ccc thin solid; &#125; 按兄弟选择，可以使用一个”+” 123h1+p &#123; font-style: italic;&#125; 结合选择器 首先定义上下文，代表id为greentea的div必须是blockquote的父元素 然后给出你想选择的元素 然后指定伪类或伪元素：1div#greentea &gt; blockquote 1div#greentea &gt; blockquote p 123div#greentea &gt; blockquote p:first-line &#123; font-style: italic;&#125; 直接孩子，使用#elixir&gt;h2 复杂选择，方式一样，例如#elixir blockquote h2 合并类规则 12345blockquote.greentea,p.greentea&#123; color: green;&#125; //CSS&lt;blockquote class = &quot;greentea&quot;&gt; //HTML 省略所有元素名，只有一个点，即可运用到全部成员 123.greentea&#123; color: green；&#125; 一个元素可以拥有多个类，&lt;p class = &quot;greentea raspberry blueberry&quot;&gt; id属性，与类类似，但是id具有唯一性，一个元素不能有多个id，另外页面上不允许多个元素都有相似的id 12345&lt;p id=&quot;footer&quot;&gt;...&lt;/p&gt;#footer &#123; ...&#125;//p#footer 类名要以一个字母开头，id可以以一个数字或者字母开头，它们都可以包含字母、数字以及_字符，但不能有空格 继承 元素能从他们的父元素继承一部分样式 例如，font-family 继承的样式可以被覆盖 如果样式会影响文本的外观，那么所有的这样子的样式都会被继承，比如：color、font-family、font-size、font-weight、font-style等等 其他的一般都不能被继承，如果不确定可以尝试一下 /* */注释 层叠 浏览器用多个样式表组织样式，最优点的是作者的样式，然后是读者的样式，最后才是浏览器的默认样式 读者如果在某个属性声明的最后加上”!important”，那么他就能覆盖作者的样式 浏览器想知道某个元素的属性，会通过5个步骤 收集所有样式表 找到所匹配的声明 现在对所有匹配的规则排序 现在按特性对所有声明排序 最后，对于冲突的规则，按照它们在各自的样式表中出现的顺序进行排序 求特定性，特定性由一组3个数开始，000 这个选择器包含id吗？每个id加1分 这个选择器包含类或伪类么？每个类或伪类加1分 这个选择器包含元素名吗？一个元素名加1分 然后将他们读作真正的数，其中100&gt;010&gt;001 注意，我们只在作者、读者和浏览器类别范围内排序，并不对整个列表重新排序 属性color 颜色 color 设置文本元素的前景色 background-color 控制元素的背景颜色 常用颜色Aqua Black Blue Fuchsia Gray Green Lime Maroon Navy Olive Purple Red Sliver Teal White YellowCSS只定义了16个基本颜色和大约150个颜色名 按红绿蓝指定颜色，例： 123456body&#123; background-color: rgb(80%, 40%, 0%);&#125;//数字也可以指定为0到255之间的一个数值body&#123; background-color: rgb(204, 102, 0);&#125; 十六进制码，前两位表示红色，中间两位表示绿色，最后两位表示蓝色,且如果每两位数字都相同，那可以缩写成类似#cb0的写法 可以利用诸如PS等应用找到Web颜色，或者使用在线颜色表 font 字体 font-family字体样式 5个字体系列：sans-serif、serif、monospace、cursive、fantasy Serif字体系列，Times、Times New Roman 、Georgia，具有衬线，常见到报纸上的排版 Sans-serif字体系列，Verdana、Arial Black、Trebuchet MS、Arial、Geneva，没有衬线，在计算机屏幕上更容易读 Monospace字体系列，Courier、Courier New、Andale Mono字体包含固定宽度的字符，主要用于软件代码显示 Cursive字体系列，Comic Sans、Apple Chancery，一些看似手写的字体，常在标题里看到 Fantasy字体系列，Last Ninja、Impact，某种风格的装饰性字体 使用CSS指定字体系列，123body&#123; font-family: Verdana, Geneva, Arial, sans-serif;&#125;//浏览器从第一个开始找，没有的话就往后，还没有就使用浏览器默认的sans-serif字体 font-style 用来设置斜体文本，italic oblique斜体和倾斜 font-weight 用来设置粗体，lighter normal bold bolder text-decoration用来增加装饰，none underline overline line-through @font-faceWeb字体 允许你定义一种字体的名字和位置，然后在页面中使用 常用字体格式：TrueType字体：.ttf,OpenType字体：.otf,Embedded Opentype字体：.eot,SVG字体：.svg,Web开放字体格式：.woff 现代浏览器上支持的最为广泛的格式是Web开放字体格式 将字体文件放到web上 使用：12345@font-face &#123; font-family: &quot;Emblema One&quot;; src: url(&quot;http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.woff&quot;), url(&quot;http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.ttf&quot;)&#125;//我这边浏览器没啥效果。。不知道是什么问题 字体大小 font-size: 14px;字的高度为14像素高 font-size: 150%;字相对于另一个字体的大小，若从父元素继承了，就是相对于父元素的大小 font-size: 1.2em; 比例系数 除此之外，还可以将文字大小指定为，xx-small, x-small, small, medium, large, x-large或xx-large，浏览器会将这些关键字转为像素值，其中small为12像素，然后每个大小大约比前一个大20% 通常，可以选一个关键字（推荐small或medium），然后利用em或者百分数相对body指定其他元素字体大小。 默认情况下，h1是200%，h2是150%，h3是120%，h4是100%，h5是90%，h6是60% 浏览器默认16像素 字体可以简写，所需的所有属性为font-family,font-style,font-weight,font-size,font-variant,line-height,按照这个顺序font-style font-variant font-weight font-size/line-height font-family，前三个顺序不重要，非必需，但一定要在font-size前，font-size必须指定 盒模型 CSS将每个元素视为盒模型（box model），每个盒模型由一个内容区以及可选的内边距，边框和外边框组成，其中，内容区（content area）包含内容（例如文本和图像），内容区被可选的透明内边距（padding）包围，内边距周围可能放置一个可选的边框（border），最后有一个可选的透明外边距（margin）包围所有部分 border-style可以控制边框的视觉样式，共8种（solid实线，double双线，groove槽线，outset外凸，dotted虚线，dashed破折线，inset内凹，ridge脊线） border-width控制边框宽度，可以采用关键字或者像素指定（thin medium thick） border-color控制边框颜色，与设置颜色类似 指定某一边的边框，可以使用这样的形式：border-top-color border-bottom：thin dotted #888888;灰色细虚线 border-radius： 15px创建圆角，可以利用px或者em指定半径大小 padding 内边距，可以采用缩写，按照top right bottom left的顺序，若四个值相同，那只需写一个就行了 line-height 行间距,比较特殊，可以直接用数字,代表自己字体大小的倍数 letter-spacing 字母之间间距 list-style 列表外观 text-align 内联元素对齐，可以设置ceter width 可以设置元素宽度，不设置默认auto background-image 元素后面放置一个图像，使用：background: url(images/background.gif); background-position,用于设置图像位置，可以按像素指定，也可以指定为一个百分数，或者采用关键字（top、left、right、bottom、center） background-repeat，用于控制平铺行为（no-repeat,repeat-x,repeat-y,inherit，repeat） border，background都可以简写 a元素和它的多重人格 页面上的链接可以有多种状态：可能未访问、已访问或者处于悬停状态（还有其他状态），可能会用到伪类 此外还有：focus和active状态，浏览器将焦点放在连接上就是焦点状态（用TAB键，键盘输入时），用户第一次单击一个链接时就处于活动状态 适当的顺序为，link，visited，hover，focus，然后是active 使用方式：123456789a:link &#123; color: green;&#125;//未访问a:visited &#123; color: red;&#125;//已访问a:hover &#123; color: yellow;&#125;//悬停 伪类（Pseudo-class） 表现的像个类，但并不是真正的类，例如之前的a:visited a:link a:hover还有first-child 伪类不知能处理链接，也能够对其他类型的元素提供处理 布局与定位流 流实际上就是浏览器在页面上摆放HTML元素所用的方法 浏览器从HTML文件最上面开始，从上到下沿着元素流逐个显示所遇到的各个元素 块元素自上而下流，每个块元素之间加一个换行 内联元素在水平上挨着，总体上从左上方流向右下方 外边距，并排放置，外边距叠加，上下放置，取决于最大外边距 float 首先它会尽可能远的向左或向右浮动一个元素，然后它下面的所有内容会绕流这个元素 对于所有的浮动元素都有一个要求：它必须有一个宽度 浮动元素外边距不会被折叠，注意这点可以避免一些错误 内联元素同样可以浮动，常见为浮动一个图像 float属性可以设置为left或者right 此时没浏览器会如下处理float 首先，浏览器正常将元素流入页面，从文件最上面开始，逐步移向末尾元素 浏览器遇到浮动元素，会将其尽可能放在最右边，然后从流中删除这个段落 然后其他块元素会填在这里，就像根本没这个段落 不过，在内联元素定位时，它们会考虑浮动元素的边界，所以会围绕着浮动元素 实现两栏效果 将sidebar放在页眉下面，然后用float将sidebar栏向右浮动，然后将主内容的右外边距至少设置得和sidebar的宽度相同，这样主内容区和边栏就会分开，但是宽度太宽时，页脚会上移造成重叠 可以利用clear属性解决这个问题，在footer中设置clear: right,代表这个元素右边不允许有浮动元素，此时还有另一个问题，在小的移动设备会看到边栏在最上面，因为我们把sidebar放在了主要内容前 可以采用右紧左松，也就是将主内容向左浮动，设置仿照如上，这样内容的顺序会是对的，但是边栏看起来非常松散 流体与冻结设计 流体布局（liquid layouts），不论浏览器调整到多大的宽度，布局都会扩展，填满整个浏览器，而有时候布局锁定更为重要，这样当用户调整屏幕大小时，你依然可以保持原样，这被称为冻结布局（frozen layouts） 首先，你需要将body内的所有内容放置于一个id为”allcontent”的&lt;div&gt;元素内123456#allcontent&#123; width: 800px; padding-top: 5px; padding-bottom: 5px; background-color: #675c47;&#125; 这样页面宽度将被限制为800px，在页面很宽时，右边很多空白空间 凝胶布局 这是Web上常见的一种设计，介于冻结与流体之间，称为凝胶（Jello），它会锁定页面中内容区的宽度，不过会将它在浏览器中居中12345678#allcontent&#123; width: 800px; padding-top: 5px; padding-bottom: 5px; background-color: #675c47; margin-left: auto; margin-right: auto;&#125; 绝对定位 可以在页面上精确的定位元素，同时采用绝对定位可以实现一些漂亮的效果 一个元素绝对定位时，浏览器首先将它从流中完全删除，然后浏览器将这个元素放置在位置属性所制定的位置上，绝对定位是相对于最近的已定位的祖先元素，例： 123456#sidebar &#123; positon: absolute; top: 100px; right: 200px; width: 280px;&#125; 同时，在绝对定位时，一个元素可有放在另一个绝对定位的元素之上，那么谁在上面？每个定位元素（绝对、相对、固定定位的元素）都有一个名为z-index的属性，将会指定它在一个虚拟z轴上的位置，越上面的，z-index越大，使用：z-index: 1;就可以确保在其他的元素上方，但是有多个需要定位的元素，那需要好好考虑下数值。 position拥有4个值：static， absolute， fixed 和 relative，其中固定（Fixed）定位是将元素放在相对于浏览器窗口的一个位置上（而不是相对与页面），所以固定元素永远不会移动，而相对（Relative）定位会让元素正常流入页面，不过在页面上显示“相对于”自己的起点要进行偏移，相对定位常用于更高级的定位和特殊效果 绝对定位元素不必须指定宽度，但是，会占据浏览器整个宽度，这可能并不是你想要的 指定位置还可以使用百分数，但是位置可能会改变，百分数还常用与制定宽度，可以使主内容区和边栏的大小更为灵活 CSS表格 类似电子表格只包含行和列 为整个表格创建一个块，然后为每行创建块，例： 12345678910&lt;div id = &quot;tableContainer&quot;&gt; &lt;div id = &quot;tableRow&quot;&gt; &lt;div id = &quot;main&quot;&gt; ... &lt;/div&gt; &lt;div id = &quot;siderbar&quot;&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS实现 12345678910111213141516171819202122 div#tableContainer &#123; display: table; border-spacing: 10px; //单元格间距 &#125; div#tableRow &#123; display: table-row; &#125; #main &#123; display: table-cell; background: #efe5d0 url(images/background.gif) top left; font-size: 105%; padding: 15px; vertical-align： top; //单元格上对齐&#125; #sidebar &#123; display: table-cell; background: #efe5d0 url(images/background.gif) bottom right; font-size: 105%; padding: 15px; vertical-align： top;&#125; 开发商特定的CSS属性 首先一个短横线一个开发商标识符在加另一个短横线在加属性，如 1-moz-transform 建立变换与过渡 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS Transforms and Transitions&lt;/title&gt; &lt;style&gt; #box &#123; position: absolute; top: 100px; left: 100px; width: 200px; height: 200px; background-color: red; transition: transform 2s; -webkit-transition: -webkit-transform 2s; -moz-transition: -moz-transform 2s; -o-transition: -o-transform 2s; /* no IE support for transition until possibly IE 10 */ &#125; #box:hover &#123; transform: rotate(45deg); -webkit-transform: rotate(45deg); /* Safari, Chrome, mobile Safari, and Android */ -moz-transform: rotate(45deg); /* Firefox */ -o-transform: rotate(45deg); /* Opera */ -ms-transform: rotate(45deg); /* IE 9 */ &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chinti.xyz/tags/CSS/"}]},{"title":"Head First HTML与CSS 阅读笔记（HTML部分）","slug":"Head-First-HTML与CSS-阅读笔记（HTML部分）","date":"2017-12-26T04:56:11.000Z","updated":"2018-01-07T07:18:17.448Z","comments":true,"path":"2017/12/26/Head-First-HTML与CSS-阅读笔记（HTML部分）/","link":"","permalink":"http://chinti.xyz/2017/12/26/Head-First-HTML与CSS-阅读笔记（HTML部分）/","excerpt":"前言&#160; &#160; &#160;&#160;在之前17年6月实习时，负责了管理公司论坛的任务，在此之中初步接触到了HTML和CSS方面的知识，但是学习的不够深入，现在是17年年底，打算重新开始学习这方面的知识，做一些巩固，为之后学习JavaScript与Jquery等打下基础。&#160; &#160; &#160;&#160;《Head First HTML与CSS》是一本对新手友好的前端入门书，虽然废话很多，插画也多的像连环画，但是作为第一本前端书籍是十分合适的，毕竟我认为保持高涨的兴趣才是进步的动力。&#160; &#160; &#160;&#160;本书第一章到第六章介绍了HTML部分（第五章有部分发布的知识，暂且略过），第十二章讲述了HTML5的新特性，而十三到十五章则将HTML与CSS同时进行介绍。本篇博客主要整理HTML部分的知识点。另一篇部分为Head First HTML与CSS阅读笔记（CSS部分）","text":"前言&#160; &#160; &#160;&#160;在之前17年6月实习时，负责了管理公司论坛的任务，在此之中初步接触到了HTML和CSS方面的知识，但是学习的不够深入，现在是17年年底，打算重新开始学习这方面的知识，做一些巩固，为之后学习JavaScript与Jquery等打下基础。&#160; &#160; &#160;&#160;《Head First HTML与CSS》是一本对新手友好的前端入门书，虽然废话很多，插画也多的像连环画，但是作为第一本前端书籍是十分合适的，毕竟我认为保持高涨的兴趣才是进步的动力。&#160; &#160; &#160;&#160;本书第一章到第六章介绍了HTML部分（第五章有部分发布的知识，暂且略过），第十二章讲述了HTML5的新特性，而十三到十五章则将HTML与CSS同时进行介绍。本篇博客主要整理HTML部分的知识点。另一篇部分为Head First HTML与CSS阅读笔记（CSS部分） [注]书中所有代码可在代码地址找到。 概念简称 HTML是HyperText Markup Language的缩写，译为超文本标记语言，用来建立网页的结构。 CSS是Cascading Style Sheets的缩写，译为层叠样式表，用来控制HTML的表现。 常识 由于浏览器会忽略制表符、回车和大部分空格，但是为了提高HTML文档的可读性，利用这些会很有帮助。 按照一定标准编写html，可以减少不同浏览器之间的差异度甚至不兼容。 属性的写法都是一样的：首先是属性名，后面一个等号，然后是双引号括起来的属性值，不严谨的写法可能会出现问题。 文件夹层数没有限制，但是过多的情况下，可能说明网站组织太复杂。 尽可能使用元素告诉浏览器你的内容的含义 web服务器默认文件名为”index.html”或”default.htm”，根据不同服务器。没有斜线的情况下，如果该目录存在，浏览器会自动添加末尾的斜线 端口默认为80 嵌套 根元素，子元素 了解如何嵌套，可以避免标记不匹配，不要越界 元素 块（block）元素：特立独行,&lt;h1&gt;、&lt;h2&gt;、...、&lt;h6&gt;、&lt;p&gt;和&lt;blockquote&gt; 内联（inline）元素：随波逐流,&lt;q&gt;、&lt;a&gt;和&lt;em&gt; void元素：没有实际内容，可以使用简写，提高效率 交互性 html不只是一个被动的文档，它可以拥有可执行的内容，可以使用JavaScript脚本语言来编写程序或脚本 通过JavaScript调用HTML5提供的一些API可以创建许多Web应用 特殊字符 &lt; 可以使用&amp;lt代替 &gt; 可以使用&amp;gt代替 &amp; 可以使用&amp;amp代替 更多常见特殊字符可以在常见字符地址（书上的404了）找到，如果需要更为详尽的字符实体清单可以在详尽字符地址找到。 工具[注]学习环境是Windows10 Notepad（记事本） 主要工具 WebStorm Dreamweaveretc. 浏览器[注]为了在多个浏览器测试效果的细微差别，所以至少要下载并了解两个不同的浏览器。 Chrome Internet Explorer Firefox Opera Safarietc. HTML首部[注]元素=开始标记+内容+结束标记 &lt;html&gt;标签，它总会是一个根元素html 告诉浏览器文件内容是HTML，使用：&lt;html&gt;...&lt;/html&gt;包围你的的HTML 头部head 包含Web页面的有关信息，只能放置&lt;title&gt;&lt;meta&gt;&lt;style&gt;元素。 title 页面标题 meta 关于页面的信息 style 页面样式，例&lt;style type=&quot;text/css&quot;&gt;...&lt;/style&gt;然后在里面可以写body{...}等CSS语法（CSS部分将会整理在另一篇博客）。 [注]编写HTML时要把首部和页面主体分开。 HTML页面主体 主体body web页面的主体元素 标题h1 h2 h3 h4 h5 h6 共六级标题，使用：&lt;h1&gt;标题&lt;/h1&gt; 段落p 块元素，使用：&lt;p&gt;...&lt;/p&gt;small专为极小字体设计，可用于版权信息 超链接 &lt;a href=&quot;链接地址&quot;&gt;链接文本&lt;/a&gt; href是hypertextreference的缩写，意思为超文本引用。 &lt;img&gt;元素也可以放在&lt;a&gt;标记之间 ../dotdot代表向上到父级文件夹 title 提供链接信息 id 用来为目标创建标识符，必须是唯一的，例：&lt;h2 id=&quot;chai&quot;&gt;Chai Tea&lt;/h2&gt;,然后使用方法如下：&lt;a href=&quot;index.html&quot;#chai&gt;See Chai Tea&lt;/a&gt; target属性，使用：target=&quot;_blank&quot;代表在新窗口打开 内部网页采用相对路径，外部网页采用绝对路径 默认的，这个标签具有下划线且可以点击 保证链接标签简洁且有意义（不要使用这里或者这一页的标签），在title属性中提供额外信息，且不要将链接放在一起 强调em内联元素，使用：&lt;em&gt;...&lt;/em&gt; 删除del将某些内容标记为要删除内容（删除线） 插入ins标记要插入的内容（下划线） 换行br用于换行，使用&lt;br&gt;，它是一个void元素，处理XHTML时可以用&lt;/br&gt; 代码code，块元素，用来显示计算机程序代码 加粗strong，内联，用来标记特别强调的文本 原样显示pre，希望浏览器按你输入的方式原样显示文本，使用这个元素指定文本格式 时间time，这个元素告诉浏览器这个内容是个日期或时间 图像img图片 src属性，指定img的源文件地址。可以指定相对地址，该属性必须填写，与href属性类似。 alt属性，指定描述这个图像的一些文字，在图像无法显示时替代显示文本，可用于帮助视力障碍的用户 width属性，指定宽度 height属性，指定高度，高度与宽度都是由像素数指定 图片格式 常见格式为：JPEG、PNG和GIF 照片和复杂图像使用JPEG，单色图像、logo和几何图形使用PNG或GIF 规范 指定长宽，可以使页面在显示图像之前就建立布局 指定长宽可以用于缩放图像，但它会先获取完整图像 浏览器宽度通常被设为800到1280像素之间，所以图像宽度要小于800 可以用photoshop等图像编辑软件调整图片大小 引用 &lt;q&gt; 短引用，不是所有浏览器都会在&lt;q&gt;的内容两边加上引号。去掉双引号用&lt;q&gt;可以让页面更加结构化，更有意义。是一个内联元素。 &lt;blockquote&gt;长引用，需要被单独显示。是一个块元素。 列表 li列表项 ol有序列表，ordered list的简写，由浏览器编号 ul无序列表，unordered list的简写 第一步，每个列表项都要放在单独的&lt;li&gt;元素中，第二步，用&lt;ol&gt;或&lt;ul&gt;包围所有列表项 可以为列表添加一些样式，列表的主要属性是lis-style-type,disc是默认的列表标记类型，circle，提供一个简单的圆形标记，square方块标记，none删除标记 定制标记，list-style-image: url(images/backpack.gif); 文本回绕，list-style-position,inside标记下回绕，outside文本下回绕 容器逻辑区就是页面上一组彼此相关的元素，通过div或者span容器来标记一组元素div块元素容器 在属于一个逻辑区的元素周围放置&lt;div&gt;开始和结束标记 利用&lt;div&gt;为页面增加更多的结构，可以进一步展现页面的底层逻辑结构，帮助别人理解你的页面 有需要的话，可以在结构上增加结构 很多情况下，会创建&lt;div&gt;并把他们放在类中 span内联元素容器 类似div，只是创建的是内联元素 表格 用table标记一个表格的开始，每行tr开始，th代表每列的表头，其余由td标记 1234567891011121314151617181920212223242526&lt;table&gt; &lt;tr&gt; &lt;th&gt;City&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Temperature&lt;/th&gt; &lt;th&gt;Altitude&lt;/th&gt; &lt;th&gt;Population&lt;/th&gt; &lt;th&gt;Diner Rating&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Walla Walla, WA&lt;/td&gt; &lt;td&gt;June 15th&lt;/td&gt; &lt;td&gt;75&lt;/td&gt; &lt;td&gt;1,204 ft&lt;/td&gt; &lt;td&gt;29,686&lt;/td&gt; &lt;td&gt;4/5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Magic City, ID&lt;/td&gt; &lt;td&gt;June 25th&lt;/td&gt; &lt;td&gt;74&lt;/td&gt; &lt;td&gt;5,312 ft&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;td&gt;3/5&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; caption 标题,放在table下，tr上,可以在CSS指定它的位置，大多数浏览器默认显示在表格上方 12345678910111213141516171819202122&lt;caption&gt; The cities I visited on my Segway&apos;n USA travels&lt;caption&gt;//CSS部分table &#123; margin-left: 20px; margin-right: 20px; border: thin dotted gray; caption-side: bottom; //指定位置&#125;td, th &#123; border: thin dotted gray; padding: 5px;&#125;caption &#123; font-style: italic; padding-top: 8px;&#125; border-spacing 边框间距，每个表格单元的外边距不能被设置，只能设置共同间距，而且可以在垂直方向和水平方向设置不同间距，例如border-spacing: 10px 30px;代表设置了10像素水平边框间距，30像素的垂直边框间距 border-collapse 边框折叠，使用：border-collapse: collapse; 颜色交替，一种通过定义类还有一种通过伪类nth-child这是一种更高级的指定方法 12345678910111213p:nth-child(even) &#123; background-color: red;&#125;p:nth-child(odd) &#123; background-color: green;&#125;//或者可以用表达式 p:nth-child(2n) &#123; background-color: red;&#125;p:nth-child(2n+1) &#123; background-color: green;&#125; 合并单元格，当存在一个单元格跨多行时，可以使用rowspan属性，指定一个表格数据单元格占的行数，然后将这个单元格所跨越的其他行删除相应的表格数据元素,同理，colspan属性可以用来跨多列 12345678910111213141516&lt;tr&gt; &lt;td rowspan = &quot;2&quot;&gt;Truth or Consequences, NM&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;August 9th&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;93&lt;/td&gt; &lt;td rowspan = &quot;2&quot; class = &quot;right&quot;&gt;4,242 ft&lt;/td&gt; &lt;td rowspan = &quot;2&quot; class = &quot;right&quot;&gt;7,289&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;5/5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td class = &quot;center&quot;&gt;August 27th&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;98&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;4/5&lt;/td&gt;&lt;/tr&gt; 表格嵌套，在表格里再放个table 表单 form表单元素，几乎所有块级元素都可以放在里面,action属性包含Web服务器脚本的URL，method属性确定表单数据如何发送到服务器，常用方法POST 1234567&lt;form action=&quot;http://wickedlysmart.com/hfhtmlcss/contest.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Just type in your name (and click Submit) to enter the contest:&lt;br&gt; First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;&quot;&gt;&lt;br&gt; Last name: &lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt; input元素用于输入一行文本，它还有一些可选的属性，允许你为这个控件设置最大字符个数和宽度，void内联元素，其中提交按钮需要指定”submit”作为input元素的type属性值，”radio”可以单选按钮，若有checked布尔属性则默认选中，”checkbox”复选框，相关选框必须共有一个名字，每个框有一个不同的值，可以用maxlength = &quot;100&quot;设置最多输入100字符 textarea元素可以创建一个多行的文本区，输入的文本在文本区中放不下，右边会出现滚动条,row行，cols列 1&lt;textarea name = &quot;comments&quot; rows = &quot;10&quot; cols = &quot;48&quot;&gt;&lt;/textarea&gt; select元素可以创建一个下拉选择的菜单，option元素创建菜单项 123&lt;select name = &quot;characters&quot;&gt; &lt;option value = &quot;Buckaroo&quot;&gt;Buckaroo Banzai&lt;/option&gt;&lt;/select&gt; 以下是HTML5新增的表单元素 数字输入，number用于限制只输入数字，有些浏览器会在右边给一个显示箭头，用于增减 1&lt;input type = &quot;number&quot; min = &quot;0&quot; max = &quot;20&quot;&gt; 范围输入，range，显示一个滑动条而非输入框 1&lt;input type = &quot;range&quot; min = &quot;0&quot; max = &quot;20&quot; step = &quot;5&quot;&gt; 颜色输入，color，用于指定元素 1&lt;input type = &quot;color&quot;&gt; 日期输入，date，用于选择时间，方法同上 email输入，email，同上 tel输入，tel，同上 url输入，url，同上 POST与GET 都是将表单数据发送到服务器，POST会打包表单变量，然后后台发送，GET也会打包，但会把这些数据追加到URL最后，向服务器发送一个请求，用户会可见 关于可访问性 实际上应该用label元素标记那些标签，可以提供页面结构更多的信息，这样可以更容易用css添加样式，另外对于有视力障碍的人也有助于他们使用的屏幕阅读器更准确的标识表单元元素，id可以与name相同，每个id必须唯一，使用：1234&lt;input type = &quot;radio&quot; name = &quot;hotornot&quot; value = &quot;hot&quot; id = &quot;hot&quot;&gt;&lt;label for = &quot;hot&quot;&gt;hot&lt;/label&gt;&lt;input type = &quot;radio&quot; name = &quot;hotornot&quot; value = &quot;not&quot; id = &quot;not&quot;&gt;&lt;label for = &quot;not&quot;&gt;not&lt;/label&gt; fieldset和legend 表单分组，用fieldset将公共元素组织在一起，用legend为这个分组提供一个标签123456&lt;fieldset&gt; &lt;legend&gt;Condiments&lt;/legend&gt; &lt;input ...&gt;...&lt;br&gt; &lt;input ...&gt;...&lt;br&gt; ...&lt;/fieldset&gt; passwords 会为你输入的文本增加掩码，工作与text类似，不过并不会采用一种安全的方式从浏览器到服务器脚本，想要提高安全性，清联系托管公司 file 创建一个文件输入元素，只需将input元素的type属性设置为file，此外运用这个元素必须使用POST方式 多选菜单 为select元素增加布尔属性multiple即可，这样菜单就不再显示下拉，而是得到一个多选菜单 Placeholder 在input元素中增加placeholder属性，可以设置一个提示，告诉别人你希望他填写什么 Required 可用与任何表单元素，是一个布尔属性，加入它，说明这是一个必须填写的表单，必须输入才能提交 HTML5及工业标准HTML5 doctype 文档类型定义 &lt;!doctype html&gt; 从html5开始不再有版本号，是一个动态的标准，且具有向后兼容性。HTML5主要是添加了些新东西，不要为了使用新特性而使用新特性，应当物尽其用，最合适的东西干最适合的活。 字符编码 meta，使用:&lt;meta charset=&quot;utf-8&quot;&gt; 指定doctype以及使用&lt;meta&gt;指定字符编码是义务必须履行 meta放在head中 W3C验证工具 W3C验证工具 重新考虑HTML结构&#160; &#160; &#160;&#160;将div元素替换成一些更加特定的元素，能够更明确地指示其中包含什么类型的内容 新增元素 可以查看http://caniuse.com/#search=new%20elements,了解浏览器是否支持新元素 article 表示页面中一个独立的组成部分，如一个博客帖子、用户论坛帖子或者新闻报道 nav 所包含的内容将作为页面的导航链接 header 放在页面顶部的内容，或者放在页面某个区块的顶部 footer 放在页面底部的内容，或者放在页面某个区块的底部 time 可能包含一个日期或时间，也可能同时包含日期和时间，简要指南如下 1234&lt;time datetime=&quot;2012-02-18&quot;&gt;2/18/2012&lt;/time&gt;//内容中，可以写任何内容，如&quot;February 18,2012&quot;甚至可以是&quot;yesterday&quot;或&quot;now&quot;//若元素内容没有采用日期/时间的格式来写，就必须要datetime属性//（2012-02 2012 2012-02-18 9：00 05：00 2012-02-18 05：00z（utc时间）） aside 包含的内容是对页面内容的补充，如插图或边栏 section 一个主题内容分组，通常包含一个首部（header），可能还有一个底部（footer） video 用来为页面增加视频媒体 mark 用于突出显示某些文本 meter 显示某个范围的度量 progress 显示任务的完成进度 canvas 显示用javaScript绘制的图像和动画 figure 定义类似照片、图标甚至代码清单等独立的内容 视频video 可以将视频看作img元素，可以提供一个src属性引用视频 12&lt;video controls autoplay width = &quot;512&quot; height = &quot;288&quot; src = &quot;video/tweetsip.mp4&quot;&gt; &lt;/video&gt; autoplay 自动播放 control 提供一组控件来控制播放、暂停、调节音量等 视频格式问题，Safari更接受H.264，Chorme更接受WebM autoplay与controls没有值，是一个bool属性，通常用户希望觉得加载页面时是否播放视频，所以是否加这个属性请三思 src 与img的src很相似 preload 用于细粒度（没懂，是指精细么）地控制视频如何加载，来实现优化，可以preload: none代表用户播放前不加载，metadata代表下载元数据，不下载内容，也可以是设置为auto，交给浏览器决定 poster 在视频未播放时，将视频的某一帧显示为“海报”图像，浏览器通常会指定第一帧,这往往是个黑屏 loop 自动循环，bool属性 width height设置视频显示区，有多余就显示黑边 视频格式 &#160; &#160; &#160;&#160;现在主流格式有3种，MP4容器，包含H.264视频和AAC音频，WebM容器，包含VP8视频和Vorbis音频，Ogg容器，包含Theora视频和Vorbis音频，在使用多个格式时可采用source元素，方式如下：12345678 &lt;video controls autoplay width = &quot;512&quot; height = &quot;288&quot;&gt; &lt;source src = &quot;video/tweetsip.mp4&quot;&gt; &lt;source src = &quot;video/tweetsip.webm&quot;&gt; &lt;source src = &quot;video/tweetsip.ogv&quot;&gt; &lt;p&gt;Sorry, your browser doesn&apos;t support the video element.&lt;/p&gt; &lt;/video&gt;``` - 如何更加具体的指定格式 &lt;source src = &quot;video/tweetsip.ogv&quot; type = &apos;video/ogg; codecs = &quot;theora, vorbis&quot;&apos;&gt; //type可选帮助浏览器确定能否播放文件，单引号 &lt;source src = &quot;video/tweetsip.mp4&quot; type = &apos;video/mp4; codecs = &quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt; &lt;source src = &quot;video/tweetsip.webm&quot; type = &apos;video/webm; codecs = &quot;vp8, vorbis&quot;&apos;&gt; ``` 参考http://wiki.whatwg.org/wiki/Video_type_parameters得到有关type参数的更多信息 在video元素中插入object元素，放在source下面，如果浏览器不认识video那么就会用object，最终看到一个flash视频 音频 audio使用方法与video类似","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://chinti.xyz/tags/HTML/"}]},{"title":"Hexo+GithubPage博客搭建","slug":"Hexo-GithubPage博客搭建","date":"2017-12-24T13:19:26.000Z","updated":"2018-01-04T05:20:53.410Z","comments":true,"path":"2017/12/24/Hexo-GithubPage博客搭建/","link":"","permalink":"http://chinti.xyz/2017/12/24/Hexo-GithubPage博客搭建/","excerpt":"前言&#160; &#160; &#160;&#160;在了解到博客后一直想用它进行一些学习上的记录，但是由于各种各样的原因计划一直搁浅了。不过在接下来的时间，继大半年前接触到一些浅显的前端技术后将进行比较系统的学习，所以借着机会将博客搭建完成。其实网上关于搭建个人博客的教程很多，但是呢作为Markdown程序员的开篇之作还是很适宜的。","text":"前言&#160; &#160; &#160;&#160;在了解到博客后一直想用它进行一些学习上的记录，但是由于各种各样的原因计划一直搁浅了。不过在接下来的时间，继大半年前接触到一些浅显的前端技术后将进行比较系统的学习，所以借着机会将博客搭建完成。其实网上关于搭建个人博客的教程很多，但是呢作为Markdown程序员的开篇之作还是很适宜的。 什么是Hexo，什么是Next&#160; &#160; &#160;&#160;Hexo是一个基于Node.js的快速、简洁且高效的博客框架。Hexo使用Markdown解析文章。Next是一款极简主义的主题，内容强大，使用简便。献上一张Next的图片。 什么是Markdown&#160; &#160; &#160;&#160;Markdown是一种可以使用普通文本编辑器编写的标记语言吗，通过这些简单的标记，实现易读易写，专注于文字本身。 什么是Github，什么是GithubPage&#160; &#160; &#160;&#160;GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHub。GithubPage是一个用于展示你和你的项目的网页，可用于搭建个人博客。 基础配置部分[注]本文中所使用的Hexo版本为3.4.3，node.js版本为8.9.3，PC环境为Windows101.安装&amp;搭建 安装Git：Git下载地址戳这 安装Node.js：Node下载地址戳这 安装Hexo：Hexo官网&#160; &#160; &#160;&#160;首先打开GitBash（你可以通过右键Git Bash Here方便的打开），接下来的一系列操作都将会在GitBash中实现。附一张GitBash截图。Hexo本体安装： npm install hexo-cli -g新建一个博客文件夹，执行：cd &lt;folder&gt;再执行：hexo init 依赖包安装：npm install指定文件夹内容如下，说明新建完成。 注册Github账号，并新建Github仓库：仓库名字必须为 username.github.io，username就是你的Github用户名。 关联到Github账号：进入博客根目录，执行vim _config.yml翻到最下面，修改为：deploy：type: gitrepo:https://github.com/username/username.github.io.gitbranch: master然后执行： npm install hexo-deployer-git --save 2. 配置SSH&#160; &#160; &#160;&#160;SSH是一种安全协议，我们需要通过SSH将Git与Github进行绑定，才能通过Git向Github提交代码。 生成公钥私钥ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;，然后敲三下回车不用输入密码，之后会生成两个文件，分别为 id_rsa和id_rsa.pub，Windows10环境下，你可以在C:\\Users\\username\\.ssh中找到。 添加公钥到Github用记事本打开id_rsa.pub，将内容复制，然后打开你的Github主页。在右上角头像处——&gt;Setting，进入个人设置界面。进入Setting页面后，点击SSH and GPG keys进入子页面，然后点击New SSH key按钮。最后，将公钥id_rsa.pub的内容粘贴到Key处，点击Add SSH key。 验证在git bash中输入：ssh -T git@github.com，等待提示。 3. NexT主题下载在GitBash下输入：cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/nextyour-hexo-site 就是你的博客文件夹。然后修改，Hexo配置文件启用主题。进入博客根目录，执行：vim _config.yml,找到theme：，将它改为theme: next即可。 使用Hexo部分1. 常用命令 清除生成的文件和缓存：hexo clean 生成静态页面：hexo generate //或 hexo g 本地预览：hexo server //或 hexo s 然后在浏览器中输入localhost：4000即可预览效果，Ctrl+C结束 新建文章：hexo new post &quot;title&quot; 新建页面：hexo new page &quot;title&quot; 部署： hexo d 等待片刻你可以在浏览器输入：username.github.io看看效果。 2. 常用Markdown语法&#160; &#160; &#160;&#160;在新建文章后可以发现在_post文件夹下出现了一个md文件，你可以对它进行编辑。可以采用vim直接编写，也可以通过一些实时观看效果的编辑器进行编写，可以自己百度。本人使用的是Cmd Markdown。这里仅介绍一些常用的Markdown语法。 标题：# 一级标题 ## 二级标题类推可得最多六级标题 列表：无序列表- 文字 有序列表1. 文字 图片与链接：图片为![][] 链接为[][] 前一个方括号是文字内容，后一个方括号是序号，在文章尾部可以[序号]：链接地址的方式。插入外链图片需要一个图床，这里我采用的是一款chrome插件，叫做新浪微博图床，也可以试试其他正规的图床服务。 粗体与斜体：粗体**文字** 斜体*文字* 分割内容：-- == 阅读更多：&lt;!--more--&gt;在这行代码前的可以显示，后面的被隐藏，需要点击阅读更多才能看全文。 空行：&lt;br /&gt; 空格：&amp;#160; &amp;#160; &amp;#160;&amp;#160; &#160; &#160; &#160;&#160;了解以上这些，写出一篇文章应该可以了，更加完全的Markdown语法自行百度。 域名绑定1. 购买域名&#160; &#160; &#160;&#160;既然已经初步搭建好了自己的博客，但是是通过username.github.io进行访问的。我们需要有一个自己独立的域名它看起来逼格高一些（并不会）。域名服务商有很多，国内国外的，我选择了腾讯云。[注]接下来以在腾讯云购买域名为例，其他服务商应该也是大同小异。 2. 绑定域名 登陆腾讯云后台，进入我的域名——&gt;域名解析 添加DNS记录 在博客根目录里的public目录中新建CNAME文本，没有后缀名，可以新建一个txt把后缀删掉，编辑他，输入你的域名，保存并退出。将CNAME文本复制到source目录中一份。 执行代码hexo clean hexo d -g 由于DNS记录需要一定时间生效，稍等片刻，用你的域名访问看看。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://chinti.xyz/categories/博客相关/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://chinti.xyz/tags/Hexo/"}]}]}