{"meta":{"title":"ChinTi's Blog","subtitle":"欢迎来到我的个人站","description":null,"author":"Chinti","url":"http://chinti.xyz"},"pages":[{"title":"about","date":"2017-12-19T04:34:07.000Z","updated":"2017-12-19T04:39:35.350Z","comments":true,"path":"about/index.html","permalink":"http://chinti.xyz/about/index.html","excerpt":"","text":"关于我占个坑 等博客完善之后再说"},{"title":"分类","date":"2017-12-19T05:01:02.000Z","updated":"2017-12-25T06:15:28.627Z","comments":true,"path":"categories/index.html","permalink":"http://chinti.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-12-25T06:01:53.000Z","updated":"2017-12-25T06:15:48.366Z","comments":true,"path":"tags/index.html","permalink":"http://chinti.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"锋利的jQuery 阅读笔记","slug":"锋利的jQuery-阅读笔记","date":"2018-04-28T12:18:31.000Z","updated":"2018-05-17T02:31:50.357Z","comments":true,"path":"2018/04/28/锋利的jQuery-阅读笔记/","link":"","permalink":"http://chinti.xyz/2018/04/28/锋利的jQuery-阅读笔记/","excerpt":"前言&#160; &#160;&#160; &#160;jQuery将JS的大量DOM操作进行了封装，能使用户更方便地处理HTML documents、event、动效以及进行ajax交互；同时还具有一个非常强大的选择器，不过现在dom也同样推出了querySelector和querySelectorAll，这方面的优势小了不少；兼容性好，到新版为止，应该可以兼容IE8；jQuery的压缩包只有18KB，非常轻量级（突然想起webpack，写个小应用，搭脚手架用掉100MB）；链式编程，发生在同一个jQuery对象上的一组动作，可以直接连写，无需重复获取；隐式迭代，会隐藏.class类的全部元素，HTML和js分离","text":"前言&#160; &#160;&#160; &#160;jQuery将JS的大量DOM操作进行了封装，能使用户更方便地处理HTML documents、event、动效以及进行ajax交互；同时还具有一个非常强大的选择器，不过现在dom也同样推出了querySelector和querySelectorAll，这方面的优势小了不少；兼容性好，到新版为止，应该可以兼容IE8；jQuery的压缩包只有18KB，非常轻量级（突然想起webpack，写个小应用，搭脚手架用掉100MB）；链式编程，发生在同一个jQuery对象上的一组动作，可以直接连写，无需重复获取；隐式迭代，会隐藏.class类的全部元素，HTML和js分离 第一章 认识jqueryJS的三个弊端，复杂的文档对象模型（DOM）、不一致的浏览器实现、缺乏便捷的开发以及调试工具JQuery的优势：轻量级、强大的选择器、出色的DOM操作的封装、可靠的事件处理机制、完善的Ajax、不污染顶级变量、出色的浏览器兼容性、链式操作方法、隐式迭代、行为层与结构层的分离、丰富的插件支持、完善的文档以及开源 jQuery代码风格 链式操作风格，应当调整代码格式：1、对于同一对象不超过三个操作，可以写成一行 2、对于同一个对象的较多操作建议每行写一个操作 3、对于多个对象的少量操作，可以每个对象写成一行，如果涉及子元素，可以适当缩进 请添加注释 jQuery对象和DOM对象 jQuery对象和DOM对象的相互转换，如获取的事jquery对象，前面加上$用以区分； jQuery对象是一个类似数组的对象，可以通过[index]的方法得到相应的DOM对象：var $cr = $(&#39;#cr&#39;); var cr = $cr[0];，或者用jQuery本身提供的get(index)方法； 只需要用$()将DOM对象包裹起来，就可以得到一个jQuery对象了 解决jQuery与其他库的冲突 jQuery库在其他库之后导入，然后在都被加载完毕后，通过 jQuery.noConflict(); 函数来将变量$的控制权交给其他库，也可以通过 var $j = jQuery.noConflict(); 自定义一个快捷方式；不想自定义快捷方式，可以选择jQuery(function($){...})，用jQuery定义函数，并在函数内部使用$，或者通过匿名函数，并设置形参为$，(function($){...}); jQuery在其他库之前导入，可以直接使用jQuery做jQuery的处理，$用来操作其他库 第二章 jQuery选择器优势：1、简洁的写法 2、支持CSS1到CSS3选择器 3、完善的事件处理机制；获取到不存在的元素不会报错，但是，要注意jquery对象不能直接用于判断是否存在，应当利用元素长度或者转换为DOM对象 jQuery选择器 基本选择器，#id .class element * selector1,selector2,...,slectorN 层次选择器，空格 &gt; + ~；可以用next()方法替代$(‘pre+next’)选择器，nextAll()方法替代$(‘pre~div’)；sibling()方法，则是选取所有同辈元素 过滤选择器 基本过滤选择器，:first :last :not(selector) :even :odd :eq(index) 等于索引 :gt(index) 大于索引 :lt(index) 小于索引 :header :animated :focus 内容过滤选择器，:contains(text) 含有文本内容的元素 :empty 空元素 :has(selector) :parent 可见性过滤选择器，:hidden :visible 属性过滤选择器，[attribute]拥有该属性的元素，[attribute = value]，[attribute != value]，[attribute ^= value]属性值为value开头，[attribute $= value]属性值为value结束，[attribute *= value]属性值含有value，[attribute |= value]属性值等于给定字符串或者以此为前缀，[attribute ~= value]属性值用空格分隔的值中包括该值，[attribute1][attribute2][attributeN]复合属性选择器，满足多个条件 子元素过滤选择器，:nth-child(index/even/odd/equation) :first-child :last-child :only-child 若某元素是它父元素中唯一子元素，那么将会被匹配；若父元素中含其他元素，则不会被匹配 表单对象属性过滤器，:enabled :disabled :checked :selected 表单选择器，:input :text :password :radio :checkbox :submit :image :reset :button :file :hidden 例子中用到的方法： show()，显示隐藏的匹配元素，hide() css(name,value)，给元素设置样式 text(string)，设置所有匹配元素的文本内容 filter(expr)，筛选出与指定表达式匹配的元素集合，其中expr可以是多个选择器的组合 addClass(class)，为匹配的元素添加指定的类名，removeClass(class) toggle(fn1,fn2)方法，交替一组动作 第三章 jQuery中的DOM操作查找节点 查找元素节点，text()获取文本内容 查找属性节点，attr()获取元素属性 创建节点 元素节点，工厂函数$()，var $li_1 = $(&#39;&lt;li&gt;&lt;/li&gt;&#39;); 文本节点，var $li_1 = $(&#39;&lt;li&gt;香蕉&lt;/li&gt;&#39;); 属性节点，var $li_1 = $(&#39;&lt;li title = &quot;香蕉&quot;&gt;香蕉&lt;/li&gt;&#39;); 插入节点 A.append(B)，在A中插入B，prepend在元素内部前置内容，after()在每个匹配的元素之后插入内容，before()在每个匹配元素之前插入；颠倒AB的，appendTo()，prependTo()，insertAfter()，insertBefore() 删除节点 remove()方法，移除该节点以及其后代节点；返回被移除元素的引用，所以还可以继续操作，但是绑定的事件失效 detach()方法，移除元素，但是被移除对象仍能保留绑定的事件，重新添加后恢复 empty()方法，清空该元素的所有后代节点，非删除 复制节点 clone()方法，若传递true，表示复制节点及其绑定的事件 替换节点 replaceWith()，将所有匹配的元素都替换成指定的HTML或者DOM元素 replaceAll()，颠倒了前者的操作；这两个事件都无法被保留 包裹节点 wrap()，将每个匹配元素用新元素包裹 wrapAll()，将所有匹配元素用一个新元素包裹 wrapInner()，将每个匹配元素的自内容用一个元素包裹 属性操作 attr(name,value)，获取属性只需要一个参数name，设置属性两个参数；设置多个属性$(&#39;p&#39;).attr({&quot;title&quot;:&quot;your title&quot;,&quot;name&quot;:&quot;test&quot;}); removeAttr(name)，删除属性 样式操作 利用attr()获取或设置样式 addClass()，追加样式 removeClass()，移除样式， toggle(f1,f2)，交替执行代码；toggleClass()，如果类名存在则删除，不含则添加 hasClass()，判断是否存在某个class 设置和获取HTML、文本和值 html()方法，类似innerHTML text()方法，类似innerText val()方法，类似value属性；val(this.defaultValue)，获取当前文本框默认值；给select、checkbox和radio的某个选项被选中，eg：$(&#39;#single&#39;).val(&quot;选择2号&quot;)； 遍历节点 children()，取得匹配元素的子元素集合，不考虑其他后代元素 next()，匹配后面紧跟的同辈元素 prev()，匹配前面紧邻的同辈元素 siblings()，匹配所有的同辈元素 closest()，取得匹配的最近的祖先元素 parent()，集合中每个匹配的父元素 parents()，集合中每个匹配的祖先元素 CSS-DOM操作 css（name,value），获取或者设置单个css样式；设置多个样式css({name1:value,name2:value})；height()获取高度，width()获取宽度 offset()，获取元素在当前视窗的相对偏移offset().left左偏移；offset().top上偏移 position()，获取元素相对于最近一个已定位的父元素的偏移 scrollTop()，获取滚动条到顶端的距离；scrollLeft()，获取滚动条到左端的距离；输入数字，表示滚动到某个地方 第四章 jQuery中的事件和动画","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript Jquery","slug":"JavaScript-Jquery","permalink":"http://chinti.xyz/tags/JavaScript-Jquery/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（21）","slug":"JavaScript-高级程序设计-阅读笔记（21)","date":"2018-04-25T10:22:31.000Z","updated":"2018-05-10T09:42:25.443Z","comments":true,"path":"2018/04/25/JavaScript-高级程序设计-阅读笔记（21)/","link":"","permalink":"http://chinti.xyz/2018/04/25/JavaScript-高级程序设计-阅读笔记（21)/","excerpt":"前言&#160; &#160;&#160; &#160;Ajax技术的核心是XMLHttpRequest对象，能够以异步的方式从服务器获取更多的信息，就是无需刷新页面即可从服务器取得数据","text":"前言&#160; &#160;&#160; &#160;Ajax技术的核心是XMLHttpRequest对象，能够以异步的方式从服务器获取更多的信息，就是无需刷新页面即可从服务器取得数据 第21章 Ajax与CometXMLHttpRequest对象 浏览器兼容 1234567891011121314151617181920212223 function createXHR()&#123; if(typeof XMLHttpRequest != &quot;undefined&quot;)&#123; return new XMLHttpRequest; &#125;else if(typeof ActiveXObject != &quot;undefined&quot;)&#123; if(typeof arguments.callee.activeXString != &quot;string&quot;)&#123; var versions = [&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;],i,len; for(i=0,len=versions.length;i &lt; len;i++)&#123; try&#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125;catch(ex)&#123; //跳过 &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error(&quot;No XHR Object available&quot;); &#125;&#125;//使用var xhr = createXHR(); XHR用法&#160; &#160;&#160; &#160;第一个方法：open，接受3个参数：1，要发送的请求类型（get，post等），2，请求的URL，3，表示是否异步发送请求的布尔值；url相对于执行代码的当前页面（也可以使用绝对路径），并不会真正发送请求，而是启动一个请求以备发送xhr.open(&quot;get&quot;,&quot;example.php&quot;,false); &#160; &#160;&#160; &#160;使用send()方法发送特定请求，xhr.send(null);；send接受一个参数：作为请求主体发送的数据，不需要则要传入null；响应的数据会被填充到XHR对象的属性 属性 说明 responseText 作为响应主体被返回的文本 responseXML 响应内容类型若是”text/xml”或”application/xml”，将保存包含着响应数据的XML DOM文档 status 响应的HTTP状态 statusText HTTP状态说明 &#160; &#160;&#160; &#160;接到响应后，首先检查status属性，一般来说，可以将HTTP状态码200,作为成功的标志，状态码304表示请求资源并没有被修改，可以直接使用浏览器中缓存的版本；检查响应 12345678 xhr.open(&quot;get&quot;,&quot;example.php&quot;,false); //同步请求 xhr.send(null); if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.resopnseText);&#125;else&#123; alert(&quot;Request was unsuccessful: &quot;+xhr.status); &#125; &#160; &#160;&#160; &#160;多数情况下，还是要发送异步请求，才能让JS继续执行而不必等待响应；可以检测readyState属性：0，未初始化，尚未调用open，1，启动，已调用open，未调用send，2，发送，已调用send，未收到响应，3，接收，已接收部分数据，4，完成，接收全部数据，可以在客户端使用了；只要该属性的值变化，就会触发readystatechange事件；在调用open()前，需要指定onreadystatechange事件处理程序确保浏览器兼容性 1234567891011121314var xhr = createXHR();xhr.onreadystatechange = function()&#123; //DOM0级方法，不是所有浏览器都支持DOM2级方法 if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.resopnseText); &#125;else&#123; alert(&quot;Request was unsuccessful: &quot;+xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;,&quot;example.php&quot;,true); //异步请求xhr.send(null);xhr.abort(); //停止触发事件，不建议重用xhr对象 HTTP头部信息&#160; &#160;&#160; &#160;默认情况下，发送XHR请求的同时，还会发送下列头部信息；通过setRequestHeader方法设置自定义的请求头部信息，接收两个参数：头部字段名称，头部字段值；要成功发送请求头部信息，必须在调用open方法之后，调用send方法之前调用setRequestHeader 头部信息 说明 Accept 浏览器能够处理的内容类型 Accept-Charset 浏览器能够显示的字符集 Accept-Encoding 浏览器能够处理的压缩编码 Accept-Language 浏览器当前设置语言 Connection 浏览器与服务器之间的链接类型 Cookie 当前页面设置的热河Cookie Host 发出请求的页面所在的域 Referer 发出请求的页面的URI(23333规范拼错了) User-Agent 浏览器的用户代理字符串 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.resopnseText); &#125;else&#123; alert(&quot;Request was unsuccessful: &quot;+xhr.status); &#125; &#125;&#125;;xhr.open(&quot;get&quot;,&quot;example.php&quot;,true);xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;MyValue&quot;);xhr.send(null); &#160; &#160;&#160; &#160;调用XHR对象的getRequestHeader方法并传入头部字段名称，可以取得相应头部信息，调用getAllResponseHeaders()方法则可以获得一个包含所有头部信息的长字符串 GET请求&#160; &#160;&#160; &#160;用于向服务器查询某些信息，使用GET请求经常发生的一个错误，就是查询字符串的格式有问题，查询字符串的每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后放到URL末尾，而且所有名-值对都必须使用和号（&amp;）分隔； 123456789101112131415xhr.open(&quot;get&quot;,&quot;example.php?name1=value1&amp;name2=value2&quot;,true);//下面这个函数可以辅助向现有URL的末尾添加查询字符串字符function addURLParam(url,name,value) &#123; url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);&#125;//使用方法var url = &quot;example.php&quot;;url = addURLParam(url,&quot;name&quot;,&quot;Nicholas&quot;);url = addURLParam(url,&quot;book&quot;,&quot;Professional JavaScript&quot;);xhr.open(&quot;get&quot;,url,false); POST请求&#160; &#160;&#160; &#160;通常用于向服务器发送应该保存的数据，应该把数据作为请求的主体提交，可以包含非常多的数据，且格式不限；若要将页面中的表单数据进行序列化，然后通过XHR放到服务器，可使用14章的serialize函数来创建字符串 1234567891011121314151617181920212223242526 function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.resopnseText); &#125;else&#123; alert(&quot;Request was unsuccessful: &quot;+xhr.status); &#125; &#125; &#125;; xhr.open(&quot;post&quot;,&quot;postExample.php&quot;,true); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); var form = document.getElementById(&quot;user-info&quot;); xhr.send(serialize(form)); &#125; //示例php &lt;?php header(&quot;Content-Type:text/plain&quot;); echo &lt;&lt;&lt;EOF Name:&#123;$_POST[&apos;user-name&apos;]&#125; Email:&#123;$_POST[&apos;user-email&apos;]&#125; EOF;?&gt;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"百度前端学院 设计师学院 笔记","slug":"百度前端学院-设计师学院-笔记","date":"2018-04-24T14:33:10.000Z","updated":"2018-04-29T01:59:08.848Z","comments":true,"path":"2018/04/24/百度前端学院-设计师学院-笔记/","link":"","permalink":"http://chinti.xyz/2018/04/24/百度前端学院-设计师学院-笔记/","excerpt":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院设计师学院部分的内容；设计师学院代码地址；Demo地址","text":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院设计师学院部分的内容；设计师学院代码地址；Demo地址 No.1 制作一个简单的菜单动画效果&#160; &#160;&#160; &#160;一个切换样式的过渡效果；注意兼容性，各项属性可以自由定义，含有必要注释；感觉写的有点蠢。。。先这样吧 CSS3过渡，transtion实例：transition: all .5s ease-in-out 1s 兼容性：123456p &#123;-webkit-transition: all .5s ease-in-out 1s;-moz-transition: all .5s ease-in-out 1s;-o-transition: all .5s ease-in-out 1s;transition: all .5s ease-in-out 1s;&#125; 语法：12345678910111213141516transition ：[&lt;&apos;transition-property&apos;&gt; || &lt;&apos;transition-duration&apos;&gt; ||&lt;&apos;transition-timing-function&apos;&gt; || &lt;&apos;transition-delay&apos;&gt; [, [&lt;&apos;transition-property&apos;&gt; || &lt;&apos;transition-duration&apos;&gt; || &lt;&apos;transition-timing-function&apos;&gt; || &lt;&apos;transition-delay&apos;&gt;]]* ===========================//检索或设置对象中的参与过渡的属性transition-property ： none | all | [ &lt;ident&gt; ] [, &lt;ident&gt; ]*//检索或设置对象过渡的持续时间transition-duration ： &lt;time&gt; [, &lt;time&gt;]*//检索或设置对象中过渡的动画类型transition-timing-function ：ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)[,ease | linear | ease-in | ease-out | ease-in-out | step-start | step-end | steps(&lt;integer&gt;[, [ start | end ] ]?) | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)]*//检索或设置对象延迟过渡的时间transition-delay ： &lt;time&gt; [, &lt;time&gt;]* 去除按钮点击后的框：button:focus {outline:none;} No.2 - 初步接触 CSS 2D 变形参考资料：CSS3 新特性兼容方法总结CSS3 2D转换CSS3 中的变形 transform详解 line-height，将它的值设置成div的高度，可以使文字垂直居中 扭曲，skew()，skewX(30deg) skewY(10deg) skew(-45deg) 旋转，rotate() 缩放，scale()，scaleX() scaleY() scale(x,y) 位移，translate()，transform: translate(x,y) 原点，transform-origin，用于设置其中心点 No.3 - CSS transition 和 CSS transform 配合制作动画 ear部分被包括在container里，一开始用face:hover搞了半天耳朵不动。。 等有时间，自行实现一次小猫；贝塞尔曲线还没看懂…… 123456789101112131415161718.container:hover .ear &#123; transform: rotate(-30deg);&#125; .container:hover .ear-wrap .right &#123; transform: rotate(30deg);&#125;.container:hover .eye-bottom &#123; transform: translateY(-15px);&#125;.container:hover .eye-core &#123; transform: scaleX(0.9);&#125;.container:hover .mouth &#123; border-radius: 40% 40% 50% 50%;&#125;.container:hover .face-red &#123; opacity: 1.0;&#125; No.4 - 3D 空间的卡片翻转动效参考资料：CSS3 3D transformCSS Transforms 3D 将卡片放置在浏览器中央 1234567891011#container &#123; width: 250px; height: 300px; margin: auto; text-align: center; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); perspective: 2000px;&#125; perspective属性，代表了透视点距离 translateZ，代表元素离你的距离，值越小离你越远；可以写在舞台元素上，也可以写在当前动画元素上 perspective-orign，设置舞台元素中心 transform-style，默认flat，3d时，应当设为preserve-3d backface-visibility，backface-visiblity: hidden，通常要使后面元素不可见 z-index，调节图层位置 rotateX() rotateY() rotateZ()，绕杠，绕柱，绕轴 No.5 - 纯 CSS 制作绕中轴旋转的立方体参考资料：CodePen 立方体 demoCSS3 @keyframes 规则 CSS动画，主要是依靠@keyframes规则和animation动画属性；尝试了一下，发现手机上貌似没有hover和active的能力。。 animation: rotate 10s linear infinite;，必须规定动画的名称和时长，line ease-in ease-out ease-in-out ease @keyframes 12345678910111213 @keyframes rotate &#123; from &#123; transform: rotateY(0deg); &#125; to &#123; transform: rotateY(-360deg); &#125; =========兼容性======== @-moz-keyframes @-webkit-keyframes @-o-keyframes &#125; transform-origin: center center -252px;设置旋转元素的基准位置 No.6 - 利用 CSS animation 制作一个炫酷的 Slider参考资料：动效落地 aboslute相对与上一个被固定的父元素的位置，所以必须要把该元素的父元素的位置确定下来，比如说设为relative 利用z-index设置层叠，但是不知道为什么显示全屏的图片的z-index设为0时，图片切换后选择图片栏的图片会消失，设为-1时就没这个问题。。。 width = 20vw; height = &quot;20vh&quot;，设置视口宽度 overflow: hidden，将滚轮隐藏 display: inline-block;，内联的块元素，本来想设为display: inline;，但没什么反应。。 JQuery部分： 解决循环输出i为同一值的问题循环部分我采用了一个闭包，另一个使用了es6的let；感觉逻辑上有点蠢 123456789101112131415161718192021function showPic() &#123; var choose = document.getElementsByClassName(&quot;choBox&quot;); var show = document.getElementsByClassName(&quot;show&quot;); for (var i = 0 ; i&lt; show.length ; i++) &#123; (function() &#123; var temp = i; choose[temp].onclick = function() &#123; for(let j = 0 ; j &lt; show.length ; j++) &#123; show[j].setAttribute(&apos;class&apos;,&apos;show&apos;); &#125; show[temp].setAttribute(&apos;class&apos;,&apos;show active&apos;+(temp+1)); &#125; &#125;)(); &#125;&#125;window.onload = function() &#123; showPic(); &#125;; 我看到有人通过label和radio的方式，设置背景图片，做出了纯CSS完成的背景；感觉开阔了思路。。。 No.7 - 使用 animate.css 实现一个优雅的登录框动画开源库，以及使用jQuery（还没怎么看过。。）Animate.css一款强大的预设css3动画库 使用::before，::after伪元素，建立了下划线 使用jquery调用Animate.css，.blur代表失去焦点时的动作，val()一般用于input，next()，Jquery遍历12345678910111213141516 $(&quot;.form__input&quot;).blur(function()&#123; if ($(&quot;.form__input&quot;)[0].value &amp;&amp; $(&quot;.form__input&quot;)[1].value) &#123; $(&quot;.btn&quot;).addClass(&quot;animated infinite pulse&quot;); &#125; else &#123; $(&quot;.btn&quot;).removeClass(&quot;animated infinite pulse&quot;); &#125; if ($(this).val()) &#123; $(this).next().children(&quot;.form__label__content&quot;).addClass(&quot;after&quot;); &#125; else &#123; $(this).next().children(&quot;.form__label__content&quot;).removeClass(&quot;after&quot;); &#125; &#125;); No.8Lottie &amp; Bodymovin lottie使用方法： 1234567lottie.loadAnimation(&#123; container: element, // the dom element that will contain the animation renderer: &apos;svg&apos;, loop: true, autoplay: true, path: &apos;data.json&apos; // the path to the animation json&#125;); 我又忘记了，涉及ajax的要用火狐浏览器。。 123456789101112131415161718192021222324 $(document).ready(function() &#123; lottie.loadAnimation(&#123; container: $(&quot;.stage&quot;)[0], renderer: &apos;svg&apos;, loop: true, autoplay: true, path: &apos;./assets/data1.json&apos;, &#125;); var ani = lottie.loadAnimation(&#123; container: $(&quot;.stage&quot;)[1], renderer: &apos;svg&apos;, loop: false, autoplay: false, path: &apos;./assets/data2.json&apos;, &#125;); $(&quot;.rectangle&quot;).mouseenter(function()&#123; ani.play(); &#125;); $(&quot;.rectangle&quot;).mouseleave(function()&#123; ani.stop(); &#125;); &#125;); 本来想用mouseover和mouseout的，但是效果有点微妙。。。 才发现，box-shadow可以设置三条边","categories":[{"name":"百度前端学院","slug":"百度前端学院","permalink":"http://chinti.xyz/categories/百度前端学院/"}],"tags":[{"name":"JavaScript HTML CSS","slug":"JavaScript-HTML-CSS","permalink":"http://chinti.xyz/tags/JavaScript-HTML-CSS/"}]},{"title":"百度前端学院 MVVM学院 笔记","slug":"百度前端学院-MVVM学院-笔记 ","date":"2018-04-24T06:22:55.000Z","updated":"2018-05-13T02:15:14.087Z","comments":true,"path":"2018/04/24/百度前端学院-MVVM学院-笔记 /","link":"","permalink":"http://chinti.xyz/2018/04/24/百度前端学院-MVVM学院-笔记 /","excerpt":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院MVVM学院部分的内容，貌似学的是百度自家的开源框架san……；MVVM学院代码地址；Demo地址","text":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院MVVM学院部分的内容，貌似学的是百度自家的开源框架san……；MVVM学院代码地址；Demo地址 1.1 课程系列引导及准备工作&#160; &#160;&#160; &#160;需要深入学习github和准备IDE 资料： git文档san的主页江湖救急指南上，江湖救急指南下 以前在知乎上看到一个简易版github介绍，觉得挺有意思： 怎样使用Github 1.2 用parcel快速搭建开发san helloworld&#160; &#160;&#160; &#160;按照任务给的学习资料弄一个hello world 资料： https://github.com/baidu/san，san主页https://webpack.js.org，webpack4主页https://medium.com/webpack，这个得用vpnhttps://parceljs.org/，parcel主页 &#160; &#160;&#160; &#160;英文看的稍微有点吃力，先用Parcel做起来再回过头搞webpack吧； npm install -g parcel-bundler ，安装，需要等一会别着急npm init -y，在正在使用的项目下创建npm install san，安装san；引用&lt;script src=&quot;node_modules/san/dist/san.js&quot;&gt;&lt;/script&gt; 利用CDN引用：开发版本：&lt;script src=&quot;https://unpkg.com/san@latest/dist/san.dev.js&quot;&gt;&lt;/script&gt;生产版本：&lt;script src=&quot;https://unpkg.com/san@latest&quot;&gt;&lt;/script&gt;注：分为开发版本（san.dev.js）和生产版本(sam.js)，生产版本提供了有助于开发的错误提示和警告；尝试了，的确可以报错 安装Babel CLI 和env presetnpm install --save-dev babel-cli babel-preset-env 然后touch .babelrc， 123&#123;&quot;presets&quot;: [&quot;env&quot;]&#125; 利用npm script设置，npm scripts使用指南 npm允许在package.json文件里面，使用script字段定义脚本命令，所以只有配置了才能执行诸如npm run dev/build这样的命令；不过我暂时用的是parcel，好像用不到官网上的这个东西。。 1234567&#123; &quot;name&quot;: &quot;my-san-app&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;, &quot;build&quot;: &quot;NODE_ENV=production webpack --config webpack.config.js&quot; &#125;&#125; 注意NODE_ENV1234567891011121314151617 &#123; module: &#123; loaders: [ &#123; test: /\\.san$/, loader: &apos;san-loader&apos; &#125; ] &#125;, resolve: &#123; alias: &#123; san: process.env.NODE_ENV === &apos;production&apos; ? &apos;san/dist/san.js&apos; : &apos;san/dist/san.dev.js&apos; &#125; &#125;&#125; 1.2 用webpack快速搭建开发san helloworldwebpack中文说明（按照官方例程npx webpack后就是不出那个hello webpack。。。，我现在大概知道原因了，好像是中文目录的锅）Webpack 4x之路（一）（可以照着这个博客做，目录中不要有中文文件夹）Webpack 4x之路（二），这段是安装热更新的工具，以及使用html打包工具Webpack 4x之路（三），这段配置style-loader和css-loader还有js压缩功能Webpack 4x之路（四），这段主要是处理图片和css文件分离，url-loader，mini-css-extract-pluginWebpack 4x之路（五），这篇前面将如何处理html中的img标签的图片如何处理，但是不好用，我采用了另一篇讲的方法；后面是将less和sass的处理还有postcss前缀处理以及最后的babel标签，进行js翻译，使用一些新锐下一代的代码如何打包图片文件，利用html-loader可以直接处理img的src 还有，san官网中使用规则时一定要用rules: test:…,use:…，不要用他给的loaders，这个也坑了好久，一直外部的san文件读不了。。 为了在开发环境组织好碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，需要一个模块化的系统 Webpack的特点：代码拆分，Webpack有两种组织模块依赖的方式，同步和异步，异步依赖作为分割点，形成一个新的块，在优化了依赖树后，每个异步区块都作为一个文件被打包；Loader转换器可以将各种类型资源转换为JS模块；智能解析器，几乎可以处理任何第三方库，动态表达式require(&quot;./templates/&quot; + name + &quot;.jade&quot;)；插件系统，Webpack拥有功能丰富的插件系统；快速运行，采取异步I/O和多级缓存提高运行效率 npm install webpack -g，全局安装webpack npm init创建package.json，然后npm install webpack --save-dev安装webpack依赖 npm info webpack查看版本信息，npm install webpack-dev-server --save-dev安装开发工具","categories":[{"name":"百度前端学院","slug":"百度前端学院","permalink":"http://chinti.xyz/categories/百度前端学院/"}],"tags":[{"name":"JavaScript HTML CSS","slug":"JavaScript-HTML-CSS","permalink":"http://chinti.xyz/tags/JavaScript-HTML-CSS/"}]},{"title":"百度前端学院 零基础学院 笔记","slug":"百度前端学院-零基础学院-笔记","date":"2018-04-24T06:18:55.000Z","updated":"2018-05-20T08:50:37.888Z","comments":true,"path":"2018/04/24/百度前端学院-零基础学院-笔记/","link":"","permalink":"http://chinti.xyz/2018/04/24/百度前端学院-零基础学院-笔记/","excerpt":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院零基础学院部分的内容，听说是66天，可能会分成两到三篇完成","text":"前言&#160; &#160;&#160; &#160;主要记录百度前端学院零基础学院部分的内容，听说是66天，可能会分成两到三篇完成 第一天 为什么有那么多人要做前端？&#160; &#160;&#160; &#160;链接中给的张秋怡的回答清晰明了，给了我很大帮助，感谢……之前翻知乎怎么就没看见…… Web 建站技术中，HTML、HTML5、XHTML、CSS、SQL、JavaScript、PHP、ASP.NET、Web Services 是什么？ 第二天 给自己做一个在线简历吧&#160; &#160;&#160; &#160;要求在Codepen上写简历，注意语义化，不要透露个人信息；[注]codepen的html栏直接写body里的内容好了；有点神奇，按tab它会自动补全，但是是瞎补全。。 codepen在线简历 遇见一个问题，就是加入图片后，对准始终不齐，直到发现了vertical-align: top;，这个属性用于设置元素的垂直对齐方式 利用CSS表格的方式，设计了布局 验证：HTML是超文本标记语言；HTML5是对其的第五次修订，更好的语义化HTML元素是构成HTML文件的基本对象；HTML元素是通过HTML标签定义的；属性是为元素添加各种附加属性文档类型是什么概念，起什么作用？告诉浏览器他是哪个版本的HTMLmeta标签都用来做什么的？提供一些辅助性信息，共两个属性：http-equiv属性和name属性（。。我之前一直都是&lt;meta charset = &quot;utf-8&quot;&gt;来着的。。）；可以用来设定检索条件，和说明主页制作使用的文字语言等功能web语义化，个人觉得就是让浏览器更容易理解你的页面链接，&lt;a&gt;常用标签：div span header footer body head section article aside ul li ol dl dt dd table tr th td表单标签ul li ol dl dt dd，前三个无定义列表，后三个有定义列表 第三天 让简历有点色彩&#160; &#160;&#160; &#160;好吧，今天才需要添加样式，那主要实验一些之前没有用过的属性 text-indent，段落的首行缩进，text-indent: 40px; text-shadow，文字的阴影，text-shadow: 1px 1px 1px #AAA; line-height，行高，在div中，将这个值设置与div的高度相同，可以实现垂直居中 验证： 什么是CSS，CSS是如何工作的：用于向用户指定文档如何呈现的语言，CSS依靠选择器和属性这样的规则确定网页如何显示 基本语法：p { color: red; } 选择器概念，简单选择器和属性选择器是什么：p {} h2 {}；a[href] {color: red;}还可以选择多个属性 文本样式有哪些相关属性和值：text-indent text-align text-transform text-decoration decoration color background-color text-shadow font-family 第四天，背景边框列表链接和更复杂的选择器编码： 了解background background-color background-image background-repeat background-position 了解border border-color border-style border-width 了解list-style list-style-type list-style-image，disc cicle suqare decimal，outside inside inherit，list-style-image:url(&quot;/i/arrow.gif&quot;); 了解a:link a:visited a:hover a:active 了解选择器，分组与继承，派生与伪类，a,b，a b，a &gt; b，a + bb是a的下一个兄弟节点，a ~ bb是a的任意兄弟节点 第五天和第六天 三种简历需要了解 盒模型，浮动以及清除浮动 参考资料：编码规范如何理解浮动简单的清除浮动 box-sizing：content-box/border-box/inherit，第二个可以将内边距和边框算入已设定的宽度与高度中，很有用 :nth-child(n)，总是用不太好呢，他代表的是该元素的父元素的第n个孩子 第七天到第八天：学习布局参考资料： MDN定位MDN定位实践，好吧 我的思维还是太局限了MDN弹性盒子CSS布局CSS布局模型，CSS布局float，CSS布局方式，CSS布局对齐方式七种左侧固定右侧自适应的方法圣杯与双飞翼布局CSS深入理解流体特性与BFC特性下多栏自适应布局三种三栏网页宽度自适应布局 弹性盒子，当元素表现为flex框时，延两个轴进行布局，主轴（main axis），沿着flex元素放置的方向延伸的轴；交叉轴（cross axis）垂直于flex元素放置方向的轴；设置了display:flex的父元素被称为flex容器；容器中的表现为柔性的盒子的元素被称为flex项 flex-direction可以指明方向：column row column-reverse row-reverse；flex-wrap:wrap，可以允许溢出的弹性盒子移到下一行；可以缩写为flex-flow: row wrap 动态尺寸，flex： 1，这个代表这些元素的占比，若其中一个设为2，那它将会是其他的两倍可用宽度；flex: 1 200px，可以为每个项先分配200px，然后剩余空间按比例分配；flex可以分配三个值flex-grow，flex-shrink，flex-basis align-items控制flex项在交叉轴上的位置，默认值stretch，在交叉轴上高度保持一致；center会使这些项保持原来高度，但在交叉轴中居中；设置flex-start或flex-end使其在开始或结束对齐值；align-self属性可以覆盖前者的值；justify-content控制在主轴上的位置，除flex-start，flex-end，center外还可以使用space-around，使项在主轴均匀分布，space-between与前者相似，但两端不留空间 项排序，order: 1，默认为0，数值越大项越靠后 圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应的三栏布局，并且中间栏要处于文档流较前用以优先渲染；所以在前半段的解决方法，比较类似，都是将三栏设置为向左浮动，并将main部分宽度设置为100%，然后设置负边距，左栏设置为负左边距100%，右栏设置为负左边距自身宽度；然后，在圣杯布局中，设置三栏的容器的padding值为左右两个子面板留出空间，然后设置两个子面板为相对定位，然后左边的left设置为负自身宽度，右边的right值为负的自身宽度；而双飞翼布局则在main中加了一个main-content容器，设置该容器的值给左右两个子面板留出空间；不过！都2018年了！可以试试flex（笑 第九天到第十一天，来做一个漂亮的网站前端开发人员也要会的切图技巧做一个会PS切图的前端开发 第十二天到第十五天，复杂页面实现利用overflow：auto和::-webkit-scrollbar{width: 0 } ；可以实现没有滚动条的上下滚动，不然就只能依靠在元素外面再包裹一个div，然后让他越界不显示，内部设置滚动后超出外面的滚动条部分就会被隐藏掉了 第十六天，开始感受JS的乐趣参考资料：W3cschool JavaScriptMDN 什么是JS，说起来我在看JS高程和JSDOM编程艺术的时候都是用getElementsById等方式来获取元素的，现在好像都是用querySelector()和querySelectorAll()来获取元素 话说，虽然要求我们判断输如框是否为数字，可是type输入了number后根本输入不了非数字啊。。。不过可以利用isNaN(x)，进行判断 第十七天到第十八天，“如果”可以“重来”这个要靠取余的方式将十进制转二进制emmm其实只需要两句就好了： 1234 function dec2bin(decNumber) &#123; var num = parseInt(decNumber); return num.toString(2); &#125; 本次任务主要是熟悉基本的api和循环 第十九天：找到那个DOM参考资料：W3CMDNDOM，我怎么觉得MDN一会需要vpn一会不需要的样子MDN querySelectorAllMDN document.querySelectorMDN element.querySelector 需要熟悉DOM方法和属性： getElementById() getElementByTagName() childNodes parentNode 熟悉高级选择器（利用CSS选择器） querySelector querySelectorAll 在给数组添加数据时可以采用push()，经常忘记，大费周章的用循环呢 第二十到第二十一天：让你和页面对话参考资料：W3School事件HTML DOM Text对象HTML DOM Button对象JS DOM改变CSSHTML DOM Style，这两个主要就是讲利用element.style.property修改样式四种动态修改样式的方法cssText，其实我觉得不好用ClassName，利用改变或增减类名修改样式 初步理解JS的事件机制，这个做例子的函数我看着像JS高级程序设计的例子js中的事件委托和事件代理，提到了适合使用事件委托的事件：click,mousedown,mouseup,keydown,keyup,keypress关于js事件冒泡与js事件代理JS事件代理和委托，本次任务是看着这个做的，这个和前一个区别在于toUpperCase()和toLowerCase()，将字符串转换为大小写。。。W3school setTimeout()方法JS中setTimeout()的用法详解W3school setInterval()方法JSsetInterval详解JavaScript中SetInterval与setTimeout的用法详解 浅谈CSS Sprite和实例解析，就是把图片放在一张图上靠改变坐标位置使用。。CSS使用Sprites技术实现圆角效果CSS Sprites:实用技术还是生厌之物 keydown按键，esc的键码是27，回车的键码是1312345678910111213141516 for (let i = 0; i&lt; input_text.length; i++) &#123; input_text[i].onkeydown = function() &#123; switch(input_text[i].id) &#123; case &quot;name&quot; : if(event.keyCode == 13) &#123; var input = document.querySelector(&apos;#name&apos;); result1.innerText = input.value; &#125; else if(event.keyCode == 27) &#123; var input = document.querySelector(&apos;#name&apos;); input.value = &quot;&quot;; &#125; break; &#125; &#125;&#125; 第二十二天到第二十四天：JavaScript里面的居民们","categories":[{"name":"百度前端学院","slug":"百度前端学院","permalink":"http://chinti.xyz/categories/百度前端学院/"}],"tags":[{"name":"JavaScript HTML CSS","slug":"JavaScript-HTML-CSS","permalink":"http://chinti.xyz/tags/JavaScript-HTML-CSS/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（13）","slug":"JavaScript-高级程序设计-阅读笔记（13）","date":"2018-03-27T01:32:55.000Z","updated":"2018-05-09T14:55:00.301Z","comments":true,"path":"2018/03/27/JavaScript-高级程序设计-阅读笔记（13）/","link":"","permalink":"http://chinti.xyz/2018/03/27/JavaScript-高级程序设计-阅读笔记（13）/","excerpt":"前言&#160; &#160;&#160; &#160;JavaScript与HTML之间的交互是通过事件实现的；事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间；使用侦听器（或处理程序）来预定事件，在事件发生时执行相应的代码","text":"前言&#160; &#160;&#160; &#160;JavaScript与HTML之间的交互是通过事件实现的；事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间；使用侦听器（或处理程序）来预定事件，在事件发生时执行相应的代码 第十三章 事件事件流&#160; &#160;&#160; &#160;单击按钮的同时，也单击了按钮的容器元素，甚至也单击了整个页面&#160; &#160;&#160; &#160;事件流描述的是从页面中接收事件的顺序；分为事件冒泡流和事件捕获流 事件冒泡&#160; &#160;&#160; &#160;事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点 事件捕获&#160; &#160;&#160; &#160;由不太具体的节点更早接收到事件，而最具体的节点应该最后接收到事件；建议放心使用事件冒泡，有特殊需求时再使用事件捕获 DOM事件流&#160; &#160;&#160; &#160;”DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段；处于目标阶段在事件处理中被看作冒泡阶段的一部分 事件处理程序&#160; &#160;&#160; &#160;事件就是用户或浏览器自身执行的某种动作，例click、load和mouseover；事件处理程序（事件侦听器）就是响应某个事件的函数，以on开头，例onclick、onload HTML事件处理程序&lt;input type = &quot;button&quot; value = &quot;Click Me&quot; onclick = &quot;alert(&#39;Clicked&#39;)&quot;/&gt; 单击显示警告框，onclick特性的值不能使用未经转义的HTML语法字符：&amp;，”，&lt;，&gt;；若想使用双引号的话：&lt;input type = &quot;button&quot; value = &quot;Click Me&quot; onclick = &quot;alert(&amp;quot;Clicked&amp;quot;)&quot;/&gt; 可以调用在页面其他地方定义的脚本；可以包括在一个外部文件中123456&lt;script type = &quot;text/javascript&quot;&gt; function showMessage() &#123; alert(&quot;Hello world!&quot;); &#125;&lt;/script&gt;&lt;input type = &quot;button&quot; value = &quot;Click Me&quot; onclick = &quot;showMessage()&quot; /&gt; 通过局部变量event，可以访问事件对象；this值等于事件的目标元素 1234&lt;!--输出&quot;Click&quot;--&gt;&lt;input type = &quot;button&quot; value = &quot;Click ME&quot; onclick = &quot;alert(event.type)&quot;&gt;&lt;!--输出&quot;Click Me&quot;--&gt;&lt;input type = &quot;button&quot; value = &quot;Click ME&quot; onclick = &quot;alert(this.value)&quot;&gt; 这个动态创建的函数会通过with扩展作用域，在这个函数内部，可以像访问局部变量一样访问document及该元素本身的成员 1234567function() &#123; with(document) &#123; with(this)&#123; //元素属性值 &#125; &#125;&#125; 故&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(value)&quot; /&gt;可以替代前面的效果 若当前元素是一个表单输入元素，则它还会包括表单元素的入口；这样事件处理程序无需引用表单元素就可以访问其他表单 123456789function() &#123; with(document) &#123; with(this.form)&#123; with(this)&#123; //元素属性值 &#125; &#125; &#125;&#125; 两个缺点： 时差问题，用户可能会在该元素一出现就点击，但是该事件处理程序可能还不具备执行条件；可以将它封装到一个try-catch语句中&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;try{showMessage();}catch(ex){}&quot; /&gt; 这种扩展事件处理程序的作用域链在不同浏览器中略有差别；而且HTML和JS紧密耦合，更改不方便 DOM0级事件处理程序&#160; &#160;&#160; &#160;将一个函数赋值给一个事件处理程序属性的一种传统方式；原因：简单，跨浏览器；需要获得操作对象的引用；每个元素都有自己的事件处理程序属性，通常全部小写（onclick）；DOM0级事件处理程序被认为是元素的方法，在元素作用域中运行，所以this指向当前元素；该方法添加的处理程序在冒泡阶段被处理 1234var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function()&#123; alert(&quot;Clicked&quot;);&#125;; &#160; &#160;&#160; &#160;删除程序btn.onclick = null; DOM2级事件处理程序&#160; &#160;&#160; &#160;addEventListener()和removeEventListener()被定义用于处理指定和删除时间处理程序的操作；所有DOM节点都包含这两个方法，且都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值；若布尔值为true，则代表在捕获阶段调用程序，反之，则冒泡阶段 1234var btn = document.getElementById(&quot;myBtn&quot;);btn.addEventListener(&quot;click&quot;,function()&#123; alert(this.id);&#125;,false); &#160; &#160;&#160; &#160;主要好处是可以添加多个程序，并且事件处理程序会按照添加它们的顺序触发；通过addEventListener添加的只能通过removeEventListener删除，所以，若添加的是匿名函数，则无法移除；匿名函数看似是相同但是实际不同；大多数情况下，将事件处理程序添加到冒泡阶段，可以最大限度兼容浏览器 IE事件处理程序&#160; &#160;&#160; &#160;类似DOM：attachEvent()和detachEvent()，接受两个参数：程序名称和程序函数；注意，第一个参数是”onclick”，不是DOM方法中的”click”；attachEvent在全局作用域运行，故this指向window；也可以添加多个处理程序，但是触发按添加相反顺序触发；也不能使用匿名函数 1234 var btn = document.getElementById(&quot;myBtn&quot;);btn.attachEvent(&quot;onclick&quot;,function()&#123; alert(this.id);&#125;); 跨浏览器的事件处理程序12345678910111213141516171819202122232425262728293031323334 //跨浏览器事件处理程序 var EventUtil = &#123; addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //DOM2级 &#125;else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type,handler); //兼容IE8及更早版本，加上“on” &#125;else&#123; element[&quot;on&quot; + type] = handler; //DOM0级 &#125; &#125;, removeHandler:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false);//DOM2级 &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot; + type,handler) //兼容IE8及更早版本，加上“on” &#125;else&#123; element[&quot;on&quot; + type] = null; &#125; &#125;&#125;;================================================= //使用方法 var btn = document.getElementById(&quot;myBtn&quot;); var handler = function()&#123; alert(&quot;hello&quot;); &#125;; EventUtil.addHandler(btn,&quot;click&quot;,handler); //省略了其他代码 EventUtil.removeHandler(btn,&quot;click&quot;,handler); 事件对象&#160; &#160;&#160; &#160;触发DOM上的一个事件时，会产生一个事件对象event，这个对象上包含着所有与事件有关的信息 DOM中的事件对象&#160; &#160;&#160; &#160;兼容DOM的浏览器会将一个event对象传入到事件处理程序中；event对象包含与创建它的特定事件有关的属性方法；触发的事件类型不一样，可用的属性方法也不一样 属性/方法 类型 读/写 说明 bubbles Boolean 只读 是否冒泡 cancelable Boolean 只读 是否可取消事件的默认行为 currentTarget Element 只读 当前处理事件的元素 defaultPrevented Boolean 只读 true表示已调用preventDefault方法(DOM3事件新增) detail Integer 只读 与事件相关细节信息 eventPhase Integer 只读 1捕获阶段，2处于目标，3冒泡阶段 preventDefault Function 只读 取消事件默认行为，cancelable为true时可使用 stopImmediatePropagation Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用(DOM3新增) stopPropagation Function 只读 取消事件进一步捕获或冒泡，若bubbles为true，可使用 target Element 只读 事件的目标 trusted Boolean 只读 true表示事件由浏览器生成，false表示事件由js生成（DOM3新增） type String 只读 被触发事件类型 view AbstractView 只读 与事件关联的抽象视图，等同于发生事件的window对象 &#160; &#160;&#160; &#160;在事件处理程序内部，对象this始终等于currentTarget，target只包含事件实际目标；若将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值 12345var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event)&#123; alert(event.currentTarget === this); //true alert(event.target === this); //true&#125; &#160; &#160;&#160; &#160;若事件在按钮的父节点中，则这些值是不同的；由于按钮上并没有注册事件处理程序，结果click时间冒泡到了document.body 12345 document.body.onclick = function(event)&#123; alert(event.currentTarget === document.body); //true alert(this === document.body); //true alert(event.target === document.getElementById(&quot;myBtn&quot;)); //true&#125; &#160; &#160;&#160; &#160;在需要一个函数处理多个事件时，可以使用type属性 1234567891011121314151617var btn = document.getElementById(&quot;myBtn&quot;);var handler = function(event)&#123; switch(event.type)&#123; case &quot;click&quot;: alert(&quot;click&quot;); break; case &quot;mouseover&quot;: alert(&quot;mouseover&quot;); break; case &quot;mouseout&quot;: alert(&quot;mouseout&quot;); break; &#125;&#125;;btn.onclick = handler;btn.onmouseover = handler;btn.onmouseout = handler; IE中的事件对象&#160; &#160;&#160; &#160;与访问DOM中的event对象不同，要访问IE中的event对象有几种不同的方式，取决于指定事件处理程序的方法；DOM0级方法，event对象作为window对象的一个属性存在 12345 var btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function()&#123; var event = window.event; alert(event.type); //&quot;click&quot;&#125;; &#160; &#160;&#160; &#160;若时间处理成通过attachEvent添加，那么会有个event对象传入函数 1234var btn = document.getElementById(&quot;myBtn&quot;);btn.attachEvent(&quot;onclick&quot;,function(event)&#123; alert(event.type); //&quot;click&quot;&#125;); &#160; &#160;&#160; &#160;若通过HTML特性指定的事件处理程序，那么还可以通过一个名叫event的变量访问event对象，&lt;input type=&quot;button&quot; value=&quot;Click Me&quot; onclick=&quot;alert(event.type)&quot;&gt; &#160; &#160;&#160; &#160;IE的event对象同样也包含与创建它的事件相关的属性和方法，基本都有对应或者相关的DOM属性和方法；也会因为事件类型的不同而不同，但所有事件都含有这些属性 属性/方法 Boolean 读/写 说明 cancelBubble Boolean 读/写 默认false，设true可取消事件冒泡 returnValue Boolean 读/写 默认true，设false可取消事件默认行为 srcElement Element 只读 事件目标，由于事件处理程序的作用域是根据制定它的方式来确定的，所以不能认为this始终等于事件目标 type String 只读 被触发的事件类型 跨浏览器的事件对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 //跨浏览器事件对象var EventUtil = &#123; addHandler:function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type,handler,false); //DOM2级 &#125;else if(element.attachEvent)&#123; element.attachEvent(&quot;on&quot; + type,handler); //兼容IE8及更早版本，加上“on”，IE方法 &#125;else&#123; element[&quot;on&quot; + type] = handler; //DOM0级 &#125; &#125;, getEvent:function(event)&#123; //返回对event对象的引用 return event?event:window.event; &#125;, getTarget:function(event)&#123; //返回事件的目标 return event.target||event.srcElement; &#125;, preventDefault:function(event)&#123; //取消事件默认行为 if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125;, removeHandler:function(element,type,handler)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,handler,false);//DOM2级 &#125;else if(element.detachEvent)&#123; element.detachEvent(&quot;on&quot; + type,handler) //兼容IE8及更早版本，加上“on”，IE方法 &#125;else&#123; element[&quot;on&quot; + type] = null; &#125; //DOM0级 &#125;, stopPropagation:function(event)&#123; //阻止事件流 if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125; &#125;&#125;;//使用示例btn.onclick = function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event);&#125;; //确保取得事件对象和事件目标var link = document.getElementById(&quot;myLink&quot;);link.onclick = function(event)&#123; //可确保在所有浏览器中单击该链接都不会打开另一个页面 event = EventUtil.getEvent(event); EventUtil.preventDefault(event);&#125;;//由于IE不支持事件捕获，所以只能用来阻止事件冒泡var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event)&#123; alert(&quot;Clicked&quot;); event = EventUtil.getEvent(event); EventUtil.stopPropagation(event);&#125;;document.body.onclick = function(event)&#123; alert(&quot;body clicked&quot;);&#125;; 事件类型UI事件 事件 说明 DOMActivate 表示元素已被激活，DOM3级中废弃，不建议使用 load 页面完全加载后在window上面触发，当所有框架加载完在框架集上触发，当图像加载完在&lt;img&gt;元素触发，当嵌入内容加载完在&lt;object&gt;元素上面触发 unload 与load的加载相反 abort 在用户停止下载过程时，若嵌入内容没有加载完，在&lt;object&gt;元素上触发 error 当js错误时在window触发，无法加载图像在&lt;img&gt;触发，无法加载嵌入内容在触发，或当一个或多个框架无法加载在框架集上触发，17章 select 用户选择文本框一或多个字符时触发 resize 窗口或框架大小变化时在window或框架上触发 scroll 用户滚动带滚动条的元素中的内容时，在该元素触发，&lt;body&gt;包含所加载页面滚动条 &#160; &#160;&#160; &#160;除DOMActivate事件外，其他事件在DOM2级都为HTML事件，DOMActivate在DOM2中仍属于UI事件 1234 //浏览器是否支持DOM3级事件定义的事件var isSupported = document.implementation.hasFeature(&quot;UIEvent&quot;,&quot;3.0&quot;); //浏览器是否支持DOM2级事件定义的事件var isSupported = document.implementation.hasFeature(&quot;HTMLEvent&quot;,&quot;2.0&quot;); load事件，当页面完全加载后，就会触发window的load事件 123456789101112131415161718192021EventUtil.addHandler(window,&quot;load&quot;,function(event)&#123; alert(&quot;Loaded&quot;);&#125;);//onload方法&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Load Event Example&lt;/title&gt;&lt;/head&gt;&lt;body onload=&quot;alert(&apos;Loaded!&apos;)&quot;&gt;&lt;/body&gt;&lt;/html&gt;//尽可能使用js方式，在现代浏览器上script也会触发load事件，可以确定动态加载js文件是否加载完毕EventUtil.addHandler(window,&quot;load&quot;,function()&#123; var script = document.createElement(&quot;script&quot;); EventUtil.addHandler(script,&quot;load&quot;,function(event)&#123; alert(&quot;Loaded&quot;); &#125;); script.src = &quot;example.js&quot;; document.body.appendChild(script);&#125;); unload事件，与load对应，但是要注意，在该事件发生时，页面加载后存在的对象，此刻应已不存在 resize事件，浏览器窗口被调整时触发，可以通过js或者onresize触发 scroll事件，虽然在window对象上发生，但它实际表示的则是页面中相应元素的变化，混杂模式下，可以通过body元素的scrollLeft和scrollTop来监控该变化 焦点事件 事件 说明 blur 元素失去焦点时触发，该事件不会冒泡，所有浏览器支持 DOMFocusIn DOM3级废弃，采用focusin DOMFocusOut 同上 focus 元素获得焦点触发，该事件不冒泡，所有浏览器支持 focusIn 元素获得焦点触发，与HTML事件focus等价，冒泡，支持的浏览器：IE5.5+，Safari5.1+，Opera11.5+，Chrome focusOut 元素失去焦点触发，与HTML事件focus等价，冒泡，支持的浏览器：同上 &#160; &#160;&#160; &#160;当焦点从页面一个元素移动到另一个元素，依次触发事件：focusOut，focusIn，blur，DOMFocusOut，focus，DOMFocusIn 12//确定浏览器是否支持焦点事件var isSUpported = document.implementation.hasFeature(&quot;FocusEvent&quot;,&quot;3.0&quot;); 鼠标与滚轮事件 事件 说明 click 单击主鼠标（一般为左键），或按下回车触发 dbclick 双击主鼠标(一般为左键)触发 mousedown 用户按下任意鼠标按钮触发，不能通过键盘触发 mouseenter 鼠标光标从元素外部首次移动到元素范围之内触发，不冒泡，移动到后代元素不触发，IE，Firefox9+，Opera支持 mouseleave 在位于元素上方的鼠标光标移动到元素范围之外触发，不冒泡，移动到后代元素不触发，IE，Firefox9+，Opera支持 mousemove 鼠标指针在元素内部移动时重复触发，不能通过键盘触发 mouseout 从一个元素上方移动到另一个元素上方触发，不能通过键盘触发 mouseover 鼠标指针位于一个元素外部，首次移入另一个元素边界之内触发，不能通过键盘触发 mouseup 释放鼠标按钮触发，不能通过键盘触发 &#160; &#160;&#160; &#160;只有相继触发mousedown和mouseup事件，才会触发click事件；滚轮事件，mousewheel 1234 //确定浏览器是否支持DOM2级鼠标事件var isSupported = document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;);//确定浏览器是否支持所有鼠标事件var isSupported = document.implementation.hasFeature(&quot;MouseEvent&quot;,&quot;3.0&quot;); 客户区坐标位置，clientX，clientY，保存鼠标事件在浏览器视口的特定位置，表示事件发生时鼠标在视口中的水平和垂直坐标 页面坐标位置，pageX，pageY，保存鼠标事件发生在页面的具体位置；IE8级更早版本不支持事件对象上的页面坐标，使用客户区坐标和滚动信息可以计算出来，使用document.body（混杂模式）或document.documentElement（标准模式）中的scrollLeft和scrollTop 12345678910111213141516var div = document.getElementById(&quot;myDiv&quot;);EventUtil.addHandler(div,&quot;click&quot;,function(event)&#123; event = EventUtil.getEvent(event); var pageX = event.pageX; var pageY = event.pageY; if(pageX == undefined)&#123; pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft); &#125; if(pageY == undefined)&#123; pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop); &#125; alert(&quot;Page coordinates: &quot; + pageX + &quot;,&quot; + pageY);&#125;); 屏幕坐标位置，screenX和screenY，相对于整个电脑屏幕的位置 修改键，Shift,Ctrl,Alt,Meta（window键盘的window键，苹果的cmd），用来修改鼠标事件的行为，DOM规定4个属性：shiftKey，ctrlKey，altKey，metaKey，包含的都是布尔值，IE8及之前不支持 相关元素，mouseover，mouseout事件会涉及更多元素，mouseover，主要目标是获得光标的元素，相关元素是失去光标的元素，mouseout，反之；DOM通过event对象的relatedTarget属性提供了相关的信息，这个属性只对mouseover，mouseout事件才包含值，其他的事件为null，IE8及之前版本不支持，提供其他属性。在mouseover触发时，IE的fromElement保存相关元素，在mouseout触发，IE的toElement保存相关元素。继续增强EventUtil函数 1234567891011getRelatedTarget:function(event)&#123; if(event.relatedTarget)&#123; return event.relatedTarget; &#125;else if(event.toElement)&#123; return event.toElement; &#125;else if(event.fromElement)&#123; return event.fromElement; &#125;else &#123; return null; &#125;&#125;, 鼠标按钮，mousedown和mouseup中event对象保存了一个button属性，0主按钮，1中间按钮，2次按钮；IE8及更早版本也提供button属性，但与DOM的button属性值有大差异：0没有按下按钮，1按下主，2按下次，3同时按下主次，4按下中，5同时按下主和中，6同时按下次和中，7同时按下三键；增强EventUtil 12345678910111213141516171819getButton:function(event)&#123; if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;))&#123; //检测MouseEvents特性可以知道event对象存在的button属性是否包含正确的值，失败，说明是IE return event.button; &#125;else&#123; switch(event.button)&#123; case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; &#125; &#125;&#125;, 更多的事件信息，只有IE支持，别管了 鼠标滚轮事件，mousewheel，还包含了一个特殊的wheelDelta属性，向前滚动鼠标滚轮，这个属性是120的倍数，向后滚是-120的倍数；火狐支持一个叫做DOMMouseScroll的类似事件，但是向前-3向后3的倍数；继续增强 12345678getWheelDelta:function(event)&#123; if(event.wheelDelta)&#123; return (client.engine.opera &amp;&amp; client.engine.opera &lt; 9.5 ? -event.wheelDelta : event.wheelDelta); &#125;else&#123; return -event.detail * 40; &#125;&#125;, 触摸设备，没有双击事件 无障碍性问题，不建议使用click之外的其他鼠标，因为可以通过键盘的回车键，不要使用onmouserover和onmousedown 键盘与文本事件&#160; &#160;&#160; &#160;主要依靠DOM0级；三个键盘事件：keydown，按下键盘任意键触发，可以重复触发，keypres，按下字符键触发，可以重发触发；keyup释放时触发；文本事件，textInput，文本插入文本框时触发；支持相同的修改键，IE不支持metaKey 键码，keydown和keyup触发时，event对象的keyCode属性中包含一个代码，数字7为55，字母A为65，P380给出了键码 字符编码，charCode属性，这个属性只有发生keypress事件才包含值，代表按下的键的ASCII码，此时keyCode为0或为按键键码；利用String.fromCharCode()将其转换为实际字符 1234567getCharCode:function(event)&#123; if(typeof event.charCode == &quot;number&quot;)&#123; return event.charCode; &#125;else&#123; return event.keyCode; &#125;&#125;, DOM3级变化，不再包含charCode属性，改为key和char；前者取代keyCode，值为字符串，按下字符键是对应的文本字符，按下非字符键则是相对应的键值；后者在非字符键为null；Safari和Chrome还支持keyIdentifier的属性，按下非字符键与key相同，字符键返回格式U+0000的字符串，表示Unicode；为了跨浏览器，不要用它们；location属性，有bug不推荐使用，支持也不多P382；getModifierState()方法，接受一个参数，即等于Shift、Control、AltGraph或Meta的字符串，表示要检测的修改键，被按下返回true，只有IE9支持，毫无意义 textInput事件，与keypress的区别，区别一：任何可以获得焦点的元素都可以触发keypress事件，但只有可编辑区域才能触发textInput事件，区别二：textInput事件只有用户输入能够输入实际字符的键才会触发，keypress事件则再按下能够影响文本显示的键（退格键）也会触发；包含一个data属性，保存用户输入的字符；还有一个属性，inputMethod，表示把文本输入文本框的方式，只有ie有。。 设备中的键盘事件 复合事件&#160; &#160;&#160; &#160;用于处理IME（输入法编辑器）的输入序列，可以让用户输入物理键盘上找不到的字符；只有IE支持 变动事件&#160; &#160;&#160; &#160;DOM2级的变动事件能在DOM中的某一部分发生变化时给出提示 事件 说明 DOMSubtreeModified DOM结构发生任何变化触发，在其他任何事件触发后都会触发 DOMNodeInserted 一个节点作为子节点被插入到另一个节点时触发 DOMNodeRemoved 节点从其父节点移除触发 DOMNodeInsertedIntoDocument 节点被直接插入文档或通过子树间接插入文档之后触发，在DOMNodeInserted后 DOMNodeRemovedFromDocument 在节点被直接从文档或通过子树间接从文档中移除之前触发，在DOMNodeRemoved后 DOMAttrModified 特性被修改触发 DOMCharacterDataModified 在文本节点值发生变化触发 12//检查浏览器是否支持变动事件var isSUpported = document.implementation.hasFeature(&quot;MutationEvents&quot;,&quot;2.0&quot;); HTML事件 contextmenu事件，冒泡事件，可以用与显示自定义的上下文菜单 beforeunload事件，在浏览器卸载页面前触发，可以用来询问用户是否离开页面 DOMContentLoaded事件，window的load事件要在文档全部加载完毕才会触发，而DOMContentLoaded事件则在形成完成的DOM树之后就触发，而不理会js文件，图像，css等资源文件的加载 readystatechange事件，行为很难预料，P390，且chrome不支持 pageshow和pagehide事件，Firefox和Opera特性，往返缓存，可以在用户使用浏览器的后退前进按钮加快页面转换速度；火狐提供了些新事件，pageshow，在页面显示时触发，必须将事件处理程序添加到window中，还包含一个属性，persisted的布尔值属性，保存在了bfcache中，为true；pagehide事件，在浏览器卸载页面时触发，在unload之前，包含这个事件的event对象也包含persisted，卸载后被保存到bfcache值为true；指定onunload会使页面被排除在bfcache之外 hashchange事件，h5新增，用于在URL的参数列表(#号后的变化)通知给开发人员；在ajax应用中，开发人员经常要利用url参数列表保存状态或导航信息，event包含两个属性，oldURL和newURL，分别保存两个完整链接，现代浏览器都支持 设备事件 orientationchange事件，苹果为移动Safari中添加了orientationchange事件，移动Safari的window.orientation属性可能包含3个值：0，肖像模式；90，左旋转（按钮在右侧），-90，右旋转（按钮在左侧） MozOrientation事件，当设备的加速计检测到设备方向改变时，触发事件 deviceorientation事件，类似前者，它只能在移动webkit浏览器中运行 devicemotion事件，可以用来检测什么时候移动，不仅仅是如何改变，P398-399 触摸与手势事件 触摸事件，P399 手势事件，p401 内存和性能事件委托&#160; &#160;&#160; &#160;对“事件处理程序过多”的解决方案是事件委托，利用事件冒泡，指定一个事件处理程序管理某一类型的所有事件；该方法消耗更低，若可行，考虑为document对象添加一个事件处理程序，用于处理页面上的某种特定类型事件，优点：该对象可以很快访问，设置事件处理程序用时更少，占用内存更少 123456789101112131415161718192021222324&lt;ul id=&quot;myLinks&quot;&gt; &lt;li id=&quot;goSomewhere&quot;&gt;Go somewhere&lt;/li&gt; &lt;li id=&quot;doSomething&quot;&gt;Do something&lt;/li&gt; &lt;li id=&quot;sayHi&quot;&gt;say hi&lt;/li&gt;&lt;/ul&gt;//若在复杂的web程序中为每个事件添加处理程序，将会有数不清的代码用于事件处理程序var list = document.getElementById(&quot;myLinks&quot;);EventUtil.addHandler(list,&quot;click&quot;,function(event)&#123; event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id)&#123; case &quot;doSomething&quot;: document.title = &quot;I changed the document&apos;s title&quot;; break; case &quot;goSomewhere&quot;: location.href = &quot;http://www.wrox.com&quot;; break; case &quot;sayHi&quot;: alert(&quot;hi&quot;); break; &#125;&#125;); 移除事件处理程序&#160; &#160;&#160; &#160;若某个元素即将被移除，可以手工移除事件处理程序，减少空事件处理程序 123456789101112&lt;div id=&quot;myDiv&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Click Me&quot; id=&quot;myBtn&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;myBtn&quot;); btn.onclick = function()&#123; //先执行某些操作 btn.onclick = null; //移除事件处理程序 document.getElementById(&quot;myDiv&quot;).innerHTML = &quot;Processing...&quot;; &#125;;&lt;/script&gt; 模拟事件","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（10-12）","slug":"JavaScript-高级程序设计-阅读笔记（10-12）","date":"2018-03-02T05:46:12.000Z","updated":"2018-04-17T09:22:45.901Z","comments":true,"path":"2018/03/02/JavaScript-高级程序设计-阅读笔记（10-12）/","link":"","permalink":"http://chinti.xyz/2018/03/02/JavaScript-高级程序设计-阅读笔记（10-12）/","excerpt":"前言&#160; &#160;&#160; &#160;10、11、12章研究都是DOM相关的知识点，在之前DOM编程艺术这本书中有过一定的了解；DOM:文档对象模型，是针对HTML和XML文档的一个API（应用程序接口）；描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的一部分","text":"前言&#160; &#160;&#160; &#160;10、11、12章研究都是DOM相关的知识点，在之前DOM编程艺术这本书中有过一定的了解；DOM:文档对象模型，是针对HTML和XML文档的一个API（应用程序接口）；描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的一部分 第十章 DOM&#160; &#160; &#160;&#160;本章主要理解包含不同层次节点的DOM，使用不同的节点类型以及克服浏览器兼容性问题等 节点层次Node类型&#160; &#160; &#160;&#160;DOM1定义了一个Node接口，JS所有节点类型都继承自Node类型；每个节点都有nodeType属性，请用数值常量进行比较，可以兼容所有浏览器 nodeName和nodeValue属性 节点关系 123var firstChild = someNode.childNodes[0];var secondChild = someNode.childNodes.item(1);var count = someNode.childNodes.length; childNodes,parentNode,previousSibling和nextSibling属性；在IE中将NodeList转换成数组，必须手动枚举所有成员 123456789101112function convertToArray(nodes)&#123; var array = null; try &#123; array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器 &#125;catch(ex)&#123; array = new Array(); for (var i=0, len=nodes.length;i&lt;len;i++)&#123; array.push(nodes[i]); &#125; &#125; return array;&#125; hasChildNodes()，在节点包含一或多个子节点的情况下返回true 操作节点123456789someNode.appendChild(newNode) //在末尾添加节点，若是已有节点，则移到末尾someNode.lastChildsomeNode.firstChildsomeNode.childNodes //获取所有子节点someNode.insertBefore(newNode,null) //前插，该例与appendChild()执行相同操作someNode.replaceChild(newNode,someNode.firstChild) //前参数替换后参数，并返回被替换的节点someNode.removeChild(someNode.lastChild)//移除节点someNode.cloneChild(true) //复制节点，true深复制，false浅复制normalize() //找到空文本节点，删除它；相邻的文本节点，则将它们合并为一个文本节点 Document类型&#160; &#160; &#160;&#160;具有以下特征 变量 值 nodeType 9 nodeName “#document” parentNode null ownerDocument null &#160; &#160; &#160;&#160;其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment 文档的子节点，documentElement属性始终指向节点，P254 文档信息，document对象是HTMLDocument的一个实例，同时还具有一些其他的属性，title(页面标题)、URL（地址栏中显示的URL）、domain（页面的域名；可有限制的设置）和referrer（来源页面的URL，可能是空字符串）；这些信息存在于请求的HTTP头部 查找元素，getElementById()和getElementsByTagName，严格匹配，IE7以下有怪癖；HTMLCollection对象有一个方法，namedItem()，可以通过属性获取集合中的项；还可以通过按名称访问项，var myImage = images[&quot;myImage&quot;]；”*”代表通配符；第三个方法，getElementsByName()只存在于HTMLDocument中 特殊集合，除了属性和方法，还有一些特殊的HTMLCollection对象集合 变量 说明 document.anchors 包含文档中所有带name特性的元素 document.applets 包含文档中所有的元素（该元素基本已不再被使用） document.forms 包含文档中所有的元素，（document.getElementsByTagName(“form”)） document.images 包含文档中所有的元素，（document.getElementsByTagName(“img”)） document.links 包含文档中所有带href特性的元素 DOM一致性检测，document.implement属性中的，hasFeature()方法，该方法很方便，但是需要与能力检测一同使用，P259 文档写入，write()、writeln()、open()和close()，前者XHTML中不支持，后者分别用于打开和关闭网页的输出流，若加载页面期间使用前两种方法，则不需要用到这两种方法 Element类型&#160; &#160; &#160;&#160;具有以下特征： 变量 值 nodeType 1 nodeName 元素的标签名 nodeValue null parentNode Document或Element HTML元素，继承了Element，还有些其他的标准特性 变量 值 id 元素在文档中的标识符 title 有关元素的附加说明，一般通过工具提示条显示出来 lang 元素内容的语言代码 dir 语言的方向，”ltr”和”rtl” className 类 操作特性，getAttribute()、setAttribute()、removeAttribute() 1234var div = document.getElementById(&quot;myDiv&quot;);alert(div.getAttribute(&quot;id&quot;));div.setAttribute(&quot;id&quot;,&quot;someOtherId&quot;);div.removeAttribute(&quot;id&quot;); attributes属性，每个Attr节点都保存在NameNodeMap对象中，该对象具有下列方法，不同浏览器返回的顺序不同 方法 说明 getNamedItem(name) 返回nodeName属性等于name的节点 removeNamedItem(name) 移除节点 setNamedItem(node) 添加节点，以节点的nodeName属性为索引 item(pos) 返回位于数字pos位置的节点 创建元素，document.createElement()，然后可以通过appendChild()、insertBefore()或replaceChild()方法将新元素添加到文档树中（在IE7及更早版本前可能会有些问题P269） 元素的子节点，遍历节点时要检查nodeType属性 Text类型 特征 说明/值 nodeType 3 nodeName “#text” nodeValue 节点所包含文本 parentNode 一个Element 不支持（没有）子节点 方法 说明 appendData(text) 将text添加到节点的末尾 deleteData(offset,count) 从offset指定的位置开始删除count个字符 insertData(offset,text) 指定位置插入 replaceData(offset,count,text) 用text替换从offset开始共计count个的文本 splitText(offset) 分割成两个文本节点 substringData(offset,count) 提取字符串 创建文本节点，document.createTextNode() 规范化文本节点，在一个包含两个或多个文本节点的父元素上调用normalize()方法 分割文本节点，splitText()，作用与前者相反 Comment类型 特征 说明/值 nodeType 8 nodeName “#comment” nodeValue 注释的内容 parentNode Document或Element 不支持（没有）子节点 document.createComment()可以传递注释文本也可以创建注释节点，访问注释节点要保证他们是元素的后代 CDATASection类型 特征 说明/值 nodeType 4 nodeName “#cdata-section” nodeValue CDATA区域中的内容 parentNode Document或Element CDATA区域主流浏览器不能够正确解析，在真正的XML文档中，可以document.createCDataSection()创建并传入节点内容 DocumentType类型 特征 说明/值 nodeType 10 nodeName doctype的名称 nodeValue null parentNode Document 不支持（没有）子节点 该类型不常用 DocumentFragment类型 特征 说明/值 nodeType 11 nodeName “#document-fragment” nodeValue null parentNode null 子节点可以是Element、ProcessingInstruction、Comment、Text、CDATASection或EntityReference 是一种“轻量级”的文档，可以包含和控制节点；不能将文档片段直接添加到文档中，单可以当作一个仓库，document.createDocumentFragment()，文档片段继承了Node的所有方法 Attr类型 特征 说明/值 nodeType 2 nodeName 特性的名称 nodeValue 特性的值 parentNode null 在HTML中不支持（没有）子节点 XML中子节点可以是Text或EntityReference 不被认为是文档树的一部分；不直接引用特性节点，具有三个属性（name、value和specified）；document.createAttribute(),getAttribute()、setAttribute和removeAttribute DOM操作技术&#160; &#160; &#160;&#160;由于浏览器中隐藏的问题导致JS处理DOM比其他更为麻烦些 动态脚本 利用&lt;script&gt;元素向页面中插入JS代码；动态脚本指的是在页面加载时不存在，在某一时刻通过修改DOM动态添加的脚本；P278；IE不太支持某些模式，因为IE将&lt;script&gt;视为一个特殊的元素，不允许DOM访问其节点 动态样式 动态样式是指在页面刚加载时不存在的样式；通过操作&lt;link&gt;很方便就可以构成 12345678910111213&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;styles.css&quot;&gt;================================function loadStyles(url) &#123; var link = document.createElement(&quot;link&quot;); link.rel = &quot;stylesheet&quot;; link.type = &quot;text/css&quot;; link.href = url; var head = documentElementsByTagName(&quot;head&quot;)[0]; head.appendChild(link); &#125;loadStyles(&quot;styles.css&quot;); 也可以操作&lt;style&gt;元素，要注意IE操作styleSheet可能会崩溃（书上写的，没有试验过） 操作表格&#160; &#160; &#160;&#160;我记得DOM编程艺术里有重点强调过，这个操作起来很麻烦；P282有HTML DOM为表格元素添加了一些属性和方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;table border = &quot;1&quot; width = &quot;100%&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Cell 1,1&lt;/td&gt; &lt;td&gt;Cell 2,1&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;======================//创建tablevar table = document.createElement(&quot;table&quot;);table.border = 1;table.width = 100%;//创建tbodyvar tbody = document.createElemet(&quot;tbody&quot;);table.appendChild(tbody);-----------------------//创建第一行var row1 = document.createElement(&quot;tr&quot;);tbody.appendChild(row1);var cell1_1 = document.createElement(&quot;td&quot;);cell1_1.appendChild(document.createTextNode(&quot;Cell 1,1&quot;));row1.appendChild(cell1_1);var cell2_1 = document.createElement(&quot;td&quot;);cell2_1.appendChild(document.createTextNode(&quot;Cell 2,1&quot;));row1.appendChild(cell2_1);//创建第二行var row2 = document.createElement(&quot;tr&quot;);tbody.appendChild(row2);var cell1_2 = document.createElement(&quot;td&quot;);cell1_2.appendChild(document.createTextNode(&quot;Cell 1,2&quot;));row2.appendChild(cell1_2);cell2_2.appendChild(document.createTextNode(&quot;Cell 2,2&quot;));row2.appendChild(cell2_2); -------------------------//采用HTML DOM添加的一些属性和方法后//创建第一行tbody.insertRow(0);tbody.rows[0].insertCell(0);tbody.rows[0].cells[0].appendChild(document.createTextNode(&quot;Cell 1,1&quot;));tbody.rows[0].insertCell(1);tbody.rows[0].cells[1].appendChild(document.createTextNode(&quot;Cell 2,1&quot;));//创建第二行tbody.insertRow(1);tbody.rows[1].insertCell(0);tbody.rows[1].cells[0].appendChild(document.createTextNode(&quot;Cell 1,2&quot;));tbody.rows[1].insertCell(1);tbody.rows[1].cells[1].appendChild(document.createTextNode(&quot;Cell 2,2&quot;));----------------------------//将表格添加到文档主体中document.body.appendChild(table); 使用NodeList 要理解NodeList及其近亲NameNodeMap和HTMLCollection；它们是动态的所以每次文档结构变化时，它们都会得到更新，所以要注意实时查询可能会死循环 第十一章 DOM扩展&#160; &#160; &#160;&#160;本章介绍了DOM的两个主要拓展，SelctorsAPI（选择符API）和HTML5；同时还介绍一些专有的DOM扩展 选择符API&#160; &#160; &#160;&#160;根据CSS选择符选择与某个模式匹配的DOM元素；jQuery的核心就是通过CSS选择符查询DOM文档取得元素的引用；&#160; &#160; &#160;&#160;Selectors API Level1的核心是两个方法：querySelector()和querySelectorAll() querySelector()方法&#160; &#160; &#160;&#160;该方法接受一个CSS选择符，返回与该模式匹配的第一个元素，如果没找到则返回null 12345678//取得body元素var body = document.querySelector(&quot;body&quot;);//取得ID为“myDiv”的元素var myDiv = document.querySelector(&quot;#myDiv&quot;);//取得类名为“selected”的第一个元素var selected = document.querySelector(&quot;.selected&quot;);//取得类为“button”的第一个图像元素var img = document.body.querySelector(&quot;img.button&quot;); querySelectorAll()方法&#160; &#160; &#160;&#160;同样，接受一个CSS选择符，返回所有匹配的元素（一个NodeList对象），可以采用item()方法，也可以使用方括号语法 matchesSelector()方法&#160; &#160; &#160;&#160;Selectors API Level2规范为Element类型增加了 matchesSelector()方法，该方法同样接受一个CSS选择符，若调用元素与选择符匹配则返回true；否则，反之；截至2011年主流浏览器还未支持该方法，可能需要用到一个包装函数；P288 元素遍历&#160; &#160; &#160;&#160;元素间的空格，IE9及之前版本，不会返回文本节点，而且他浏览器则会返回文本节点，所以使用childNodes和firstChild等属性可能会结果不一致；为此，Element Traversal 规范新定义了一组属性 属性 说明 childElementCount 返回子元素（不包括文本节点和注释）的个数 firstElementChild 指向第一个子元素 lastElementChild 指向最后一个子元素 previousElementSibling 指向前一个同辈元素 nextElementSibling 指向后一个同辈元素 HTML5&#160; &#160; &#160;&#160;HTML5规范围绕着新增标记定义了大量的JS接口；其中一些与DOM重叠，并定义了浏览器应当支持的DOM扩展 与类相关的扩充 getElementsByClassName()方法，接受一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList classList属性，HTML5新增的一种操作类名的方式，classList属性是新集合类型DOMTokenList的实例，该类型还定义一些方法 方法 说明 add(value) 将给定的字符串值添加到列表中；若已存在则什么都不会发生 contains(value) 表示列表中是否存在给定的值 remove(value) 从列表中删除给定的字符串 toggle(value) 若存在则删除给定值，若不存在则添加它 焦点管理 document.activeElement属性，该属性始终引用获得焦点的元素；默认情况下，文档刚加载完的时候保存的是document.body元素的引用，加载过程中则是null document.hasFocus()，用于确定文档是否获得了焦点，alert(document.hasFocus()); //true HTMLDocument的变化 readyState属性，具有两个可能的值：loading和complete，通过这个实现一个指示文档已经加载完成的指示器 兼容模式，检测页面的兼容模式是必要的，IE为此给document添加了一个名为compatMode的属性，该属性用于告诉开发者采用那种渲染模式，标准模式的值为：CSS1Compat，混杂模式下值为BackCompt；该属性已被HTML5接纳 head属性 字符集属性&#160; &#160; &#160;&#160;charset属性表示文档字符集，默认情况下为UTF-16，可以通过meta元素、响应头部及直接设置的方法修改值；defaultCharset则表示默认浏览器及操作系统设置下的文档默认字符集 自定义数据属性&#160; &#160; &#160;&#160;添加前缀data-，可以为元素添加非标准属性（HTML5），添加自定义属性后，可以听过dataset属性来访问自定义属性，var appId = div.dataset.appId; 插入标记 innerHTML属性，在读模式下，该属性返回与调用元素的所有子节点（元素、注释和文本）的标记；写模式下，会根据指定值创建DOM树，然后替换原本的所有子节点；使用该属性在大部分浏览器中，插入&lt;script&gt;元素并不会执行，IE8及之前满足一些条件下可以执行，P295（注意作用域）；总之，使用该元素，尽可能检查一下其中的文本内容 outerHTML属性，读模式下，返回调用它的元素及所有子节点的HTML标签；写模式下，根据制定HTML字符串创建新DOM子树，然后替换调用元素 insertAdjacentHTML()方法，接受两个参数：插入位置和要插入的文本；第一个参数必须如下： 值 说明 beforebegin 在当前元素之前插入一个紧邻的同辈元素 afterbegin 在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素 beforeend 在当前元素之下插如一个新的子元素或在最后一个子元素之后再插入新的子元素 afterend 在当前元素之后插入一个紧邻的同辈元素 内存和性能问题，本节的替换子节点方法可能会引起浏览器内存占用，尤其IE，所以最好手工删除被替换的节点（13章讨论事件处理程序），记住不要将innerHTML或者outerHTML放在循环里进行赋值，应构建一个字符串，循环后将结果赋值到前两者之中 scrollIntoView()方法&#160; &#160; &#160;&#160;该方法可以在所有HTML元素上使用，投过滚动浏览器窗口或者某个容器元素，调用元素就可以出现在视口中；若传入true，或不传入参数，那么窗口滚动后会让调用元素的顶部与视口顶部尽可能平齐；若传入false，调用元素会尽可能全部出现在视口中（可能的话，调用元素的底部会与视口底部平齐） 专有扩展文档模式&#160; &#160; &#160;&#160;IE8引入了该模式，页面的文档模式决定了可以使用什么功能，到了IE9总共可以用以下四种模式 模式 说明 IE5 混杂模式渲染页面 IE7 以IE7标准模式渲染 IE8 以IE8标准模式渲染，可以使用Selector API、更多CSS2和某些CSS3功能以及一部分HTML5 IE9 以IE9标准模式渲染，可以使用ES5、完整的CSS3和更多HTML5 IE的版本有以下不同的值：Edge、EmulateIE9、EmulateIE8、EmulateIE7、9、8、7、5 1234&lt;meta http-equiv = &quot;X-UA-Compatible&quot; content = &quot;IE=EmulateIE7&quot;&gt; //考虑文档模式&lt;meta http-equiv = &quot;X-UA-Compatible&quot; content = &quot;IE=7&quot;&gt; //不考虑文档模式var mode = document.documentMode; //返回文档模式版本号 children模式&#160; &#160; &#160;&#160;该属性是HTMLCollection的实例，只包含元素中同样还是元素的子节点，除此之外和childNodes没有什么差别 contains()方法&#160; &#160; &#160;&#160;调用contains()方法的应该是祖先节点，也就是搜索开始的节点，该方法接受一个参数，若是后代节点返回true compareDocumentPosition()也能确定节点间关系，返回一个位掩码 掩码 关系 1 无关 2 居前 4 居后 8 包含 16 被包含 WebKit版本小于522（safari3），contains()方法不能正常使用 插入文本 innerText，读取时，由浅入深，将文档树拼接起来，写入时，删除元素所有子节点，插入包含相应文本的文本节点；DOM Level3有一个类似的属性textContent属性，但innerText会忽略行内的样式和脚本 outerText，反胃扩大到包含调用它的节点，其他没什么区别 滚动 scrollIntoViewIfNedded(alignCenter)，在当前元素视口不可见时，才滚动浏览器窗口或容器元素；如果可见，什么都不会发生；若alignCenter设置为true，则表示尽量显示在视口中部（垂直方向） scrollByLines(lineCount)，将元素滚动到指定行高，lineCount正负都可以 scrollByPages(pageCount)，将元素的内容滚动到指定页面高度，具体高度由元素高度而定 第十二章 DOM2和DOM3&#160; &#160; &#160;&#160;DOM1级主要定义的是HTML和XML文档的地层结构；DOM2和3级则在此基础之上引入了更多的交互能力，和支持更高级的XML特性；为此DOM2和3具有许多模块，如下 模块 说明 DOM2级核心 在1级核心上构建，为节点添加了更多方法和属性 DOM2级视图 为文档定义了基于样式信息的不同视图 DOM2级事件 说明了如何使用事件与DOM文档交互 DOM2级样式 定义了如何以变成方式来访问和改变CSS样式信息 DOM2级遍历和范围 引入遍历DOM文档和选择其特定部分的新接口 DOM2级HTML 在1级HTML基础上构建，添加更多属性 DOM3级增加了Xpath模块和加载与保存模块 DOM变化&#160; &#160; &#160;&#160;DOM2级和3级的目的用于扩展DOM API，以满足XML更多需求和提供更好的纠错和特性检测能力；P306，提供了一些检测这些模块的代码 针对XML命名空间的变化&#160; &#160; &#160;&#160;技术上来说，HTML不支持XML命名空间，但XHTML支持；P306 node类型的变化 Document类型的变化 Element类型的变化 NamedNodeMap类型的变化 其他方面的变化&#160; &#160; &#160;&#160;这些变化与XML命名空间无关，更倾向于确保API的完整性和可靠性 DocumentType类型的变化，新增3个属性：publicID、systemID表示的是文档类型声明中的两个信息段，在DOM1级中无法访问internalSubset，用于访问包含在文档类型声明中的额外定义 Document类型的变化，importNode()，用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分；若调用appendChild()时传入的节点属于不同的文档，则会导致错误；接受两个参数，要复制的节点和一个表示是否复制子节点的布尔值，返回原来节点的副本，但能够在当前文档中使用 Node类型的变化，isSupport()方法，用于确定当前节点具有什么能力；这个方法接受两个参数：特性名和特性版本号，若浏览器实现了该特性则返回true；isSameNode()和isEqualNode()，这两个方法都接受一个节点参数，并在传入节点与引用节点相同或者相等时返回true（相同指的是两个节点引用的是同一个对象；相等指的是相同类型，即具有相同的属性） 框架的变化，框架和内嵌框架分别用HTMLFrameElement和HTMLFrameElement表示，他们在DOM2级中都有了个新属性叫做contentDocument，指向表示框架内容的文档对象；在此之前只能利用iframe集合取得这个文档对象；IE8之前不支持该属性；所有浏览器都支持contentWindow属性 样式&#160; &#160; &#160;&#160;HTML中定义样式的方式有3种：通过&lt;link/&gt;元素包含外部样式表文件、使用&lt;style/&gt;元素定义嵌入式样式，以及使用style特性定义针对特定元素的样式 访问元素的样式&#160; &#160; &#160;&#160;style对象包含了style特性指定的所有的样式信息，但不包括与外部样式表或嵌入样式表经层叠而来的样式；对于使用短划线的css属性名，必须将其转换为驼峰大小写形式 DOM样式属性和方法，这些属性和方法在提供元素的style特性值的同时，也可以修改样式 属性/方法 说明 cssText 访问style特性中的CSS代码 length 应用给元素的CSS属性的数量 parentRule 表示CSS信息的CSSRule对象 getPropertyCSSValue (propertyName) 返回包含给定属性值的CSSValue对象(cssText和cssValueType) getPropertyPriority (propertyName) 如果给定的属性使用了!important设置，则返回 “important”，否则，返回空字符串 gePropertyValue (propertyName) 返回给定属性的字符串值 item (index) 返回给定位置的css属性的名称 removeProperty (propertyName) 从样式中删除给定属性 setProperty (propertyName,value,priority) 将给定属性设置为相应的值，并加上优先权标志( !important 或 一个空字符串) 计算的样式 document.defaultView.getComputedStyle()，该方法接受两个参数：要取得计算样式的元素和一个伪元素字符串（如:after），如不需要伪元素信息，第二个参数可以是null；该方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式 IE有一个类似的概念，每个具有style属性的元素还有个currentStyle属性；这两个属性，都不返回border样式，因为这是一个综合属性；且这些计算出来的样式都是只读，不能修改；你需要元素具有某个特定的默认值，应手工在样式表中指定该值 操作样式表&#160; &#160; &#160;&#160; CSSStyleSheet类型继承自StyleSheet 属性 说明 disabled 表示样式表是否被禁用的布尔值；这个属性是可读/写的，设置为true可以禁用样式表 href 若样式表是通过&lt;link&gt;包含的，则是样式表的URL；否则是null media 当前样式表支持的所有类型的集合；在IE中，media是一个反映&lt;link&gt;和&lt;style&gt;元素media特性值的字符串 &#160; &#160; &#160;&#160;其余的几个属性，个人感觉不是很常用，且大多IE不支持这些方法 CSS规则，CSSRule对象表示样式表中的每一条规则；它是一个基类型；最常见的如CSSStyleRule对象，但是它包含的属性IE基本不支持（P318），其中较为常用的属性是：cssText、selectorText和style 创建规则，使用insertRule方法，接受两个参数：规则文本和表示在哪里插入规则的索引；IE8及早期版本支持类似方法addRule，接受两个参数：选择符文本和CSS样式信息，一个可选参数：插入规则位置，addRule上限4095条样式规则；还是建议采用第十章的动态加载样式表的技术 删除规则，deleteRule()，这个方法接受一个参数：要删除的规则的位置；与添加规则相似，这不是实际开发中常见的作法，所以慎用 元素大小 偏移量，包括元素在屏幕上占用的所有可见的空间；元素的可见大小由高度、宽度决定，包括所有内边距、滚动条、边框大小（不包括外边距*）；要想知道某个元素的在页面上的偏移量，可以将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如此循环至根元素，可以得到一个基本准确的值 属性 说明 offsetHeight 元素在垂直方向上占用的空间大小，以像素计；包括高度、（可见的）水平滚动条的高度和上下边框的高度 offsetWidth 元素在水平方向上占用的空间大小，以像素计；包括宽度、（可见的）垂直滚动条的宽度、左右边框宽度 offsetLeft 元素的左外边框至包含元素的左内边框之间的像素距离 offsetTop 元素的上外边框至包含元素的上内边框之间的像素距离 offsetParent 此属性不一定与parentNode的值相等；如，&lt;td&gt;元素的offsetParent作为其祖先元素的table元素，因为&lt;table&gt;是DOM层次中距&lt;td&gt;最近的一个具有大小的元素 123456789101112131415161718192021function getElementLeft(element)&#123; var actualLeft = element.offsetLeft; var current = element.offsetParent; while (current !== null)&#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft; &#125; function getElementTop(element)&#123; var actualTop = element.offsetTop; var current = element.offsetParent; while (current !== null)&#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop; &#125; 客户区大小，指的是元素内容及其内边距所占据的空间大小（滚动条占用空间不算），有关客户区大小的属性有两个：clientWidth和clientHeight 12345678910111213function getViewPort()&#123; if(document.compatMode == &quot;BackCompat&quot;)&#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125;else &#123; return &#123; width: document.documentElement.clientWIdth, height: document.documentElement.clientHeight &#125; &#125; &#125; 滚动大小，指的是包含滚动内容的元素大小；实际上，在不包含滚动条的页面中，scrollHeight和clientHeight并不和它们的定义一致；firefox：两组属性始终相等，等于文档内容区域的实际尺寸，而非视口尺寸；Opera、Safari、Chrome：scrollWidth和scrollHeight等于视口大小，而令两者等于文档内容区域的大小；IE：scrollWidth和scrollHeight等于文档内容区域的大小，而令两者等于视口大小；有毒；在确定文档的总高度时（包括基于视口的最小高度），必须取得他们的最大值，才能保证在跨浏览器的环境下取得精确的结果；注意，对于运行在混杂模式下的IE，需要用document.body代替document.documentElement；实际操作中，貌似clientWidth都是取到视口宽度…emmm是改过了么?? ；P324有一张图，可以比较方便的理解这几个属性之间的关系 属性 说明 scrollHeight 在没有滚动条的情况下，元素内容的总高度 scrollWidth 在没有滚动条的情况下，元素内容的总宽度 scrollLeft 被隐藏在内容区域左侧的像素数，通过设置这个属性可以改变元素的滚动位置；0是初始值，大于0则不在初始位置 scrollTop 被隐藏在内容区域上方的像素数，通过设置这个属性可以改变元素的滚动位置；同上 确定元素大小，getBoundingClient()，返回一个矩形属性，包含left、top、right、bottom；IR8及之前版本认为文档左上角左边是(2,2)，其他浏览器是（0,0） 遍历&#160; &#160; &#160;&#160;DOM遍历是深度优先的DOM结构遍历，移动的方向至少有两个（取决于使用遍历类型），遍历以给定节点为根，不可能向上超出DOM树的根节点；定义了两个辅助类型：NodeIterator和TreeWalker NodeIterator&#160; &#160; &#160;&#160;该方法接受四个参数 参数 说明 root 想要作为搜索起点的树中的节点 whatToShow 表示要访问哪些节点的数字代码 filter 是一个NodeFilter对象，或者一个表示应该接受还是拒绝某种特定节点的函数 entityReferenceExpansion 布尔值，表示是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展 whatToShow参数是一个位掩码 常量 说明 NodeFilter.SHOW_ALL 所有类型节点 NodeFilter.SHOW_ELEMENT 元素 NodeFilter.SHOW_ATTRIBUTE 特性 NodeFilter.SHOW_TEXT 文本 NodeFilter.SHOW_COMMENT 注释 NodeFilter.SHOW_DOCUMENT 根节点 NodeFilter.SHOW_DOCUMENT_TYPE 节点类型 NodeFilter.SHOW_DOCUMENT_FRAGMENT 文档片段 可以使用按位或操作符来组合多个选项如： var whatToShow = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT; 可以通过createNodeIterator()方法的filter参数来指定自定义的NodeFilter对象；每个NodeFilter对象只有一个方法，应该访问的节点返回NodeFilter.FILTER_SKIP；可以创建包含acceptNode()方法的对象，然后将这个对象传入createNodeIterator() 12345 var filter = &#123; acceptNode: function(node) &#123; return node.nodeName.toLowerCase() == &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; &#125;&#125;; 也可以采用一个类似acceptNode()的方法： 123 var filter = function(node) &#123; return node.nodeName.toLowerCase() == &quot;p&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;&#125; 如果不指定过滤器，则传入null；P328-330，有几个遍历的例子 TreeWalker&#160; &#160; &#160;&#160;这是一个比前者高级的版本；除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了一些不同方向上遍历DOM结构的方法 方法 说明 parentNode() 遍历到当前节点的父节点 firstChild() 到第一个子节点 lastChild() 到最后一个子节点 nextSibling() 到当前节点的下一个同辈节点 previousSibling() 到当前节点的上一个同辈节点 创建TreeWalker对象，要使用document.createTreeWalker()方法，该方法接受4个参数与document.createNodeIterator()方法相同；所以很多地方可以用该类型替代；该类型还有一个属性，叫做currentNode，表示任何遍历方法在上一次遍历中返回的节点，设置该属性可以修改遍历继续进行的起点 范围DOM中的范围&#160; &#160; &#160;&#160;DOM2级在Document类型中定义了createRange方法；使用hasFeature或直接检测该方法，可以确定浏览器是否支持范围；新创建的范围与创建它的文档关联，只能用于当前文档 &#160; &#160; &#160;&#160;每个范围由一个Range类型的实例表示，下列属性提供了当前范围在文档中的位置信息 属性 说明 startContainer 包含范围起点的节点（选区中第一个子节点的父节点） startOffset 范围在startContainer中起点的偏移量；若startContainer是文本节点，注释节点，CDATA节点，那么startOffset就是范围起点之前跳过的字符数量，否则就是范围中第一个子节点的索引 endContainer 包含范围终点的节点（选区中最后一个节点的父节点） endOffset 范围在endContainer中终点的偏移量，与startOffset规则相同 commonAncestorContainer startContainer和endContainer共同祖先节点在文档树位置最深的那个 使用DOM范围实现简单的选择，selectNode()和selectNodeContents方法，这两个方法都接受一个参数，即一个DOM节点，然后用该节点的信息来填充范围；前者选择整个节点，后者选择它的子节点；调用selectNode时，startContainer，endContainer，commonAncestorContainer都是传入的父节点，也就是document.body，startOffset等于给定节点在其父节点的childNodes集合中的索引，endOffset=startOffset+1，因为只选了一个节点；调用selectNodeContainer时，startContainer，endContainer，commonAncestorContainer都是传入的节点，也就是元素，startOffset始终等于0，因为范围从给定节点的第一个子节点开始，endOffset等于子节点数量；P333还有一些更精细地控制方法 用DOM范围实现复杂选择，使用setStart()和setEnd()方法创建复杂的范围；这两个方法都接受两个参数：一个参照节点和一个偏移量值；对前者来说，参照节点会变成startContainer，而偏移量值会变成startOffset；对后者来说，参照节点会变成endContainer，而偏移量值会变成endOffset；P334 操作DOM范围中的内容，deleteContents()和extraContents()；后者会返回范围的文档片段，利用该值可以将内容插入到其他地方；也可以采用cloneContents()，返回范围中节点的副本 插入DOM范围中的内容，insertNode() 折叠DOM范围，collapse()方法，接受一个参数，布尔值，表示要折叠到范围的哪一端，true是起点 比较DOM范围，compareBoundaryPoints()方法，接受两个参数：表示比较方法的常量值和要比较的范围 常量值 说明 Range.START_TO_START(0) 比较第一个范围和第二个范围的起点 Range.START_TO_END(1) 比较第一个范围的起点和第二个范围的终点 Range.END_TO_END(2) 比较第一个范围和第二个范围的终点 Range.END_TO_START(3) 比较第一个范围的终点和第二个范围的起点 若第一个范围的点位于第二个范围中的点前，返回-1；相等，返回0；反之，返回1 复制DOM范围，cloneRange()方法 清理DOM范围，detach()方法，将范围从文档中分离，然后解除对范围的引用range.detach(); range = null; IE8及更早版本中的范围&#160; &#160; &#160;&#160;IE8及早期版本支持一种类似的概念，即文本范围。。。先当不存在吧","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（8-9）","slug":"JavaScript-高级程序设计-阅读笔记（8-9）","date":"2018-02-18T14:16:32.000Z","updated":"2018-03-07T15:32:31.405Z","comments":true,"path":"2018/02/18/JavaScript-高级程序设计-阅读笔记（8-9）/","link":"","permalink":"http://chinti.xyz/2018/02/18/JavaScript-高级程序设计-阅读笔记（8-9）/","excerpt":"前言&#160; &#160;&#160; &#160;8、9章主要讲解BOM和客户端检测的知识，以浏览器客户端作为对象进行控制；BOM、DOM与事件将会是在开发中接触最多的东西","text":"前言&#160; &#160;&#160; &#160;8、9章主要讲解BOM和客户端检测的知识，以浏览器客户端作为对象进行控制；BOM、DOM与事件将会是在开发中接触最多的东西 第八章 BOM&#160; &#160;&#160; &#160;BOM，浏览器对象模型；BOM提供了许多对象，用于访问浏览器的功能，这些功能与任何网页内容无关 window对象&#160; &#160;&#160; &#160;BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JS访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象 全局作用域&#160; &#160;&#160; &#160;所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法；定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以 12345678910111213141516var age = 29;window.color = &quot;red&quot;;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回falsedelete window.age;//在IE&lt;9时抛出错误，在其他所有浏览器中都返回truedelete window.color; //returns truealert(window.age); //29alert(window.color); //undefined//尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在var newValue = oldValue;//errorvar newValue = window.oldValue; //undefined 窗口位置&#160; &#160;&#160; &#160;使用以下代码可以跨浏览器取得窗口左边和上边的位置 12var leftPos = (typeof window.screenLeft == &quot;number&quot;) ? window.screenLeft : window.screenX;var topPos = (typeof window.screenTop == &quot;number&quot;) ? window.screenTop : window.screenY; &#160; &#160;&#160; &#160;无法再跨浏览器的条件下取得窗口左边和上边的精确坐标值&#160; &#160;&#160; &#160;利用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。前者接受的是新位置的x和y坐标值；后者接受的是在水平和垂直方向移动的像素数 窗口大小&#160; &#160;&#160; &#160;跨浏览器确定一个窗口的大小不是一件简单的事情；虽然各个浏览器均提供了4个属性（innerWidth、innerHeight、outerWidth和outerHeight），但是这些属性返回的却有所不同&#160; &#160;&#160; &#160;但是可以取得页面视口的大小123456789var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth != &quot;number&quot;) &#123; //compatMode用来确定页面是否处于标准模式（第10章） if (document.compatMode == &quot;CSS1Compat&quot;) &#123; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125; 移动设备，window.innerWidth和window.innerHeight保存着可见视口，也就是屏幕上可见页面区域的大小；移动IE浏览器中，document.documentElement.clientWidth和document.documentElement.clientHeight提供了相同的信息 其他移动浏览器中，document.documentElement度量的是布局视口；移动IE浏览器中则存在document.body.clientWidth和document.body.clientHeight中 resizeTo()和resizeBy()方法可以用来调整浏览器窗口的大小 导航和打开窗口&#160; &#160;&#160; &#160;window.open()方法，既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口；接受4个参数：要加载的URL、窗口目标（已有窗口或框架的名称或者是_self、_parent、_top或_black）、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值 第三个参数是一个逗号分隔的设置字符串，表示在新窗口中都显示哪些的特性 设置 值 说明 fullscreen yes或no 表示浏览器窗口是否最大化。仅IE height 数值 表示新窗口的高度。不能小于100 left 数值 表示新窗口的左坐标。不能是负值 location yes或no 表示是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也可能会被禁用（取决于浏览器） menubar yes或no 标识是否在浏览器窗口中显示地址栏。不同浏览器的默认值不同。如果设置为no，地址栏可能会隐藏，也有可能会被禁用（取决于浏览器） resizable yes或no 表示是否可以通过拖动浏览器窗口的边框改变其大小。默认值为no scrollbars yes或no 表示如果内容在视口中显示不下，是否允许滚动。默认值为no status yes或no 表示是否在浏览器窗口中显示状态栏。默认值为no toolbar yes或no 表示是否在浏览器窗口中显示工具栏。默认值为no top 数值 表示新窗口的上坐标。不能是负值 width 数值 表示新窗口的宽度。不能小于100 &#160; &#160;&#160; &#160;例如：window.open(&quot;http://www.wrox.com/&quot;,&quot;wroxWindow&quot;,&quot;height=400,width=400,top=1-,left=10,left=10,resizable=yes&quot;); close()方法可以关闭新打开的窗口 安全限制及弹出窗口屏蔽程序 &#160; &#160;&#160; &#160;由于滥用弹出窗口，浏览器给弹出窗口配置方面增加了限制 12345678910111213141516171819var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;);if (wroxWin == null)&#123; alert(&quot;The popup was blocked!&quot;);&#125;//若果是浏览器扩展或其他程序阻止的弹出窗口，window.open()通常会抛出错误，在必须检测返回值的同时，将对window.open()的调用封装在一个try-catch块中var blocked = false; try &#123; var wroxWin = window.open(&quot;http://www.wrox.com&quot;, &quot;_blank&quot;); if (wroxWin == null) &#123; blocked = true; &#125;&#125; catch (ex) &#123; blocked = true;&#125;if (blocked) &#123; alert(&quot;The popup was blocked!&quot;);&#125; 间歇调用和超时调用&#160; &#160;&#160; &#160;JS是单线程语言，但是通过设置超时值和间歇时间值来调度代码在特定的时刻执行；前者是在指定的事件过后执行，后者则是每隔指定的时间就执行一次代码；超时调用的代码都是在全局作用域执行的 setTimeout()方法，超时调用，接受两个参数：执行的代码和以毫秒标识的时间；第一个参数类似eval()中所使用的字符串，也可以是一个函数 1234567//不建议传递字符串(性能损失)setTimeout(&quot;alert(&apos;Hello world!&apos;)&quot;, 1000);//推荐的调用方式setTimeout(function() &#123; alert(&quot;Hello world!&quot;);&#125;,1000); clearTimeout()方法，取消超时调用，setTimeout()会返回一个超时调用id，将该id作为参数传给clearTimeout()可以取消未执行的超时调用计划 123456//设置超时调用var timeoutId = setTimeout(function &#123; alert(&quot;Hello world!&quot;);&#125;,1000);//取消clearTimeout(timeoutId); setInterval()，间歇调用，传入的参数与setTimeout()类似 clearInterval()，取消间歇调用 系统对话框&#160; &#160;&#160; &#160;通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息；外观由浏览器决定；第一个是警告，第二个可用于确定或者取消，第三个是提示，用于提示用户输入一些文本，接受两个参数，要显示给用户的文本提示和文本输入域的默认值 123456789101112//confirm()if (confirm(&quot;Are you sure?&quot;)) &#123; alert(&quot;I&apos;m so glad you&apos;re sure!&quot;);&#125; else &#123; alert(&quot;I&apos;m sorry to hear you&apos;re not sure. &quot;);&#125;//prompt()var result = prompt(&quot;What is your name? &quot;, &quot;&quot;);if (result !== null) &#123; alert(&quot;Welcome, &quot; + result);&#125; window.print()，显示“打印”对话框 window.find()，显示“查找”对话框 location 对象&#160; &#160;&#160; &#160;location是最有用的BOM对象之一，它既是window对象的属性也是document对象的属性；location对象的用处不只表现在它保存当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员通过不同属性访问这些片段 属性名 例子 说明 hash “#contents” 返回URL中的hash（#号跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.wrox.com:80” 返回服务器名称和端口号（如果有） hostname “www.wrox.com” 返回不带端口号的服务器名称 href “http:/www.wrox.com” 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/WileyCDA/“ 返回URL中的的目录和（或）文件名 port “8080” 返回URL中指定的端口号。不包含端口号则返回空字符串 protocol “http:” 返回页面使用的协议。通常是http:或https: search “?q=javascript” 返回URL的查询字符串。这个字符串以问号开头 查询字符串参数&#160; &#160;&#160; &#160;用于解析查询字符串，然后返回包含所有参数的一个对象1234567891011121314151617181920212223242526272829303132function getQueryStringArgs() &#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null, name = null, value = null, //在for循环中使用 i = 0, len = items.length; //逐个将每一项添加到args对象中 for (i=0; i &lt; len; i++) &#123; item = items[].split(&quot;=&quot;); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if(name.length) &#123; args[name] = value; &#125; &#125; return args;&#125;//示例//假设查询字符串是?q=javascript&amp;num=10var args = getQueryStringArgs();alert(args[&quot;q&quot;]); //&quot;javascript&quot;alert(args[&quot;num&quot;]); //&quot;10&quot; 位置操作&#160; &#160;&#160; &#160;location对象可以通过很多方式改变浏览器位置 首先使用assign()方法并传递一个URL 1234location.assign(&quot;http://www.wrox.com&quot;);//也可以通过以下方法，同样会调用assign()window.location = &quot;http://www.wrox.com&quot;;location.href = &quot;http://www.wrox.com&quot;; 修改location对象的其他属性同样也会改变当前加载的页面；以上任何一种方法修改URL后，浏览器的历史记录就会生成一条新纪录，调用replace()方法，不会形成新纪录，但是用户不能回到前一个页面 reload()方法，重载当前显示页面；不传递参数，页面会以最有效方式重载，通常来说是从缓存中加载，若向该方法传递参数true，则强制从服务器加载 navigator对象&#160; &#160;&#160; &#160;用于识别客户端浏览器的事实标准；通常用于检测显示网页的浏览器类型；在第九章会详细讨论 ####检测插件&#160; &#160;&#160; &#160;一种常见例程用于检测浏览器中是否安装了特定的插件；非IE浏览器，通过plugins数组达成这个目的，该数组包含下列属性 name： 插件的名字（通常回包含检测插件必要的所有信息，但有时并不如此） description：插件的描述 filename：插件的文件名 length：插件所处理的MIME类型数量 &#160; &#160;&#160; &#160;IE浏览器相对比较麻烦，需要通过专有的ActiveXObject类型；IE通过COM对象的方式实现插件，所以检查特定插件必须知道标识符，Flash的标识符ShockwaveFlash.ShockwaveFlash；refresh()可以刷新plugins，传递true会重新加载所有界面，否则只更新集合123456789101112131415161718192021222324252627282930313233343536373839//检测插件（IE中无效）funciton hasPlugin(name) &#123; name = name.toLowerCase(); for (var i=0; i&lt; navigator.plugins.length; i++) &#123; if (navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; &#125; return false;&#125;//检查IE中的插件function hasIEPlugin(name) &#123; try &#123; new ActiveXObject(name); return true; &#125; catch (ex) &#123; return false; &#125;&#125;//检测所有浏览器中的Flashfunction hasFlash() &#123; var result = hasPlugin(&quot;Flash&quot;); if (!result) &#123; result = hasIEPlugin(&quot;ShockwaveFlash.shockwaveFlash&quot;); &#125; return result;&#125;//检测所有浏览器中的QuickTimefunction hasQuickTime() &#123; var result = hasPlugin(&quot;QuickTime&quot;); if(!result) &#123; result = hasIEPlugin(&quot;QuickTime.QuickTime&quot;); &#125; result result;&#125;//检测Flashalert(hasFlash());//检测QuickTimealert(hasQuickTime()); 注册处理程序&#160; &#160;&#160; &#160;registerContentHandler()和registerProtocolHandler()方法（22章，HTML5），这两个方法可以让一个站点指明它可以处理特定类型的信息；registerContentHandler()方法接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称；registerProtocolHandler()方法，接受三个参数：要处理的协议、处理该协议的页面的URL和应用程序的名称 123navigator.registerContentHandler(&quot;application/rss+xml&quot;,&quot;http://www.somereader.com?feed=%s&quot;,&quot;Some Reader&quot;);navigator.registerProtocolHandler(&quot;mailto&quot;,&quot;http://www.somemailclient.com?cmd=%s&quot;, &quot;Some Mail Client&quot;); screen对象&#160; &#160;&#160; &#160;screen对象主要用于表明客户端的能力，包括浏览器窗口外部的显示器的信息，如像素宽度和高度等；每个浏览器中的screen对象有所不同，P214 history对象&#160; &#160;&#160; &#160;history对象保存着用户上网的历史记录，从打开窗口被打开的那一刻起；history是window对象的属性，因此每个浏览器窗口、标签页乃至框架都有自己的history；go()方法可以在用户的历史记录中跳转，可以向前或向后，正负数相当于向前或向后，也可以传递一个字符串参数，跳转至位置最近的页面；当然可以用back()和forward()来代替go() 第九章 客户端检测&#160; &#160;&#160; &#160;现实中，浏览器之间的差异极大，客户端检测既是一种补救措施，也是一种开发策略；先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案 能力检测&#160; &#160;&#160; &#160;通过识别浏览器支持的特定能力，给出解决方案 更可靠的能力检测&#160; &#160;&#160; &#160;在可能的情况下，要尽可能使用typeof进行能力检测；当然许多时候，IE比较例外 1234//在IE8及之前版本中不行，会返回falsefunction hasCreateElement() &#123; return typeof document.createElement == &apos;funciton&apos;;&#125; &#160; &#160;&#160; &#160;P219页介绍了一个IE浏览器中的例子 能力检测，不是浏览器检测&#160; &#160;&#160; &#160;实际开发中，应将能力检测作为确定下一步解决方案的依据，而不是用它来判断用户使用的是什么浏览器1234//确定浏览器是否支持Netscape风格的插件var hasNSPlugins = !!(navigator.plugins &amp;&amp; navigator.plugins.length);//确定浏览器是否具有DOM1级规定的能力var hasDOM1 = !!(document.getElementById &amp;&amp; document.createElement &amp;&amp; document.getElementsByTagName); 怪癖检测&#160; &#160;&#160; &#160;目标是识别浏览器的特殊行为，与能力检测不同，是想知道浏览器存在什么缺陷（bug）；P220-221举了IE8及更早版本和safari3以前版本的例程 用户代理检测&#160; &#160;&#160; &#160;该方法争议很大，它通过检测用户代理字符串确定实际使用的浏览器，该字符串可以通过JS的navigator.userAgent属性访问；在客户端，该方法优先级在前两者之后 用户代理字符串检测技术&#160; &#160;&#160; &#160;浏览器对应的引擎：Gecko：Firefox，Webkit：Safari，Chrome，Presto：Opera；移动浏览器都是基于Webkit，但是会有辅助确定的记号，比如：辅助确定Mac操作系统的“like Mac OS X”，以及确定移动端的：Mobile 识别呈现引擎、平台、window操作系统、移动设备、游戏系统&#160; &#160;&#160; &#160;五大呈现引擎：IE、Gecko、WebKit、KHTML和Opera123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181var client = function()&#123; //呈现引擎 var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //具体的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera)&#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\\/(\\S+)/.test(ua))&#123; engine.ver = RegExp[&quot;$1&quot;]; engine.webkit = parseFloat(engine.ver); //确定是chrome还是safari if (/Chrome\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.safari = parseFloat(browser.ver); &#125; else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100)&#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312)&#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412)&#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\\/(\\S+)/.test(ua) || /Konqueror\\/([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[&quot;$1&quot;]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\\)]+)\\) Gecko\\/\\d&#123;8&#125;/.test(ua))&#123; engine.ver = RegExp[&quot;$1&quot;]; engine.gecko = parseFloat(engine.ver); //确定是不是Firefox if (/Firefox\\/(\\S+)/.test(ua))&#123; browser.ver = RegExp[&quot;$1&quot;]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua))&#123; engine.ver = browser.ver = RegExp[&quot;$1&quot;]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf(&quot;Win&quot;) == 0; system.mac = p.indexOf(&quot;Mac&quot;) == 0; system.x11 = (p == &quot;X11&quot;) || (p.indexOf(&quot;Linux&quot;) == 0); //检测Window操作系统 if (system.win)&#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\\s?(\\d+\\.\\d+)?/.test(ua))&#123; if (RegExp[&quot;$1&quot;] == &quot;NT&quot;)&#123; switch(RegExp[&quot;$2&quot;])&#123; case &quot;5.0&quot;: system.win = &quot;2000&quot;; break; case &quot;5.1&quot;: system.win = &quot;XP&quot;; break; case &quot;6.0&quot;: system.win = &quot;Vista&quot;; break; case &quot;6.1&quot;: system.win = &quot;7&quot;; break; default: system.win = &quot;NT&quot;; break; &#125; &#125; else if (RegExp[&quot;$1&quot;] == &quot;9x&quot;)&#123; system.win = &quot;ME&quot;; &#125; else &#123; system.win = RegExp[&quot;$1&quot;]; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf(&quot;iPhone&quot;) &gt; -1; system.ipod = ua.indexOf(&quot;iPod&quot;) &gt; -1; system.ipad = ua.indexOf(&quot;iPad&quot;) &gt; -1; system.nokiaN = ua.indexOf(&quot;NokiaN&quot;) &gt; -1; //windows mobile if (system.win == &quot;CE&quot;)&#123; system.winMobile = system.win; &#125; else if (system.win == &quot;Ph&quot;)&#123; if(/Windows Phone OS (\\d+.\\d+)/.test(ua))&#123;; system.win = &quot;Phone&quot;; system.winMobile = parseFloat(RegExp[&quot;$1&quot;]); &#125; &#125; //检测iOS版本 if (system.mac &amp;&amp; ua.indexOf(&quot;Mobile&quot;) &gt; -1)&#123; if (/CPU (?:iPhone )?OS (\\d+_\\d+)/.test(ua))&#123; system.ios = parseFloat(RegExp.$1.replace(&quot;_&quot;, &quot;.&quot;)); &#125; else &#123; system.ios = 2; //can&apos;t really detect - so guess &#125; &#125; //检测Andriod版本 if (/Android (\\d+\\.\\d+)/.test(ua))&#123; system.android = parseFloat(RegExp.$1); &#125; //游戏系统 system.wii = ua.indexOf(&quot;Wii&quot;) &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;(); 使用方法&#160; &#160;&#160; &#160;用户代理检测是客户端的最后一个选择，优先采用能力检测和怪癖检测；用户代理检测一般适用于下列情形 不能直接准确地使用能力检测或怪癖检测，比如某些浏览器预留了函数但并没有实现，仅测试函数无法得出信息 同一款浏览器在不同平台下的不同表现 为了跟踪分析等","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（6-7）","slug":"JavaScript-高级程序设计-阅读笔记（6-7）","date":"2018-02-02T15:46:52.000Z","updated":"2018-02-24T14:15:23.961Z","comments":true,"path":"2018/02/02/JavaScript-高级程序设计-阅读笔记（6-7）/","link":"","permalink":"http://chinti.xyz/2018/02/02/JavaScript-高级程序设计-阅读笔记（6-7）/","excerpt":"前言&#160; &#160;&#160; &#160;4，6，7章主要讲解作用域链、JavaScript面向对象、原型-构造函数机制、闭包等概念，这些都是JavaScript的重中之重","text":"前言&#160; &#160;&#160; &#160;4，6，7章主要讲解作用域链、JavaScript面向对象、原型-构造函数机制、闭包等概念，这些都是JavaScript的重中之重 第六章 面向对象的程序设计&#160; &#160;&#160; &#160;面向对象语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象，但是ES没有类，所以它的对象也与其他语言中的对象有所不同，每个对象都是基于一个引用类型创建的，可以是原生类型，也可以是自己定义的 理解对象&#160; &#160;&#160; &#160;可以创建一个Object对象，但现在对象字面量称为创建对象的首选模式 属性类型 数据属性，包含一个数据值的位置，在这个位置可以读取和写入值 数据属性 默认值 说明 [[Configurable]] true 表示能否通过delete删除属性从而重新定义属性 [[Enumerable]] true 表示可否通过for-in循环返回属性 [[Writable]] true 表示可否修改属性的值 [[Value]] undefined 包含这个属性的数据值，读取属性值的时候从这个位置读，写入的新值保存在这个位置 若要改变属性默认的特性，ES5提供了一个方法：Object.defineProperty()方法，该方法接受三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value，不要在ie8上使用 12345var person = &#123;&#125;;Object.defineProperty(person,&quot;name&quot;,&#123; writable: false, value: &quot;Nicholas&quot;&#125;); 访问器属性，ES5：Object.defineProperty()方法，旧方法：__defineGetter__()，__defineSetter__ 访问器属性 默认值 说明 [[Configurable]] true 表示能否通过delete删除属性从而重新定义属性 [[Enumerable]] true 表示可否通过for-in循环返回属性 [[Get]] undefined 在读取属性时调用的函数 [[Set]] undefined 在写入属性时调用的函数 123456789101112131415var book = &#123; _year: 2004; edition: 1;&#125;;Object.defineProperty(book,&quot;year&quot;,&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edtion += newValue - 2004; &#125; &#125;&#125;); 定义多个属性&#160; &#160;&#160; &#160;Object.defineProperties()方法 读取属性的特性&#160; &#160;&#160; &#160;Object.getOwnPropertyDescriptor()方法1234var descriptor = Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);alert(descriptor.value); //2004alert(descriptor.configurable); //false... 创建对象&#160; &#160;&#160; &#160;Object构造函数或对象字面量都可以用来创建单个对象，但是同一个接口创建多个对象，会产生大量重复代码 工厂模式&#160; &#160;&#160; &#160;该设计模式抽象了创建具体对象的过程，ES无法创建类，于是发明了一种函数，可以封装以特定接口创建对象的细节 1234567891011function createPerson(name,age,job) &#123; var o = new Project(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var person = createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;); &#160; &#160;&#160; &#160;该方法虽然解决了创建多个相似对象的问题，但是却没解决对象识别的问题 构造函数模式&#160; &#160;&#160; &#160;构造函数可用来创建特定类型的对象，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法123456789101112function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person = new Person(&quot;Grey&quot;,&quot;27&quot;,&quot;Doctor&quot;);alert(person.constructor == Person); //truealert(person instanceof Object); //truealert(person instanceof Person); //true &#160; &#160;&#160; &#160;创建自定义的构造函式可以将它的实例标识为一种特定的类型，这是构造函数模式胜过工厂模式的地方。使用构造函数模式的主要问题是，每个方法都要在每个实例上重新创建一遍，而将这个方法转移到构造函数外部，但是又存在一个问题全局作用域中定义的函数实际上只被某个对象调用，尤其是如果有多个这样的函数存在，整个引用类型就毫无封装性可言。 原型模式&#160; &#160;&#160; &#160;我们所创建的每个函数都有一个prototype属性，该属性是一个指针指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法1234567891011121314function Person() &#123; Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function()&#123; alert(this.name); &#125;&#125;var person1 = new Person();person1.sayName(); //Nicholasvar person2 = new Person();person2.sayName(); //Nicholasalert(person1.sayName == person2.sayName); //true 理解原型对象 &#160; &#160;&#160; &#160;只要创建了一个新函数，就会根据一组特定规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。默认情况下，所有原型对象会自动获取一个constructor（构造函数）属性，这个属性是一个指向prototype属性所在函数的指针。 &#160; &#160;&#160; &#160;比如之前的代码，Person的prototype属性以及Person1与Person2的[[Prototype]]属性指向Person Prototype，然后Person Prototype的constructor属性指向Person 函数名 说明 示例 isPrototypeOf() 确定对象之间是否存在原型关系 alert(Person.prototype.isPrototypeOf(person1)); //true Object.getPrototypeOf() 该方法返回[[Prototype]]的值 alert(Object.getPrototypeOf(person1) == Person.prototype); //true hasOwnProperty() 检测一个属性是否存在于实例中（存在于原型中返回false） alert(person1.hasOwnProperty(“name”)); //false in 通过对象能够访问给定属性时返回true(无论是实例还是原型中) alert(“name” in person1); //true for-in 返回的是所有能够通过对象访问的、可枚举属性(无论是实例中的还是原型中的) Object.keys() 接受一个对象作为参数，返回一个包含所有可枚举属性的字符串数组 alert(Object.keys(person.prototype)); //“name,age,job,sayName” Object.getOwnPropertyName() 可以取得所有实例属性，无论是否枚举 alert(Object.getOwnPropertyNames(Person.prototype)); //“constructor,name,age,job,sayName” &#160; &#160;&#160; &#160;可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果在实例中添加了一个同名属性，该属性将会屏蔽原型中的那个属性，使用delete操作符可以删除实例属性，从而恢复访问 更简单的原型语法 &#160; &#160;&#160; &#160;每添加一个属性和方法就要敲一遍Person.prototype，为了视觉上更好的封装原型，可以采用一个包含所有属性和方法的对象字面量来重写整个原型&#160; &#160;&#160; &#160;[注]使用该方法封装原型，本质上完全重写了prototype对象，因此constructor属性变成了新对象的属性，即指向了Object 1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123; //constructor: Person, //包含这句，可以确保该属性的值为Person，但是同样会变为可枚举 name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function() &#123; alert(this.name); &#125;&#125;;var friend = new Person();alert(friend instanceof Person); //true 检测是否存在prototype属性alert(friend instanceof Object); //truealert(friend.constructor == Person); //false //若加上之前那条，该属性会变成truealert(friend.constructor == Object); //true &#160; &#160;&#160; &#160;ES5之后可以使用Object.defineProperty()将construct属性改为不可枚举 1234Object.defineProperty(Person.prototype,&quot;constructor&quot;, &#123; enumerable: false; value: Person&#125;); 原型的动态性，尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来；重写整个原型对象会切断现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍是最初的原型，P157，有点绕 原生对象的原型，所有原生的引用类型也是采用这种模式创建的；通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法，但是最好不要这么干 原型对象的问题，它省略了构造函数传递初始化参数，导致默认情况下会取得相同的属性，但最大的问题还是它共享的本性导致的 组合使用构造模式和原型模式&#160; &#160;&#160; &#160;该方法是最为常见的创建自定义类型的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性；此外，该模式也支持向构造函数传递参数 1234567891011121314151617181920function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;Shelby&quot;, &quot;court&quot;]&#125;Person.prototype = &#123; constructor : Person, sayName : function() &#123; alert(this.name); &#125;&#125;var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);person1.friends.push(&quot;Van&quot;);alert(person1.friends); //&quot;Shelby,Count,Van&quot;alert(person2.friends); //&quot;Shelby,Count&quot;alert(person1.friends === person2.friends); //falsealert(person2.friends === person2.sayName); //true 动态原型模式&#160; &#160;&#160; &#160;动态原型模式将所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点 1234567891011121314function Person(name, age, job) &#123; //属性 this.name = name; this.age = age; this.job = job; //方法 if (typeof this.sayName != &quot;function&quot;) &#123; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造模式&#160; &#160;&#160; &#160;该模式与工厂模式其实一摸一样，除了使用new操作符并把使用的包装函数叫做构造函数；该方法不能依赖instanceof操作符来确定对象类型，所以尽量不要使用这种模式 123456789101112131415function SpecialArray() &#123; //创建数组 var values = new Array(); //添加值 values.push.apply(values, arguments); //添加方法 values.toPipedString = function() &#123; return this.join(&quot;|&quot;); &#125;; //返回数组 return values;&#125;var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);alert(colors.toPipedString()); //&quot;red|blue|green&quot; 稳妥构造函数模式&#160; &#160;&#160; &#160;稳妥对象，指的是没有公共属性，也不引用this的对象，其他与寄生构造函数类似 123456789101112function Person(name, age, job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); &#125;; //返回对象 return o;&#125; 继承&#160; &#160;&#160; &#160;由于函数没有签名，在ECMAScript中无法实现接口继承，只支持实现继承，且主要依靠原型链实现 原型链※&#160; &#160;&#160; &#160;ES中将原型链作为实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法；让原型对象等于另一个类型的实例，层层递进&#160; &#160;&#160; &#160;构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针 12345678910111213141516171819202122232425function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();//SuperType实例中的所有方法和属性，现也存在于SubType.prototype中SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //truealert(instance instanceof Object); //truealert(instance instanceof SuperType); //truealert(instance instanceof SubType); //truealert(Object.prototype.isPrototypeOf(instance)); //truealert(SuperType.prototype.isPrototypeOf(instance)); //truealert(Subtype.prototype.isPrototypeOf(instance)); //true 别忘记默认的原型，所有引用类型默认继承了Object，该继承方式也是通过原型链 确定原型和实例的关系，两种方式，第一种是instanceof操作符；第二种方式是采用isPrototypeOf()方法 谨慎地定义方法，给原型添加方法的代码（覆盖或添加）一定要放在替换原型的语句之后；在通过原型链继承之时不要使用字面量创建原型方法，会重写原型链 123456789//继承了SuperTypeSubType.prototype = new SuperType();//添加新方法SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;SubType.prototype.getSuperValue = function() &#123; return false;&#125;; 原型链的问题：其一，通过原型实现继承时，原型实际上会成为另一个类型的实例，所以原先的实例属性顺利成长的变成现在的原型属性，最终这些属性会被现有原型的实例所共享；其二，在不影响所有对象实例的情况下，给超类型的构造函数传递参数；因此，实践中很少会单独使用原型链 1234567891011121314function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123;&#125;//继承了SuperTypeSubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot; 借用构造函数&#160; &#160;&#160; &#160;该技术的基本思想是在子类型构造函数的内部调用超类型构造函数（apply()方法和call()方法） 12345678910111213function SuperType() &#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType() &#123; //继承了SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green&quot; 传递参数 123456789101112function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; //继承了SuperType， 同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;); //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //&quot;Nicholas&quot;alert(instance.age); //29 借用构造函数的问题，无法函数复用，所以也不会单独使用 组合继承※&#160; &#160;&#160; &#160;思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承；最常用的方式，且instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象 12345678910111213141516171819202122232425262728293031function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; //继承属性 SuperType.call(this, name); this.age = age;&#125;//继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;;var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;instance2.sayAge(); //27 原型式继承&#160; &#160;&#160; &#160;在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例；相当于object()对传入其中的对象进行了一次浅复制（只复制了一层对象的属性） 123456789101112131415161718192021222324252627282930var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;//Example01function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot;//Example02，ES5新增了object.create()方法规范了原型式继承，该方法第二参数与Object.defineProperties()方法的第二个参数格式相同var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;); var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;); alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 寄生式继承&#160; &#160;&#160; &#160;创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象 123456789101112131415function createAnother(orignal) &#123; var clone = object(orignal); //通过调用函数创建一个新对象 clone.sayHi = function() &#123; //以某种方式来增强这个对象 alert(&quot;hi&quot;); &#125;; return clone; //返回这个对象 &#125;var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 寄生组合式继承※&#160; &#160;&#160; &#160;组合继承最大的问题是不论什么情况下，都会调用两次超类型构造函数；寄生组合式继承，本质上就是使用寄生式继承来继承超类型的的原型，然后将结果制定给与子类型的原型，基本模式如下： 123456789101112131415161718192021222324function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype;&#125;//Examplefunction SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;; function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; &#160; &#160;&#160; &#160;该模式下，只调用了一次SuperType构造函数，因此避免在SubType.prototype上面创建不必要的属性；该方式是实现基于类型继承的最有效的方式 第七章 函数表达式&#160; &#160;&#160; &#160;本章主要介绍函数表达式的特征，如何使用函数实现递归，以及使用闭包定义私有变量 &#160; &#160;&#160; &#160;定义函数的方法有两种：函数声明和函数表达式 123456789101112//函数声明function functionName(arg0, arg1, arg2) &#123; //函数体&#125;//只在Firefox、Safari、Chrome和Opera有效alert(functionName.name); //&quot;functionName&quot;//函数表达式，这种情况下创建的函数也被称为匿名函数（拉姆达函数）var functionName = function(arg0, arg1, arg2)&#123; //函数体&#125;； 递归12345678910111213141516171819202122232425262728function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;//该方法表面没什么问题，但是如下调用会导致出错var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); //error//非严格模式下，可以使用argument.callee解决这个问题，它是一个指向正在执行的函数的指针function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125;//严格模式var factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;); 闭包※&#160; &#160;&#160; &#160;闭包是指有权访问另一个函数作用域中的变量的函数；创建闭包的常见方式，就是在一个函数内部创建另一个函数&#160; &#160;&#160; &#160;注意作用域链的关系！！！ P179&#160; &#160;&#160; &#160;如何创建作用域链以及作用域链有什么作用对于理解闭包至关重要 ；当某个函数被调用时，会创建一个执行环境及相应的作用域链，然后，使用arguments和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链中点的全局执行环境&#160; &#160;&#160; &#160;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部环境的变量对象，则只在函数执行的过程中存在。创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域的前端。对于该例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，他只引用但不实际包含变量对象&#160; &#160;&#160; &#160;无论何时在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。通常，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）；闭包的情况则有所不同，在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中；匿名函数的作用域被销毁后，外部函数的活动对象才会被销毁；过度使用闭包可能导致内存占用过多，请谨慎使用 闭包与变量&#160; &#160;&#160; &#160;作用域链的配置机制有个副作用，即闭包只能取得包含函数中任何变量的最后一个值；闭包保存的是整个变量对象，而不是某特殊变量 1234567891011121314151617181920212223//该函数会返回一个函数数组，但是由于每个函数的作用域链中都保存着createFunctions()函数的活动对象，也就是说引用的都是同一个变量i，那么当最后createFunction返回后，变量的值为10，则result每个值都是10function createFunctions() &#123; var result = new Array(); for (var i=0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; &#125;; &#125; return result;&#125;//可以创建另一个匿名函数强制使闭包行为符合预期;调用每个匿名函数时我们传入了变量i，这样result中每个函数都有自己num变量的一个副本，因此可以返回不同值function createFunctions() &#123; var result = new array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function(num) &#123; return funciton() &#123; return num; &#125;; &#125;(i); &#125; return result;&#125; 关于this对象&#160; &#160;&#160; &#160;匿名函数的执行环境具有全局性；全局函数中，this等于window 12345678910var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc : function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;The Window&quot; （非严格模式下） &#160; &#160;&#160; &#160;这段我稍微有点绕进去，不是很理解为什么两个括号，我尝试将getNameFunc()()删去一个()后，返回如下结果 1234此网页显示：function() &#123; return this.name;&#125; &#160; &#160;&#160; &#160;书上是这样描述的，该代码首先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含了一个方法——getNameFunc()，它返回一个匿名函数，该匿名函数又返回this.name。由于getNameFunc()返回一个函数，所以调用object.getNameFunc()()会立即调用它所返回的函数，从而返回一个字符串。 &#160; &#160;&#160; &#160;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时只能搜索到他的活动对象，所以无法直接访问外部函数中的这两个变量，不过可以将外部作用域中的this对象保存在一个闭包能够访问到的变量里 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My Object&quot;, getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //&quot;My Object&quot; &#160; &#160;&#160; &#160;特殊情况下，this的值会意外的改变，不过一般不会这么使用12345678910111213var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getName: function()&#123; return this.name; &#125;&#125;; alert(object.getName()); //&quot;My Object&quot;alert((object.getName)()); //&quot;My Object&quot;alert((object.getName = object.getName)()); //&quot;The Window&quot; 非严格模式 内存泄漏&#160; &#160;&#160; &#160;闭包在ie的某些版本中会导致一些特殊的问题，比如说闭包的作用域链中保存这一个HTML元素，那么该元素将无法被销毁；不过只需稍作修改即可12345678910111213141516171819//element的引用数至少为1，占用的内存永远不会被回收function assignHandler() &#123; var element = document.getElementById(&quot;someElement&quot;); element.onclick = function() &#123; alert(element.id); &#125;;&#125;//稍作修改，解除对DOM对象的直接引用function assignHandler() &#123; var element = document.getElementById(&quot;someElement&quot;); var id = element.id; element.onclick = function() &#123; alert(id); &#125;; element = null;&#125; 模仿块级作用域&#160; &#160;&#160; &#160;JS块级作用域不存在的；块语句中定义的变量，实际上是包含函数中而非语句中创建的；所以一旦变量有定义开始，就可以在函数内部随处访问，即使错误的重新声明，该声明会被无视掉；匿名函数可以用来模仿块级作用域，在函数声明外加上一对圆括号可以转换为函数表达式 123456789101112var someFunction = function() &#123; //这里是块级作用域&#125;;someFunction();function() &#123; //块级作用域&#125;(); //出错，函数声明后不能跟圆括号(function() &#123; //块级作用域&#125;)(); //可以模仿一个块级作用域（私有作用域），该方法可以减少闭包占用的内存问题，函数执行完毕，就可以立即销毁其作用域链 私有变量&#160; &#160;&#160; &#160;严格来说，JS是没有私有成员的概念的，所有的对象属性都是公有的&#160; &#160;&#160; &#160;任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。而那些有权访问私有变量和私有函数的公有方法被称为特权方法 1234567891011121314151617181920212223242526//第一种是在构造函数中定义特权方法function MyObject() &#123; //私有变量和私有函数 var privatedVariable = 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125; //利用私有和特权成员，可以隐藏那些不应该被直接修改的数据 function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; &#125; &#125; var person = new Person(&quot;Nicholas&quot;); alert(person.getName()); //&quot;Nicholas&quot; person.setName(&quot;Grey&quot;); alert(person.getName()); //&quot;Grey&quot; &#160; &#160;&#160; &#160;由于采用构造函数的方法导致具有构造函数模式的缺点 静态私有变量123456789101112131415161718192021222324252627282930313233343536373839404142434445//基本模式(function() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //构造函数，初始化未经声明的变量总会创建一个全局变量 MyObject = function() &#123; &#125;; //公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;) &#123;&#125;;//例如(function()&#123; //私有变量和私有函数 var name = &quot;&quot;; //静态的、由所有实例共享的属性 Person = function(value)&#123; name = value; &#125;; //公有/特权方法 Person.prototype.getName = function()&#123; return name; &#125;; Person.prototype.setName = function (value)&#123; name = value; &#125;;&#125;)(); var person1 = new Person(&quot;Nicholas&quot;); alert(person1.getName()); //&quot;Nicholas&quot; person1.setName(&quot;Greg&quot;); alert(person1.getName()); //&quot;Greg&quot; var person2 = new Person(&quot;Michael&quot;); alert(person1.getName()); //&quot;Michael&quot; alert(person2.getName()); //&quot;Michael&quot; &#160; &#160;&#160; &#160;多查找作用域链中的一个层次，就会一定程度上影响查找速度；这就是闭包和私有变量的一个不足之处 模块模式（module pattern）&#160; &#160;&#160; &#160;模块模式为单例（只有一个实例的对象）创建私有变量和特权方法；如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，就可以使用模块模式 12345678910111213141516var singleton = function() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //特权/公有方法和属性 return &#123; publicProperty: true; publicMethod: function() &#123; privateVariable++; return privateFunction(); &#125; &#125;;&#125;(); 增强的模块模式&#160; &#160;&#160; &#160;可以在返回对象前加入对其增强的代码 123456789101112131415161718192021222324252627function BaseComponent()&#123;&#125;function OtherComponent()&#123;&#125;var application = function()&#123; //私有变量和函数 var components = new Array(); //初始化 components.push(new BaseComponent()); //创建application的一个局部副本 var app = new BaseComponent(); //公共接口 app.getComponentCount = function()&#123; return components.length; &#125;; app.registerComponent = function(component)&#123; if (typeof component == &quot;object&quot;)&#123; components.push(component); &#125; &#125;; //返回副本 return app;&#125;();alert(application instanceof BaseComponent);application.registerComponent(new OtherComponent());alert(application.getComponentCount()); //2","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript 高级程序设计 阅读笔记（1-5）","slug":"JavaScript-高级程序设计-阅读笔记（1-5）","date":"2018-01-25T13:52:27.000Z","updated":"2018-02-02T15:37:59.483Z","comments":true,"path":"2018/01/25/JavaScript-高级程序设计-阅读笔记（1-5）/","link":"","permalink":"http://chinti.xyz/2018/01/25/JavaScript-高级程序设计-阅读笔记（1-5）/","excerpt":"前言&#160; &#160; &#160;&#160;700页。。好厚啊。。慢慢读吧，完整把javaScript过一遍再去学jQuery还有vue什么的框架和库吧（等一个月后百度前端学院开班。。不知道今年开不开），本书源代码可以在www.wrox.com中下载，第一到第五章是语言基础知识","text":"前言&#160; &#160; &#160;&#160;700页。。好厚啊。。慢慢读吧，完整把javaScript过一遍再去学jQuery还有vue什么的框架和库吧（等一个月后百度前端学院开班。。不知道今年开不开），本书源代码可以在www.wrox.com中下载，第一到第五章是语言基础知识 第一章 JavaScript 简介&#160; &#160; &#160;&#160;首先一个完整的JavaScript实现包含了三个部分，核心（ECMAScript，由ECMA-262定义），文档对象模型（DOM），浏览器对象模型（BOM）&#160; &#160; &#160;&#160;其中，ECMAScript包含了语法、类型、语句、关键字、保留字、操作符以及对象&#160; &#160; &#160;&#160;而DOM是提供了一个针对XML但经过扩展用于HTML的应用程序编程接口（API），DOM包含DOM1级，DOM2级，DOM3级，其中DOM1级又由两个模块组成，DOM Core与DOM HTML，而DOM2级则是再次智商扩充了新的模块，如：DOM视图、DOM事件、DOM样式、DOM遍历和范围，在DOM3级中引入了DOM加载和保存模块，还有DOM验证模块&#160; &#160; &#160;&#160;BOM一般值处理浏览器窗口和框架，但是习惯上所有针对浏览器的JS扩展皆算作BOM的一部分 第二章 在HTML中使用JavaScript&#160; &#160; &#160;&#160;这章稍作了解好了，正常不会再HTML直接使用JS的了吧 defer 延迟脚本，HTML5中明确规定内嵌脚本将会忽视这个属性 async 异步脚本 由于HTML5在这个时间点已经被广泛应用，之后XHTML部分就直接略过了 文档模式，有多种模式，使用HTML5用：&lt;!DOCTYPE html&gt; noscript元素 第三章 基本概念&#160; &#160; &#160;&#160;本章主要介绍ES3，并对ES5的变化进行一些说明（ES6是2015年新制定的标准，按需再去了解吧） 语法 区分大小写 标识符，第一个字符必须是一个字母、一个下划线（_）或一个美元符号（$），其他字符可以是字幕、下划线、美元符号或数字 按照惯例采用驼峰大小写格式 注释，//单行注释，/*...*/多行注释 严格模式（strict mode），在脚本顶部或者制定函数内部&quot;use strict&quot;; 语句，以一个分号结尾，若省略分号，则有解析器确定 关键字和保留字，关键字是一组具有特殊用途的的字，保留字则为一组可能在将来使用的关键字 变量，弱类型，松散类型，才用var进行定义 数据类型，5种简单数据类型：Undefined、Null、Boolean、Number和String，还有一种复杂数据类型Object typeof操作符，特别：null会返回Object，因为被认为是一个空的对象引用，未初始化的变量会自动赋予undefined值 相等性测试时，null与undefined会返回true Boolean类型，利用Boolean()可以把任何其他值转型，一般来说空字符串、0和NaN、null还有undefined会被转换成false Number类型，八进制必须以0开头，十六进制必须以0x开头，存在+0与-0，可以采用科学记数法，即3.125e7，同时不要使用浮点数值做判断，因为精度不能保证（IEEE754） 数值范围，Number.MIN_VALUE == 5e-324，Number.MAX_VALUE == 1.7976931348623157e+308，Infinity表示无穷值，isFinite()判断有穷性 NaN，Not a Number，NaN与任何值不相等包括自己，任何对NaN的操作都会返回NaN，任何数值除以非数值就会返回NaN，isNaN()判断不是数值，无法被转换为数值就会返回true 数值转换，Number()、parseInt()、parseFloat() 函数 八进制 十六进制 字符串 空字符串 Number() 忽略前导0，转换为十进制 转换为相同大小的十进制 包含其他格式的转换为NaN 0 parseInt() 转换为相同大小的十进制，指定基数为8 同前，基数指定为16 若第一个字符为数字，则会一直解析到非数值为止，若第一个字符为非数字，转化为NaN NaN parseFloat() 忽略0，理解为十进制 转化为0 同上 同上 string类型，”\\”转义字符，例如\\n \\t \\b \\r \\f \\\\ \\&#39; \\&quot; \\xnn \\unnnn，字符串一旦创建，值就是不可改变的，需要重新创建，toString()方法，该方法可以指定基数，将数值转化为对应进制的字符串值，null和undefined没有这个方法 Object类型，对象，其实就是一组数据和功能的集合，var o = new Object();省略括号有效，但不推荐，每个Object实例都拥有下列属性和方法 属性和方法名 说明 constructor 保存着用于创建当前对象的函数 hasOwnProperty(propertyName) 用于检查给定属性在当前对象实例中是否存在 isPrototypeOf(object) 用于检查传入的对象是否是当前对象的原型 propertyIsEnumerable(propertyName) 用于检查给定的属性是否能够使用for-in语句来枚举 toLocalString() 返回对象的字符串表示，该字符串与执行环境的地区对应 toString() 返回对象的字符串表示 valueOf() 返回对象的字符串、数值或布尔值表示 操作符 一元操作符，递增递减操作符++age; --age;和C差不多，一元加和一元减，用在数值前表示正负，用于其他的值会强制执行一次Number() 位操作符，按位非（NOT），~，相当于操作数的负值减一，按位与（AND），&amp;，按位或（OR），|，按位异或（XOR），^，左移，&lt;&lt;，例：var newValue = oldValue &lt;&lt; 5;，有符号右移，&gt;&gt;，无符号右移，&gt;&gt;&gt; 布尔操作符，逻辑非，!，逻辑与（短路操作，若第一个为false后一条语句不执行），&amp;&amp;，逻辑或，||，可以利用这个避免为后一个变量赋值 乘性操作符，乘法，*，除法，/，其中零被零除为NaN，求模，% 加性操作符，加法，+，正负无穷相加为NaN，减法，- 关系操作符，&lt; &gt; &lt;= &gt;=，可以比较字符串，每个字符编码的大小 相等操作符，相等(==)和不相等(!=)——先转换再比较，全等(===)和不全等(!==)——仅比较而不转换 条件操作符，variable = boolean_expression ? true_value : false_value;，例如：var max = (num1&gt;num2) ? num1 : num2; 赋值操作符，=，还有一些复合赋值操作符 逗号操作符 语句 if语句，do-while语句，while语句，for语句，for-in语句，建议使用for-in之前，先检测确认该对象的值不是null或undefined label语句，可以在代码中添加标签，label： statement，该标签可以由break或continue语句引用 with语句，将代码的作用域设置到一个特定的对象中，with(expression) statement;，不建议使用，且严格模式下会报错 switch语句，采用的是全等操作符 函数，function，可以向函数传递任意数量的参数，在函数体内可以通过arguments对象来访问这个参数数组，不存在重载 第四章 变量、作用域和内存问题&#160; &#160; &#160;&#160;本章主要介绍基本类型和引用类型的值，以及理解执行环境和垃圾收集 基本类型和引用类型的值，基本类型指的是简单数据段，引用类型指的是由多个值构成的对象 动态的属性，只能给引用类型值动态的添加属性，以便将来使用 复制变量值，引用类型相当于创建了一个副本到原副本的指针 传递参数，访问变量有按值和按引用两种方式，而参数只能按值传递 检测类型，typeof操作符可以确定一个变量是字符串、数值、布尔值还是undefined的最佳工具，若变量的值是null或对象，都会返回object instanceof用于确定一个值使用哪种引用类型，alert(person instanceof Object);，基本类型则返回false 执行环境及作用域 全局执行环境被认为是window对象 每个函数都有自己的执行环境，作用域链用于保证对执行环境有权访问的所有变量和函数的有序访问 延长作用域链，try-catch语句的catch块和with语句会在作用域的前端临时增加一个变量对象 没有块级作用域，所以在if和for语句中所声明的变量在执行完毕后不会被销毁 函数中声明的变量，若没有使用var声明，该变量会自动被添加到全局环境 查询标识符 垃圾收集，JS具有自动垃圾收集机制，原理很简单，具体到浏览器中，则通常有两种策略 标记清除（mark-and-sweap），当变量进入环境时，将这个变量标记为“进入环境”，该方法较为常见 引用计数（reference counting），会造成很多麻烦，例如循环引用 性能问题，可以直接调用window.CollectGarbage()触发垃圾收集过程，但是最好不要这么做 管理内存，使用具备垃圾收集机制的语言，一般开发人员不需要操心内存管理，优化内存的最佳方式，就是为执行中的代码只保存必要的数据，一旦数据不再用，最好将其设为null来释放引用。不过，解除一个值的引用并不意味着自动回收该值所占用的内存，接触引用的真正作用是让值脱离执行环境，便于垃圾收集器下次运行时回收 第五章 引用类型&#160; &#160; &#160;&#160;要注意，虽然引用类型与类看起来相似，但是他们并不是相同的概念，虽然技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构 Object类型，创建Object实例的方式有两种，第一种使用new操作符后跟Object()，另一种方式是对象字面量表示法，一般来说访问对象属性时使用的是点表示法，除非必须使用变量来访问属性才使用方括号表示法 Array类型，同样使用字面量表示法时，也不会调用函数，数组的length不是只读的，所以可以通过修改它在末尾移除项或者添加新项，利用colors[colors.length]=&#39;black&#39;;可以在尾端添加一个值并length自动加一，数组最多可以包含4294967295项 检测数组，两种方法，if (value instanceof Array) {...}和if (Array.isArray(value)){...}，前种方法假定只有一个全局执行环境 转换方法，toLocaleString() toString() valueOf()，用join方法可以返回不同的分隔符构建的字符串，alert(colors.join(&#39;||&#39;)); 栈方法，push() pop()，队列方法，push() shift()，unshift作用与shift相反，用于在前端推入项，利用unshift和pop可以反向模拟队列 重排序方法，reserve()，反转数组，sort()，会调用toString()方法，所以比较的是字符串，而且sort可以接受一个比较函数作为参数，实现降序升序排列，这两个方法的返回值是经过排序之后的数组 操作方法，concat()方法可以基于当前数组中的所有项创建一个新数组，若给它传递参数，则会将参数添加到结果数组的末尾，var colors2 = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);；slice()方法可以给予当前数组中的一个或多个项创建一个新数组，接收一个或者两个参数，即要返回项的起始和结束位置，该方法返回起始和结束位置之间的项，但是不包括结束位置的项；splice()方法功能强大，可以实现数组中元素的删除，插入，替换。该方法接受两个或者三个参数，起始项的位置，要删除的个数，带插入的元素，该方法始终会返回一个数组，该数组包含从原始数组中删除的项 位置方法，ES5添加了两个位置方法：indexOf()和lastIndexOf()，前者从前往后查找，后者从后往前查找，这两个方法都可以接受两个参数：要查找的项和（可选的）表示查找起点位置的索引，没有找到则返回-1 迭代方法，以下均是对数组中的每一项运行给定函数，并且这些方法都不会修改数组中包含的值，参数似乎全是function(item,index,array){...}， every()，如果该函数对每一项都返回true，则返回true filter()，返回该函数会返回true的项组成的数组 forEach()，这个方法没有返回值 map()，返回每次函数调用的结果组成的数组 some()，如果该函数对任一项返回true，则返回true 归并方法：reduce()和reduceRight()，这两个方法都接受两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值，这个函数接收4个参数：前一个值、当前值、项的索引和数组对象。fucntion(prev,cur,index,array){...} Date类型 var now = new Date();，在调用Date构造函数而不传递参数的情况下，新创建的对象自动获取当前日期和时间 若想根据特定日期和时间创建日期对象，必须传入表示改日期的毫秒数，提供了两个方法：Date.parse()和Date.UTC()，例如：var someDate(Date.parse(&quot;May 25, 2004&quot;));，var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));，月份中的天数从1开始，其他都是从0开始，P99页 ES5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数 继承的方法，在不同浏览器中返回的日期和时间会略有不同 日期/时间组件方法P102，有一大把，按需查阅 日期格式化方法 方法 作用 toDateString() 以特定实现的格式显示星期几、月、日和年 toTimeString() 以特定于实现的格式显示时、分、秒和时区 toLocaleDateString() 以特定于地区的格式显示星期几、月、日和年 toLocaleTimeString() 以特定于实现的格式显示时、分、秒 toUTCString() 以特定于实现的格式完整的UTC日期 RegExp类型 var expression = / pattern / flags ; 其中，模式（pattern）部分可以是任何简单或者复杂的正则表达式 正则表达式的匹配模式支持3个标志（flags） 标志 说明 g 表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i 表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 ES3中，正则表达式字面量始终会共享一个RegExp实例，ES5明确规定，始终正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例 RegExp实例属性 属性 说明 global 布尔值，表示是否设置了g标志 ignoreCase 布尔值，表示是否设置了i标志 lastIndex 整数，表示开始搜索下一个匹配项的字符位置，从0算起 multiline 布尔值，表示是否设置了m标志 source 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法，该对象的主要方法是exec()，该方法是专门为捕获组而设计的，该方法接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者返回null，返回的数组包含两个额外的属性：index和input，前者表示匹配项在字符串中的位置，后者表示应用正则表达式的字符串，该方法即使使用g也只会返回一个匹配项，但是再次调用会继续往下匹配 test()方法，接受一个字符串参数，匹配的话返回true，否则是false 模式的局限性，高级正则表达式特性部分不支持 RegExp构造函数属性，具有一个长属性名和一个短属性名，opera不支持短属性名，貌似现在高版本都支持了吧，一般短属性不是有效的ES标识符，所以需要用方括号法调用 长属性名 短属性名 说明 input &#36;&#95; 最近一次要匹配的字符串 lastMatch &#36;&#38; 最近一次的匹配项 lastParen &#36;&#43; 最近一次匹配的捕获组 leftContext &#36;&#96; input字符串中lastMatch之前的文本 multiline &#36;&#42; 布尔值，表示是否所有表达式都是用多行模式 rightContext &#36;&#39; Input字符串中lastMatch之后的文本 Function类型 函数实际上是对象，每个函数都是Function类型的实例，所以函数名实际上也是一个指向函数对象的指针 没有重载（深入理解），因为函数名只是指针罢了 函数声明与函数表达式，函数声明会被提升到代码树顶部，并添加入执行环境中，但是等价的函数表达式不会，所以在执行语句放在函数表达式前的话会报错，除此之外没有区别 作为值的函数 函数内部属性，有两个特殊属性，arguments和this，前者主要用途是保存函数参数，是一个类数组对象，它还拥有一个属性，叫做callee，是一个指针，指向拥有该arguments对象的函数，可以消除类似递归函数中与函数名紧密耦合的现象，arguments.callee(num-1) this引用的是函数执行的环境对象 ES5规范了另一个函数对象的属性caller，该属性保存着调用当前函数的函数的引用 1234567function outer()&#123; inner(); &#125;function inner()&#123; alert(arguments.callee.caller)&#125;outer(); //弹出outer()的源代码 在严格模式下arguments.callee以及arguments.caller都会报错，而非严格模式下后者始终为undefined 函数属性和方法，每个函数都包含两个属性，length和prototype，其中前者表示函数希望接受的命名参数的个数，prototype属性是保存引用类型所有实例方法的真正所在，它是不可枚举的 每个函数都包含两个非继承而来的方法：apply()和call()，这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值，前者接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组（可以是Array的实例，也可以是arguments对象），后者的第一个参数是this没有变化，变化的是其余参数都直接传递给函数，也就是传递的参数必须逐个列举出来 事实上，传参并不是apply()和call()真正的用武之地，他们可以扩充函数赖以运行的作用域，sayColor.call(o); //blue ES5还定义了一个方法，bind()，该方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值 基本包装类型 为了便于操作基本类型，ES提供了3个特殊的引用类型，Boolean、Number和String，引用类型与基本包装类型的主要区别在于对象的生存期，自动创建的基本类型对象只存在于一行代码的执行瞬间，然后即被销毁，要注意通过new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的（建议永远不要使用Boolean对象） toFixed()方法会按照指定的小数位返回数值的字符串表示，alert(num.toFixed(2)); //&quot;10.00&quot; toExponential()，该方法返回以指数表示法表示的数值的字符串形式 toPrecision()方法会返回最合适的的格式 字符方法，字符串操作方法，字符串位置方法，字符串大小写转换方法，字符串的模式匹配方法， 方法 说明 charAt() 以单字符字符串的形式返回给定位置的那个字符（位置从0开始） charCodeAt() 同上，但返回的是字符编码 concat() 用于将一或多个字符串拼接起来，返回拼接得到的新字符串（还是加号操作符常用） slice() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定结束位置，输入的负值会与长度相加 substring() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定结束位置，将负值转为0 substr() 接受一或二个参数，返回一个字符串，第一个参数指定开始位置，第二个参数指定返回字符个数，第一个负值与长度相加，第二个负值转为0 indexOf() 从字符串开头向后搜索子字符串的位置，没找到返回-1，接受可选的第二个参数表示从哪个位置开始 lastIndexOf() 从字符串末尾向后搜索子字符串的位置，没找到返回-1，接受可选的第二个参数表示从哪个位置开始 trim() 该方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果 toLowerCase() toLocaleLowerCase() 转换为小写 toUpperCase() toLocaleUpperCase() 转换为大写 match() 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，只接受一个参数，正则表达式或者RegExp对象 search() 返回字符串中第一个匹配项的索引 replace() 替换子字符串，该方法接受两个参数，第一个参数可以是个RegExp对象或者一个字符串（不会被转化为正则表达式），第二个参数可以是一个字符串或者函数（在下面又列了一个表，表示字符串可用的一些特殊字符序列） split() 接受两个参数，第一个参数可以是字符串也可以是RegExp对象，是指定的分隔符，第二个可选的参数，用于指定数组的大小，返回一个数组 localeCompare() 一个字符串，字符串参数在字母表排前面返回1，相等返回0，之后返回-1 fromCharCode() 一个或多个字符编码，然后转化成对应的字符或字符串 特殊字符序列 字符序列 替换文本 &#36;&#36; &#36; &#36;&#38; 匹配整个模式的子字符串。与RegExp.lastMatch的值相同 &#36;&#39; 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同 &#36;&#96; 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同 &#36;n 匹配第n个捕获组的子字符串，其中n等于0~9 &#36;nn 同上，nn等于01~99 单体内置对象 内置对象，开发人员不必显示地实例化内置对象，因为它们已经实例化了，例如Object、Array、String 单体内置对象，Global和Math Global对象，兜底对象，不属于任何其他对象的属性和方法，最终都是它的属性和方法，事实上，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性 URL编码方法encodeURI()和encodeURIComponent()方法可以对URI进行编码，以便于发送给浏览器，有效的URI中不能包含某些字符，例如空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解；前者作用与整个URI，后者作用于URI中的一段进行编码；对应解码方式为decodeURI()和decodeURIComponent() eval()方法eval()就像一个完整的ECMASCript解析器，它只接受一个参数，即要执行的ECMAScript字符串，eval()中创建的任何变量或函数都不会被提升，严格模式下报错，而且可能会被代码注入，请谨慎使用 Global对象的属性undefined、NaN、Infinity、Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError window对象ECMASript没有指出如何访问Global()对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性 单体内置对象 Math()对象 Math对象的属性Math对象包含的属性大都是数学计算中可能会用到的一些特殊值，属性表 min()和max()方法var max = Math.max(3,54,32,16) //54var values = [1,2,3,4,5,6,7,8];var max = Math.max.apply(Math, values) //Math作为apply()的第一个参数，从而正确的设置this值，然后将任何数组作为第二个参数 舍入方法Math.ceil()上舍，Math.floor()下舍，Math.round()四舍五入 random()方法返回一个大于0小于1的随机数例如：值 = Math.floor(Math.random()*可能值的总数+第一个可能的值) 其他方法，方法表 属性 说明 Math.E 自然对数的底数，即常量e的值 Math.LN10 10的自然对数 Math.LN2 2的自然对数 Math.LOG2E 以2为底e的对数 Math.LOG10E 以10为底e的对数 Math.PI &pi;的值 Math.SQRT1_2 1/2的平方根（即2的平方根的倒数） Math.SQRT2 2的平方根 方法 说明 方法 说明 Math.abs(num) 返回num的绝对值 Math.asin(x) 返回x的反正弦值 Math.exp(num) 返回Math.E的num次幂 Math.atan(x) 返回x的反正切值 Math.log(num) 返回num的自然对数 Math.atan2(y,x) 返回y/x的反正切值 Math.pow(num,power) 返回num的power次幂 Math.cos(x) 返回x的余弦值 Math.sqrt(num) 返回num的平方根 Math.sin(x) 返回x的正弦值 Math.acos(x) 返回x的反余弦值 Math.tan(x) 返回x的正弦值","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"JavaScript DOM 编程艺术 阅读笔记","slug":"JavaScript-DOM-编程艺术-阅读笔记","date":"2018-01-07T08:03:38.000Z","updated":"2018-01-23T14:28:19.521Z","comments":true,"path":"2018/01/07/JavaScript-DOM-编程艺术-阅读笔记/","link":"","permalink":"http://chinti.xyz/2018/01/07/JavaScript-DOM-编程艺术-阅读笔记/","excerpt":"前言&#160; &#160; &#160;&#160;开始正式起步JavaScript的学习了，根据知乎的建议买了两本书《JavaScript DOM编程艺术》以及《JavaScript高级程序设计》，我打算先从编程艺术入手，全书将会围绕着一个具体的网页效果展开，使读者对JavaScript有个整体的了解。","text":"前言&#160; &#160; &#160;&#160;开始正式起步JavaScript的学习了，根据知乎的建议买了两本书《JavaScript DOM编程艺术》以及《JavaScript高级程序设计》，我打算先从编程艺术入手，全书将会围绕着一个具体的网页效果展开，使读者对JavaScript有个整体的了解。 第一章：JavaScript简史&#160; &#160; &#160;&#160;正如其名，本章主要介绍了JavaScript的起源，还有浏览器战争和DOM演变史。 JavaScript的起源，它是由Netscape公司与Sun公司合作开发的。在它出现之后，网页的可交互性得到了显著改善。JavaScript是一种脚本语言。 DOM是一套对文档的内容进行抽象和概念化的方法。 浏览器战争 DHTML，是Dynamic HTML(动态HTML)的缩写，它不是一个新技术，而是描述HTML、CSS和JavaScript技术组合的术语，其含义为 利用HTML把网页标记为各种元素 利用CSS设置元素样式和它们的显示位置 利用JavaScript实时的操控页面和改变样式 浏览器之间的冲突，Netscape公司的DOM和微软公司的DOM采用了不一样的方式，导致脚本不得不编写两次，并且为了确保正确向浏览器提供脚本，程序员必须写一些代码去探查在客户端运行的浏览器是哪一种 制定标准，W3C结合大家的优点推出了一个标准化的DOM 浏览器以外的考虑，DOM是一种API（应用编程接口），它可以使人们更方便的交流与合作 浏览器战争的结局，微软战胜了Netscape只是因为IE随系统附带而已 崭新的起点，现今几乎所有的浏览器都内置了对DOM的支持，只要遵循最新的DOM标准，就可以大胆去做 第二章：JavaScript语法&#160; &#160; &#160;&#160;本章主要是介绍JS语法，其实大多数与其他语言差不多，稍微记一些差别就行 准备工作，只需要文本编辑器（嗯 继续用记事本）和一个浏览器，可以通过两种方式执行JS代码 第一种方式是将JS代码放入head标签中的script标签之间 第二种方式是将代码存在一个扩展名为.js的独立文件，典型方式为在head放一个script并将它的src指向该文件，例如：&lt;script src = &quot;file.js&quot;&gt;&lt;/script&gt;,但是更好的方式是将script放在HTML文档末尾，&lt;/body&gt;之前，可以使浏览器更快的加载页面 本章给了一个text.html其中&lt;html lang = &quot;en&quot;&gt;用于向搜索引擎表示该页面为html语言，且语言为英语，lang代表language，若想改成中文，可使用zh-CN 语法，语句，注释（//,/*...*/,&lt;!--）推荐使用前两个 变量（variable）与赋值（assignment），JS允许程序员直接对变量赋值无需事先声明，但是提前声明是一种良好的编程习惯,在JS中是区分大小写的，变量名中不允许包含空格或标点符号（美元符号$除外），同时第一位不允许是数字 1var mood = &quot;happy&quot;,age = 33; 为了使变量易于阅读，可以在变量名中的适当位置插入下划线，例如var my_mood = &quot;happy&quot;;另一种方式称为驼峰式（camel case）,删除下划线，后面的新单词改用大写字母开头，例如var myMood = &quot;happy&quot;;,其中happy被称为字面量（literal），我想用何种命名方式主要还是靠实际工作中的团队约定吧 数据类型，JS是一种弱类型（weakly typed）语言，所以不需要进行类型声明（typing），所以程序员可随时改变变量的数据类型 字符串，需要用单引号或者双引号包裹住，但是若字符串中包含所用引号，则需要在此之前加一个”\\”进行转义（escaping） 12var height = &quot;about 5&apos;10\\&quot; tall&quot;;alert(height); 数值，布尔值 1234var age = 33.5;var temperature = -20.33333;var sleeping = true; 数组，之前三个都是标量（scalar），而存储一组值则需要数组（array） 123456var beatles = Array(4);var beatles = Array();//不知道元素个数时也能用array[index] = element; //填充（populating）var beatles = Array(&quot;John&quot;,&quot;Paul&quot;,&quot;George&quot;,&quot;Ringo&quot;);var beatles = [&quot;John&quot;,&quot;Paul&quot;,&quot;George&quot;,&quot;Ringo&quot;]//略随便 关联数组，可以使用明确下标，例如字符串,但这种方式不推荐1234var lennon = Array();lennon[&quot;name&quot;] = &quot;John&quot;;lennon[&quot;year&quot;] = 1940;lennon[&quot;living&quot;] = false; 对象(Object)，与数组类似 包含在对象中的数据可以通过两种形式访问，属性（property）和方法（method），为了使对象描述特定的人，需要通过new创建实例 内建对象，比如Array，和它的length属性，还有类似Math对象和Date对象 宿主对象，由浏览器提供的预定义对象被称为宿主对象（host object）12345678var lennon = Object();lennon.name = &quot;John&quot;;lennon.year = 1940;lennon.living = false;var lennon = &#123;name:&quot;John&quot;, year:1940; living:false &#125;; //花括号法Person.mood; Person.walk();var jeremy = new Person; 操作（operation），进行计算和处理数据，和其他的语言差不多，除了要记住字符串与数值拼接在一起会自动转化为字符串，以及记住JS是弱类型语言 条件语句（if…else）,比较操作符（==, &gt;=, &lt;=, &gt;, &lt;, !=, ===, !==）,全等和严格不相等是在比较某些类似false 与””的情况下 逻辑操作符（&amp;&amp;, ||, !）,为了避免歧义”!”后面最好跟（） 循环语句（if, while, do…while, for） 函数，若多次使用同一段代码可以将他们封装为一个函数，通过function定义一个函数的语法（参数argument），且JS拥有许多内建函数，例如alert 书中作者推荐利用下划线命名变量，驼峰法命名函数 变量的作用域，即全局变量和局部变量，在函数内定义变量避免二义性 第三章：DOM 文档：DOM中的”D” 对象：DOM中的”O”,分为三种类型 用户定义对象（user-defined object）：由程序员自行创建的对象 内建对象（naive object）：内建在JS中的对象 宿主对象（host object）：由浏览器提供的对象在JS最初的版本，提供了window对象，通称为BOM（浏览器对象模型），它提供了window.open和window.blur等方法，这些方法实现了到处被滥用的各种弹出窗口和下拉菜单 模型：DOM中的”M”,它代表着”Model”模型，DOM将一份文档表示为一棵树，称为节点树 节点（node） 元素节点 文本节点 属性节点 CSS （class属性 和 id属性） 获取元素，3种DOM方法可以获取元素节点，分别是通过元素ID、通过标签名字和通过类名字 getElementById，文档中每个元素都是一个对象 12345document.getElementById(id)//下面是个例子document.getElementByID(&quot;purchases&quot;)//你可以用typeof操作符验证返回的操作数alert(typeof document.getElementById(&quot;purchases&quot;)); getElementsByTagName，返回一个对象数组，通配符”*” 1234567891011121314 element.getElementsByTagName(tag) //下面是个例子 document.getElementsByTagName(&quot;li&quot;) //再例 alert(document.getElementsByTagName(&quot;li&quot;).length); //再再例 for (var i=0; i&lt;document.getElementsByTagName(&quot;li&quot;).length;i++)&#123; alert(typeof document.getElementsByTagName(&quot;li&quot;)[i])；&#125; //再再再例 var items = document.getElementsByTagName(&quot;li&quot;); for (var i=0; i&lt;items.length;i++)&#123; alert(typeof items[i])； &#125; getElementsByClassName，可以通过类名寻找元素，指定多个类，只需要在两者间加上空格 123getElementByClassName(class)//例alert(document.getElementsByClassName(&quot;important sale&quot;).length); [注]书中P42这里有一段函数用于匹配新老浏览器，现在已无用，但向后兼容性的思想应当记住 获取和设置属性 getAttribute，用于查询属性object.getAttribute(attribute),它不属于document对象，它只能通过元素节点对象调用 setAttribute，允许我们对属性节点值做出修改object.setAttribute(attribute,value)，同样只能用于元素节点 第四章：案例研究：JavaScript图片库&#160; &#160; &#160;&#160;本章将会被带着使用JS和DOM去建立一个图片库，首先编写一个优秀的标记文件，其次编写一个JS函数用以显示用户想要查看的图片，然后利用标记触发函数调用 标记 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;utf-8&quot;&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = &quot;images/fireworks.jpg&quot; title = &quot;A fireworks display&quot;&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/coffee.jpg&quot; title = &quot;A cup of black coffee&quot;&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/rose.jpg&quot; title = &quot;A red,red rose&quot;&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = &quot;images/bigben.jpg&quot; title = &quot;The famous clock&quot;&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = &quot;placeholder&quot; src = &quot;images/placeholder.gif&quot; alt = &quot;my image gallery&quot;&gt;//占位 &lt;script type = &quot;text/javascript&quot; src = &quot;showPic.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 12345678 //DOM方法如下 function showPic(whichpic)&#123; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = whichpic.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,source);&#125; //非DOM方法如下,推荐使用DOM方法 placeholder.src = source; 应用这个JavaScript函数，添加事件处理函数（event handler）,这里需要注意的是，当你JS打错了会不执行然后页面正常跳转，我傻乎乎的找了半天html哪里写错了。。。 1&lt;a href = &quot;images/fireworks.jpg&quot; title = &quot;A fireworks display&quot; onclick = &quot;showPic(this); return false;&quot;&gt;Fireworks&lt;/a&gt; //在每个链接中加入onclick 对这个函数进行扩展 childNodes属性，可以用来获取任何一个元素的所有子元素，使用：element.childNodes,按书中要求我获得了9，是因为空格和换行符也会被解释为节点 nodeType属性，这个属性可以告诉我们节点是哪一种节点，它一共拥有12种值，但其中只有三个有实用价值，元素节点为1，属性节点为2，文本节点为3 nodeValue属性，用于得到和设置一个节点的值：node.nodeValue,这里要注意p元素本身的属性是个空值，你要找它的子节点，例如alert(description.childNodes[0].nodeValue); firstchild和lastchild属性 加上CSS样式 第五章：最佳实践&#160; &#160; &#160;&#160;本章将介绍一些最佳实践，同时向读者介绍了四种思想：平稳退化，分离JavaScript，向后兼容性，性能考虑 过去的错误，很多书中介绍的遗留问题在如今已经得到了解决 不要怪罪JavaScript Flash的遭遇 质疑一切，利用JS改变网页行为，必须三思而后行，确认是否必要 平稳退化，若JS不被浏览器支持，虽然某些功能无法使用，但基本操作仍能顺利完成（现今基本不用担心支持问题） window.open(url,name,features)，第三个参数是利用逗号分割的字符串，用于设定属性，例如尺寸显示位置等 “javascript:”伪协议，用于通过一个链接调用JavaScript函数，例如：&lt;a href = &quot;javascript:popUp(&#39;http://www.example.com/&#39;);&quot;&gt;Example&lt;/a&gt;，在html文档中通过伪协议调用JS代码并不好 内嵌的事件处理函数，类似onclick，&lt;a href = &quot;#&quot; onclick = &quot;popUp(&#39;http://www.example.com&#39;); return false;&quot;&gt;Example&lt;/a&gt;，若用户禁用JS这条链接将毫无作用 谁关心这个，除了禁用JS的浏览器的用户以外，你可以想象用户是搜索机器人，只有极少数搜索机器人可以理解JS代码，若你的网页无法平稳退化，它在搜索引擎上的排名会受到损害12345&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(&apos;http://www.example.com&apos;); return false;&quot;&gt;Example&lt;/a&gt;//精简下&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(this.getAttribute(&apos;href&apos;)); return false;&quot;&gt;Example&lt;/a&gt;//利用DOM提供的的this.href&lt;a href = &quot;http://www.example.com/&quot; onclick = &quot;popUp(this.href); return false;&quot;&gt;Example&lt;/a&gt; 向CSS学习 结构与样式的分离 渐进增强，“标记良好的内容就是一切” 分离JavaScript，利用id或class作为挂钩&lt;a href = &quot;http://www.example.com/&quot; class = &quot;popup&quot;&gt;Example&lt;/a&gt;，在外部JS文件中完成事件动作element.event = action...，具体步骤： 把文档里的所有链接放入一个数组 遍历数组 若果某个链接的class属性等于popup，就表示这个链接被点击时应该调用popUp()函数 于是，把这个连接的href传给popUp()函数，取消这个链接的默认行为12345678910111213window.load = prepareLinks; //必须function prepareLinks() &#123; var links = document.getElementsByTagName(&quot;a&quot;); for(var i=0; i&lt;links.length; i++)&#123; if(links[i].getAttribute(&quot;class&quot;) == &quot;popup&quot;)&#123; popUp(this.getAttribute(&quot;href&quot;)); return false; &#125; &#125;&#125;function popUp(winURL) &#123; window.open(winURL,&quot;popup&quot;,&quot;width=320,height=480&quot;);&#125; 向后兼容 对象检测，if(method){statements}，但是可读性较差，可以采用逻辑非的方式，if(!method) return false; 浏览器嗅探技术（browser sniffung），这个风险很大，因为浏览器有时会说谎，将自己报告成另外一种浏览器（我想到edge报告自己是chrome） 性能考虑 尽量少访问DOM和尽量减少标记，只要查询某些元素就要遍历整个DOM树，最好的方法就是将第一次结果保存在一个变量中 合并和放置脚本 压缩脚本，代码压缩工具：Douglas Crockford的JSMin、雅虎的YUI Compressor、谷歌的Closure Compiler 第六章：案例研究：图片库改进版&#160; &#160;&#160;&#160;本章是将上一章内容运用进之前所做的图片库 快速回顾，确认它能否支持平稳退化 JS是否分离 结构化程序设计备忘，通常认为函数只有一个出口和入口，但是过分拘泥这点会使代码难以阅读 添加事件处理函数 检查点，检查浏览器是否支持函数 变量名里有什么，用一些有意义的单词命名一长串代码，使代码更加易读和理解 遍历 改变行为 完成JavaScript函数 共享onload事件，将函数与onclick事件绑定，可以采用一个弹性的解决方案addLoadEvent123456789101112function addLoadEvent(func) &#123; var oldonload = window.onload; if(typeof window.onload != &apos;function&apos;) &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 不要做太多假设，在实际工作中，检查需要根据具体情况来做出 键盘访问，onkeypress，但是最好不要用它，且onclick的支持已经够完美 prepareGallery和showPic代码段 12345678910111213141516171819202122232425262728function showPic(whichpic) &#123; if (!document.getElementById(&quot;placeholder&quot;)) return false; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = document.getElementById(&quot;placeholder&quot;); if (placeholder.nodeName != &quot;IMG&quot;) return false; placeholder.setAttribute(&quot;src&quot;,source); if (document.getElementById(&quot;description&quot;)) &#123; var text = whichpic.getAttribute(&quot;title&quot;) ? whichpic.getAttribute(&quot;title&quot;):&quot;&quot;; var description = document.getElementById(&quot;description&quot;); if (description.firstChild.nodeType == 3)&#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125;function prepareGallery() &#123; if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; if (!document.getElementById(&quot;imagegallery&quot;)) return false; var gallery = document.getElementById(&quot;imagegallery&quot;); var links = gallery.getElementsByTagName(&quot;a&quot;); for(var i=0; i &lt; links.length; i++) &#123; links[i].onclick = function() &#123; return showPic(this)? false:true; &#125; &#125;&#125; 把JavaScript与CSS结合起来 DOM Core和HTML-DOM 第七章：动态创建标记&#160; &#160; &#160;&#160;本章主要是介绍一些传统方法和DOM方法 一些传统方法 document.write，最大的缺点是它违背了“行为应该与表现分离”的原则 innerHTML，用它读取内容毫无细节可言，会将标记和字符串一起读出，但是可以用来在js中把一段HTML内容完全替换进这个标签，无法做到插入，在XHTML中可能会忽略这个属性 DOM方法 createElement方法，使用：document.createElement(nodeName)，用于创建元素节点，创建后，它成为了一个文档碎片（document fragment），但它已经具有了一个nodeType和一个nodeName值 appendChild方法，使用：parent.appendChild(child)，用于插入某文档的节点树 createTextNode方法，使用：document.createTextNode(text)，用于创建一个文本节点 一个更复杂的组合12345678910111213 window.onload = function() &#123; var para = document.createElement(&quot;p&quot;); var txt1 = document.createTextNode(&quot;This is &quot;); para.appendChild(txt1); var emphasis = document.createElement(&quot;em&quot;); var txt2 = document.createTextNode(&quot;my&quot;); emphasis.appendChild(txt2); para.appendChild(emphasis); var txt3 = document.createTextNode(&quot; content. &quot;); para.appendChild(txt3); var testdiv = document.getElementById(&quot;testdiv&quot;); testdiv.appendChild(para);&#125; 重回图片库 insetBefore()在已有元素前插入一个新元素，使用：parentElement.insertBefore(newElement,targetElement)，例如：var gallery = document.getElementById(&quot;imagegallery&quot;); gallery.parentNode.insertBefore(placeholder,gallery) 在已有元素后插入一个新元素，并没有现成的函数，但是可以自己写，具体原理：若此元素为父元素最后一个孩子，使用appendChild，若不是，则利用insertBefore插入这个元素的下一个兄弟元素之前12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; Ajax，这个词用于概括异步加载页面内容的技术 XMLHttpRequest对象，它是Ajax技术的核心，充当浏览器中的脚本与服务器之间的中间人的角色，以往请求都是由浏览器发出，而现在JS也可以通过这个对象自己发送请求和处理响应，书中给了一个ajax例子，这里需要注意，Chrome本地服务器上并不能处理异步，换成火狐浏览器即可解决这个问题 渐进增强与Ajax Hijax 第八章：充实文档的内容&#160; &#160; &#160;&#160;本章将继续实践上一章学到的内容 不应该做什么，不要把重要内容通过DOM技术添加到网页上 把“不可见”变成“可见”，可以利用DOM技术得到隐藏在属性里的信息，创建标记封装这些信息，把这些标记插入到文档 显示“缩略语列表”,并编写displayAbbreviations函数 for (variable in array)可以用于遍历关联数组 过去版本的ie可能无法正常支持abbr，所以需要通过一些判断条件，在不支持时不执行这些js代码，即使某种浏览器会引起问题，但还是尽量不要用嗅探代码 12345678910111213141516171819202122232425262728293031323334353637383940414243 function displayAbbreviations() &#123; if(!document.getElementsByTagName) return false; if(!document.createElement) return false; if(!document.createTextNode) return false; // 取得所有缩略词 var abbreviations = document.getElementsByTagName(&quot;abbr&quot;); if (abbreviations.length &lt; 1) return false; var defs = new Array(); //遍历 for (var i=0; i&lt;abbreviations.length; i++) &#123; if (abbreviations[i].childNodes.length &lt; 1) continue; var definition = abbreviations[i].getAttribute(&quot;title&quot;); var key = abbreviations[i].lastChild.nodeValue; defs[key] = definition; &#125; //创建定义列表 var dlist = document.createElement(&quot;dl&quot;); //遍历定义 for (key in defs) &#123; var definition = defs[key]; //创建定义标题 var dtitle = document.createElement(&quot;dt&quot;); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); //创建定义描述 var ddesc = document.createElement(&quot;dd&quot;); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); //把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; if (dlist.childNodes.length &lt; 1) return false; //创建标题 var header = document.createElement(&quot;h2&quot;); var header_text =document.createTextNode(&quot;Abbreviations&quot;); header.appendChild(header_text); //把标题添加到页面主体 document.body.appendChild(header); //把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 显示“文献来源链接表”，cite属性可以标识blockquote内容引自哪里，但是浏览器一般会完全忽略这个属性，在返回子节点时不要想当然，某些浏览器会将换行符也会解释为一个文本节点 1234567891011121314151617181920212223242526272829 function displayCitations() &#123; if (!document.getElementsByTagName) return false; if (!document.createElement) return false; if (!document.createTextNode) return false; //取得所有引用 var quotes = document.getElementsByTagName(&quot;blockquote&quot;); //遍历引用 for (var i=0; i&lt;quotes.length; i++)&#123; //如果没有cite属性，继续循环 if (!quotes[i].getAttribute(&quot;cite&quot;)) continue; //保存cite属性 var url = quotes[i].getAttribute(&quot;cite&quot;); //取得引用中所有元素节点 var quoteChildren = quotes[i].getElementsByTagName(&quot;*&quot;); //如果没有元素节点，继续循环 if (quoteChildren.length &lt; 1) continue; //取得引用中的最后一个元素节点 var elem = quoteChildren[quoteChildren.length - 1]; //创建标记 var link = document.createElement(&quot;a&quot;); var link_text = document.createTextNode(&quot;source&quot;); link.appendChild(link_text); link.setAttribute(&quot;href&quot;,url); var superscript = document.createElement(&quot;sup&quot;); superscript.appendChild(link); //把标记添加到引用中的最后一个元素节点 elem.appendChild(superscript); &#125;&#125; 显示“快捷键菜单”，accesskey属性可以把一个元素（如链接）与键盘上某个特定的按钮关联在一起，一般来说，Windows系统中，同时按下alt和特定按钮，在Mac中，是按下Ctrl，例Home，不要设置太多快捷键，会与浏览器内置快捷键冲突，常用方法 123456789101112131415161718192021222324252627282930313233343536373839404142function displayAccessKeys() &#123; if(!document.getElementsByTagName) return false; if(!document.createElement) return false; if(!document.createTextNode) return false; //取得文档中所有链接 var links = document.getElementsByTagName(&quot;a&quot;); //创建一个数组 var akeys = new Array(); //便利链接 for(var i=0; i&lt;links.length; i++) &#123; var current_link = links[i]; //若没有accesskey继续循环 if(!current_link.getAttribute(&quot;accesskey&quot;)) continue; //取得accesskey的值 var key = current_link.getAttribute(&quot;accesskey&quot;); //取得链接文本 var text = current_link.lastChild.nodeValue; //存入数组 akeys[key] = text; &#125; //创建列表 var list = document.createElement(&quot;ul&quot;); //遍历访问键 for(key in akeys) &#123; var text = akeys[key]; //创建放到列表项中的字符串 var str = key + &quot;:&quot; + text; //创建列表项 var item = document.createElement(&quot;li&quot;); var item_text = document.createTextNode(str); item.appendChild(item_text); //将列表项添加入列表 list.appendChild(item); &#125; //创建标题 var header = document.createElement(&quot;h3&quot;); var header_text = document.createTextNode(&quot;Accesskeys&quot;); header.appendChild(header_text); //把标题添加到页面主体 document.body.appendChild(header); document.body.appendChild(list);&#125; 第九章：CSS-DOM&#160; &#160; &#160;&#160;本章介绍如何利用DOM技术获取和设置CSS信息 三位一体的网页，结构层、表示层、行为层 style属性，element.style.property，它也是一个对象 在调用诸如font-family这样的属性时，会将中间的连字符解释为减法操作符，需要将他变为驼峰命名法fontFamily，在火狐浏览器中，返回颜色值是以RGB（红，绿，蓝） style属性只能返回内嵌样式，所以几乎没有实用价值。。，但是可以用于设置样式 何时需要设置样式 根据元素在节点树里的位置来设置样式，nextSibling 根据某种条件反复设置某种样式，书中给了一个让表格反复变色的例子，这不是一个很好的做法在现在尽量用CSS完成，例如：tr:nth-child(odd) { background-color: #ffc} 响应事件，CSS提供了:hover等伪class属性，DOM也可以通过onmouseover等事件对HTML元素的状态变化作出响应,同样尽可能利用CSS完成 ClassName属性，之前让DOM直接设置或修改样式，这种做法让“行为层”干了“表示层”的活，不如用JS代码更新这个元素的类名element.className = value;，elem.setAttribute(&quot;class&quot;,&quot;intro&quot;);的方式也可以，用下面这个函数可以添加类 12345678910function addClass(element,value) &#123; if(!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName += &quot; &quot;; newClassName += value; element.className = newClassName; &#125;&#125; 同时，可以对复杂的函数更进一步的抽象，以便通用 1234567891011121314151617181920212223242526272829303132 function getNextElement(node) &#123; if(node.nodeType == 1) &#123; return node; &#125; if (node.nextSibling) &#123; return getNextElement(node.nextSibling); &#125; return null;&#125;function styleHeaderSiblings(tag,theclass) &#123; if (!document.getElementsByTagName) return false; var headers = document.getElementsByTagName(tag); var elem; for (var i=0; i&lt;headers.length; i++) &#123; elem = getNextElement(headers[i].nextSibling); addClass(elem,theclass); &#125;&#125;function addClass(element,value) &#123; if(!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName += &quot; &quot;; newClassName += value; element.className = newClassName; &#125;&#125;addLoadEvent(function()&#123;styleHeaderSiblings(&quot;h1&quot;,&quot;intro&quot;);&#125;); 第十章：用JavaScript实现动画效果&#160; &#160; &#160;&#160;本章介绍了一些简单动画效果 动画基础知识 位置，static fixed relative absolute 时间，setTimeout(&quot;function&quot;,interval)，第二个是以毫秒为单位设定时间，variable = setTimeout(&quot;function&quot;,interval)，然后clearTimeout(variable)，可以用来取消“等待执行”队列中的某个函数，例：movement = setTimeout(&quot;moveMessage()&quot;,5000) 时间递增量，parseInt(string)和parseFloat(string)可以用于提取字符串中的数字 抽象，这里遇到一个var repeat = &quot;moveElement(&#39;&quot;+elementID+&quot;&#39;,&quot;+final_x+&quot;,&quot;+interval+&quot;)&quot;;，这句话一下子略难理解，实际上是repeat存入了一个字符串，然后其中所有的加号即为“和”，利用参数变量代替硬编码常数，你将可以随意重用它 实用的动画，尽量避免内容在页面中移动 提出问题，类似图片库那章，但是这次不是使用onclick事件，而是采用onmouseover事件，显示预览图片切换显示时多少会有点延时，若采用集体照的方式可以避免 overflow，CSS中的这个属性可以用于处理一个元素的尺寸超过容器尺寸的情况，可以用它进行裁剪，它具有四个属性值visible不裁剪，溢出显示，hidden，隐藏，scroll隐藏，但是给一个滚动条，auto，与前一个类似，但是只有在确实溢出时才给滚动条，其中position: relative很重要，可以将子元素的坐标固定在lideshow左上角 变量作用域问题，全局变量会造成冲突，JS允许我们为元素创建属性，element.property = value，而移动元素太慢了，在调节步进时，遇上我们无法把一个元素移动不到一像素的距离，Math.ceil(number)可以返回一个向上取整得数floor向下取整，round四舍五入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 function prepareSlideshow() &#123; if (!document.getElementById(&quot;linklist&quot;)) return false; var slideshow = document.createElement(&quot;div&quot;); slideshow.setAttribute(&quot;id&quot;,&quot;slideshow&quot;); var preview = document.createElement(&quot;img&quot;); preview.setAttribute(&quot;src&quot;,&quot;images/topics.gif&quot;); preview.setAttribute(&quot;alt&quot;,&quot;building blocks of web design&quot;); preview.setAttribute(&quot;id&quot;,&quot;preview&quot;); slideshow.appendChild(preview); var list = document.getElementById(&quot;linklist&quot;); insertAfter(slideshow,list); var links = list.getElementsByTagName(&quot;a&quot;); links[0].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-100,0,10); &#125; links[1].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-200,0,10); &#125; links[2].onmouseover = function() &#123; moveElement(&quot;preview&quot;,-300,0,10); &#125; &#125;function moveElement(elementID,final_x,final_y,interval) &#123; if (!document.getElementById) return false; if (!document.getElementById(elementID)) return false; var elem = document.getElementById(elementID); if (elem.movement) &#123; clearTimeout(elem.movement); &#125; if(!elem.style.left||!elem.style.top) &#123; elem.style.left = &quot;0px&quot;; elem.style.top = &quot;0px&quot;; &#125; var xpos = parseInt(elem.style.left); var ypos = parseInt(elem.style.top); var dist = 0; if(xpos == final_x &amp;&amp; ypos == final_y) &#123; return true; &#125; if (xpos &lt; final_x) &#123; dist = Math.ceil((final_x - xpos)/10); xpos += dist; &#125; if (xpos &gt; final_x) &#123; dist = Math.ceil((xpos - final_x)/10); xpos -= dist; &#125; if (ypos &lt; final_y) &#123; dist = Math.ceil((final_y - ypos)/10); ypos += dist; &#125; if (ypos &gt; final_y) &#123; dist = Math.ceil((ypos - final_y)/10); ypos -= dist; &#125; elem.style.left = xpos + &quot;px&quot;; elem.style.top = ypos + &quot;px&quot;; var repeat = &quot;moveElement(&apos;&quot;+elementID+&quot;&apos;,&quot;+final_x+&quot;,&quot;+final_y+&quot;,&quot;+interval+&quot;)&quot;; elem.movement = setTimeout(repeat,interval);&#125; 第十一章：HTML5&#160; &#160; &#160;&#160;本章介绍了一些HTML5的新特性 Modernizr，它可以用于检测浏览器可能支持的特性，应用它最好放在head元素中 Canvas，画布，它可以动态创建和操作图形图像，使用规范 音频和视频，HTML5的video元素为在文档中嵌入影片以及与影片交互定义了一种标准方式，同时将这种操作简化为一个标签，格式问题在我看的前一本书《HF HTML&amp;CSS》中也有提及 自定义控件 currentTime，返回当前播放的位置，以秒表示 duration，返回媒体的总时长，以秒表示，对于流媒体返回无穷大 paused，表示媒体是否处于暂停状态 play，在媒体播放开始时发生 pause，在媒体暂停时发生 loadeddata，在媒体可以从当前播放位置开始播放时发生 ended，在媒体播放完成而停止时发生 control，这个属性不要忘记添加在video元素中，书中只给了一个写播放暂停按键的例子 表单，在不支持HTML5的浏览器上可以通过DOM实现 第十二章：综合示例&#160; &#160; &#160;&#160;将这本书所学的内容综合起来完成一个网站 原始资料 站点结构，images，styles，scripts，页面Home About Photos Lives Contact CSS，颜色color，布局layout，版式typography，在这个例子里 内边距放在布局中，外边距放在版式中 标记 JavaScript，先建立一个global.js用于保存一些通用函数例如之前所用到的addLoadEvent(func) insertAfter(newElement, targetElement) addClass(element, value) 页面突出显示highlightPage，利用getAttribute(&quot;href&quot;)获取链接的URL，利用window.location.href获取当前页面的url，indexOf可以用来在字符串中寻找子字符串的位置string.indexOf(substring)，返回-1即为失败 toLowerCase该方法可以将文本转换成小写 点击内部链接后，会在连接后包含一串字符串，以#为分隔符，about.html#jay，这里利用split方法可以便捷的将字符串分成多串，array = string.split(character) 1234567891011121314151617181920212223242526272829303132 function showSection(id) &#123; var sections =document.getElementsByTagName(&quot;section&quot;); for (var i=0; i&lt;sections.length; i++) &#123; if (sections[i].getAttribute(&quot;id&quot;) != id) &#123; sections[i].style.display = &quot;none&quot;; &#125; else &#123; sections[i].style.display = &quot;block&quot;; &#125; &#125;&#125;function prepareInternalnav() &#123; if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; var articles = document.getElementsByTagName(&quot;article&quot;); if (articles.length == 0) return false; var navs = articles[0].getElementsByTagName(&quot;nav&quot;); if (navs.length == 0) return false; var nav = navs[0]; var links = nav.getElementsByTagName(&quot;a&quot;); for (var i=0; i&lt;links.length; i++) &#123; var sectionId = links[i].getAttribute(&quot;href&quot;).split(&quot;#&quot;)[1]; if (!document.getElementById(sectionId)) continue; document.getElementById(sectionId).style.display = &quot;none&quot;; links[i].destination = sectionId; links[i].onclick = function() &#123; //一开始一下子没绕过弯，留个档 showSection(this.destination); return false; &#125; &#125;&#125; JavaScript图片库，将第六章第七章部分代码改一下 增强表格，将第九章代码进行改编 增强表单 字段标签，element.focus()单击一个标签可以将焦点转移到关联的表单字段中 占位符值，onfocus事件会在焦点移入表单字段触发，onblur事件则反之，现代浏览器应该不需要再检查占位符值了吧 replace替换，field.value.replace(&#39; &#39;,&#39;&#39;)将空格替换掉 同时，书上代码中有一段element.required == &#39;required&#39;代码，可能不太能用，required现在是一个bool型，在html中只需些&lt;input ... required&gt;即可，在js中的判断应改为element.required == true 提交表单，添加一点Ajax，首先创建一个加载图像，可以到http://ajaxload.info创建一个，并把此图像命名为loading.gif 假设表单中包含消息“Why does 2+2=4?”，然后根据name=value&amp;name2=value2&amp;name3=value3规则形成一个URL编码的表单数据字符串，例如message=Why does 2+2=4?&amp;name=me&amp;email=me@example.com的形式，但是其中诸如+、=、？可能会造成歧义，JS提供了一个函数encodeURIComponent可以用于把有歧义的字符转换成对应的ASCII码：message=Why%20does%202%2B2%3D4%3F%26&amp;name=Me%email=me%40example.com，join函数可以用来将数组中的所有元素通过一个分隔符进行连接并放入一个字符串中，例如dataParts.join(&#39;&amp;&#39;) 正则表达式，在JS中，正则表达式的每个模式都是以一个斜杠（/）开头和结尾，正则表达式部分待之后在看了书上也没具体写 这本书Ajax部分看的有点糊涂，感觉只是初步的了解，我打算看高级程序设计这本书的时候再结合起来好好理解下 压缩js代码，用以改进性能 书后附录中还简短的介绍了jQuery，不过我打算在《锋利的jQuery》中具体学习","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://chinti.xyz/tags/JavaScript/"}]},{"title":"2018素描","slug":"2018素描","date":"2018-01-04T04:56:04.000Z","updated":"2018-01-04T05:45:01.489Z","comments":true,"path":"2018/01/04/2018素描/","link":"","permalink":"http://chinti.xyz/2018/01/04/2018素描/","excerpt":"前言&#160; &#160; &#160;&#160;以前画了许多但是搬家什么的也遗失了，大学也没怎么画过，既然重新开始画了，就好好记录下，其实第一张应该是为所欲为，但画的太丑了，不传了","text":"前言&#160; &#160; &#160;&#160;以前画了许多但是搬家什么的也遗失了，大学也没怎么画过，既然重新开始画了，就好好记录下，其实第一张应该是为所欲为，但画的太丑了，不传了 作品2018-01-02 Taylor Swift","categories":[{"name":"绘画","slug":"绘画","permalink":"http://chinti.xyz/categories/绘画/"}],"tags":[{"name":"sketch","slug":"sketch","permalink":"http://chinti.xyz/tags/sketch/"}]},{"title":"Head First HTML与CSS 阅读笔记（CSS部分）","slug":"Head-First-HTML与CSS-阅读笔记（CSS部分）","date":"2017-12-31T08:54:53.000Z","updated":"2018-01-07T11:32:46.446Z","comments":true,"path":"2017/12/31/Head-First-HTML与CSS-阅读笔记（CSS部分）/","link":"","permalink":"http://chinti.xyz/2017/12/31/Head-First-HTML与CSS-阅读笔记（CSS部分）/","excerpt":"前言&#160; &#160; &#160;&#160;本文是《Head First HTML与CSS》的CSS部分，另一部分为Head First HTML与CSS 阅读笔记（HTML部分）。","text":"前言&#160; &#160; &#160;&#160;本文是《Head First HTML与CSS》的CSS部分，另一部分为Head First HTML与CSS 阅读笔记（HTML部分）。 概念常识 CSS验证工具 css中的每一个语句包括一个场所（如卧室），以及这个场所的一个属性（如窗帘或地毯），还要应用到这个属性的一个样式（如蓝色，或者1英寸的瓷砖），使用：1234p&#123; //需要增加样式的元素 background-color: red; //指定样式属性border: 1px solid gray;&#125; 使用方式 在html文件中指定样式，需要在&lt;head&gt;元素中增加&lt;style&gt;， 12345&lt;style&gt;p&#123; //选择器 p选择器会选择HTML中所有的段落 color: maroo; //color 代表文本颜色 maroon 茶红色&#125;&lt;/style&gt; 外部链接，将规则放在XXX.css中，css文件通常被称为”样式表”stylesheet,然后不再需要style元素，将其删除，然后添加外部链接，例如&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;lounge.css&quot;&gt; link用于链入外部信息，rel属性制定了链接的文件关系，这里是样式表所以是stylesheet 规则合并，共通样式合并起来写，特定样式写在另一个规则里 1234h1，h2&#123; font-family: sans-serif; color: gray;&#125; 可以使用多个样式表，按照顺序通过link元素将样式表链入HTML文件，最下面的样式表最优先 在link元素中添加media属性，可以适用于指定设备的样式文件，使用方式如下 123 &lt;link href=&quot;lounge-mobile.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 480px)&quot;&gt; //创建了一个查询，指定了一个有屏幕的设备，且屏幕宽度不超过480像素&lt;link href=&quot;lounge-print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt; //匹配了打印机 查询中还有很多属性可用，例如min-device-width、max-device-width，以及显示方向[orientation,这可以是横向（landscape）或纵向（portrait）]，此外还有许多其他属性，根据需要添加多个link，涵盖所要支持的全部设备 直接在CSS中增加媒体查询(IE8及以前版本不支持媒体查询)，例： 123456789101112131415161718@media screen and (min-device-width: 481px) &#123; #guarantee &#123; margin-right: 250px; &#125;&#125;@media screen and (max-device-width:480px) &#123; #guarantee &#123; margin-right: 30px; &#125;&#125;@media print &#123; body &#123; font-family: Times, &quot;Times New Roman&quot;, serif; &#125;&#125;p.special &#123; color: red;&#125; 选择器与类 只能为body添加样式 可以用于定义一类元素 首先，为HTML中的元素添加一个class属性，其次，在CSS中选择这个类 类选择器，先选择类中的元素，再用”.”指定一个类 1234567&lt;p class = &quot;greentea&quot;&gt;...&lt;/p&gt; //HTMLp.greentea&#123; color: green;&#125; //CSS id选择器，方法如类选择器，除了不用”.”改用用”#”指定id 子孙选择器，父元素和子孙元素名之间放一个空格，使用： 123#exlixirs h2 &#123; color: black;&#125; 属性选择器，可以根据属性值来选择元素，如： 123img[width] &#123; border: black thin solid; &#125;img[height = &quot;300&quot;] &#123; border: red thin solid; &#125;image[alt~=&quot;flowers&quot;] &#123; border: #ccc thin solid; &#125; 按兄弟选择，可以使用一个”+” 123h1+p &#123; font-style: italic;&#125; 结合选择器 首先定义上下文，代表id为greentea的div必须是blockquote的父元素 然后给出你想选择的元素 然后指定伪类或伪元素：1div#greentea &gt; blockquote 1div#greentea &gt; blockquote p 123div#greentea &gt; blockquote p:first-line &#123; font-style: italic;&#125; 直接孩子，使用#elixir&gt;h2 复杂选择，方式一样，例如#elixir blockquote h2 合并类规则 12345blockquote.greentea,p.greentea&#123; color: green;&#125; //CSS&lt;blockquote class = &quot;greentea&quot;&gt; //HTML 省略所有元素名，只有一个点，即可运用到全部成员 123.greentea&#123; color: green；&#125; 一个元素可以拥有多个类，&lt;p class = &quot;greentea raspberry blueberry&quot;&gt; id属性，与类类似，但是id具有唯一性，一个元素不能有多个id，另外页面上不允许多个元素都有相似的id 12345&lt;p id=&quot;footer&quot;&gt;...&lt;/p&gt;#footer &#123; ...&#125;//p#footer 类名要以一个字母开头，id可以以一个数字或者字母开头，它们都可以包含字母、数字以及_字符，但不能有空格 继承 元素能从他们的父元素继承一部分样式 例如，font-family 继承的样式可以被覆盖 如果样式会影响文本的外观，那么所有的这样子的样式都会被继承，比如：color、font-family、font-size、font-weight、font-style等等 其他的一般都不能被继承，如果不确定可以尝试一下 /* */注释 层叠 浏览器用多个样式表组织样式，最优点的是作者的样式，然后是读者的样式，最后才是浏览器的默认样式 读者如果在某个属性声明的最后加上”!important”，那么他就能覆盖作者的样式 浏览器想知道某个元素的属性，会通过5个步骤 收集所有样式表 找到所匹配的声明 现在对所有匹配的规则排序 现在按特性对所有声明排序 最后，对于冲突的规则，按照它们在各自的样式表中出现的顺序进行排序 求特定性，特定性由一组3个数开始，000 这个选择器包含id吗？每个id加1分 这个选择器包含类或伪类么？每个类或伪类加1分 这个选择器包含元素名吗？一个元素名加1分 然后将他们读作真正的数，其中100&gt;010&gt;001 注意，我们只在作者、读者和浏览器类别范围内排序，并不对整个列表重新排序 属性color 颜色 color 设置文本元素的前景色 background-color 控制元素的背景颜色 常用颜色Aqua Black Blue Fuchsia Gray Green Lime Maroon Navy Olive Purple Red Sliver Teal White YellowCSS只定义了16个基本颜色和大约150个颜色名 按红绿蓝指定颜色，例： 123456body&#123; background-color: rgb(80%, 40%, 0%);&#125;//数字也可以指定为0到255之间的一个数值body&#123; background-color: rgb(204, 102, 0);&#125; 十六进制码，前两位表示红色，中间两位表示绿色，最后两位表示蓝色,且如果每两位数字都相同，那可以缩写成类似#cb0的写法 可以利用诸如PS等应用找到Web颜色，或者使用在线颜色表 font 字体 font-family字体样式 5个字体系列：sans-serif、serif、monospace、cursive、fantasy Serif字体系列，Times、Times New Roman 、Georgia，具有衬线，常见到报纸上的排版 Sans-serif字体系列，Verdana、Arial Black、Trebuchet MS、Arial、Geneva，没有衬线，在计算机屏幕上更容易读 Monospace字体系列，Courier、Courier New、Andale Mono字体包含固定宽度的字符，主要用于软件代码显示 Cursive字体系列，Comic Sans、Apple Chancery，一些看似手写的字体，常在标题里看到 Fantasy字体系列，Last Ninja、Impact，某种风格的装饰性字体 使用CSS指定字体系列，123body&#123; font-family: Verdana, Geneva, Arial, sans-serif;&#125;//浏览器从第一个开始找，没有的话就往后，还没有就使用浏览器默认的sans-serif字体 font-style 用来设置斜体文本，italic oblique斜体和倾斜 font-weight 用来设置粗体，lighter normal bold bolder text-decoration用来增加装饰，none underline overline line-through @font-faceWeb字体 允许你定义一种字体的名字和位置，然后在页面中使用 常用字体格式：TrueType字体：.ttf,OpenType字体：.otf,Embedded Opentype字体：.eot,SVG字体：.svg,Web开放字体格式：.woff 现代浏览器上支持的最为广泛的格式是Web开放字体格式 将字体文件放到web上 使用：12345@font-face &#123; font-family: &quot;Emblema One&quot;; src: url(&quot;http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.woff&quot;), url(&quot;http://wickedlysmart.com/hfhtmlcss/chapter8/journal/EmblemaOne-Regular.ttf&quot;)&#125;//我这边浏览器没啥效果。。不知道是什么问题 字体大小 font-size: 14px;字的高度为14像素高 font-size: 150%;字相对于另一个字体的大小，若从父元素继承了，就是相对于父元素的大小 font-size: 1.2em; 比例系数 除此之外，还可以将文字大小指定为，xx-small, x-small, small, medium, large, x-large或xx-large，浏览器会将这些关键字转为像素值，其中small为12像素，然后每个大小大约比前一个大20% 通常，可以选一个关键字（推荐small或medium），然后利用em或者百分数相对body指定其他元素字体大小。 默认情况下，h1是200%，h2是150%，h3是120%，h4是100%，h5是90%，h6是60% 浏览器默认16像素 字体可以简写，所需的所有属性为font-family,font-style,font-weight,font-size,font-variant,line-height,按照这个顺序font-style font-variant font-weight font-size/line-height font-family，前三个顺序不重要，非必需，但一定要在font-size前，font-size必须指定 盒模型 CSS将每个元素视为盒模型（box model），每个盒模型由一个内容区以及可选的内边距，边框和外边框组成，其中，内容区（content area）包含内容（例如文本和图像），内容区被可选的透明内边距（padding）包围，内边距周围可能放置一个可选的边框（border），最后有一个可选的透明外边距（margin）包围所有部分 border-style可以控制边框的视觉样式，共8种（solid实线，double双线，groove槽线，outset外凸，dotted虚线，dashed破折线，inset内凹，ridge脊线） border-width控制边框宽度，可以采用关键字或者像素指定（thin medium thick） border-color控制边框颜色，与设置颜色类似 指定某一边的边框，可以使用这样的形式：border-top-color border-bottom：thin dotted #888888;灰色细虚线 border-radius： 15px创建圆角，可以利用px或者em指定半径大小 padding 内边距，可以采用缩写，按照top right bottom left的顺序，若四个值相同，那只需写一个就行了 line-height 行间距,比较特殊，可以直接用数字,代表自己字体大小的倍数 letter-spacing 字母之间间距 list-style 列表外观 text-align 内联元素对齐，可以设置ceter width 可以设置元素宽度，不设置默认auto background-image 元素后面放置一个图像，使用：background: url(images/background.gif); background-position,用于设置图像位置，可以按像素指定，也可以指定为一个百分数，或者采用关键字（top、left、right、bottom、center） background-repeat，用于控制平铺行为（no-repeat,repeat-x,repeat-y,inherit，repeat） border，background都可以简写 a元素和它的多重人格 页面上的链接可以有多种状态：可能未访问、已访问或者处于悬停状态（还有其他状态），可能会用到伪类 此外还有：focus和active状态，浏览器将焦点放在连接上就是焦点状态（用TAB键，键盘输入时），用户第一次单击一个链接时就处于活动状态 适当的顺序为，link，visited，hover，focus，然后是active 使用方式：123456789a:link &#123; color: green;&#125;//未访问a:visited &#123; color: red;&#125;//已访问a:hover &#123; color: yellow;&#125;//悬停 伪类（Pseudo-class） 表现的像个类，但并不是真正的类，例如之前的a:visited a:link a:hover还有first-child 伪类不知能处理链接，也能够对其他类型的元素提供处理 布局与定位流 流实际上就是浏览器在页面上摆放HTML元素所用的方法 浏览器从HTML文件最上面开始，从上到下沿着元素流逐个显示所遇到的各个元素 块元素自上而下流，每个块元素之间加一个换行 内联元素在水平上挨着，总体上从左上方流向右下方 外边距，并排放置，外边距叠加，上下放置，取决于最大外边距 float 首先它会尽可能远的向左或向右浮动一个元素，然后它下面的所有内容会绕流这个元素 对于所有的浮动元素都有一个要求：它必须有一个宽度 浮动元素外边距不会被折叠，注意这点可以避免一些错误 内联元素同样可以浮动，常见为浮动一个图像 float属性可以设置为left或者right 此时没浏览器会如下处理float 首先，浏览器正常将元素流入页面，从文件最上面开始，逐步移向末尾元素 浏览器遇到浮动元素，会将其尽可能放在最右边，然后从流中删除这个段落 然后其他块元素会填在这里，就像根本没这个段落 不过，在内联元素定位时，它们会考虑浮动元素的边界，所以会围绕着浮动元素 实现两栏效果 将sidebar放在页眉下面，然后用float将sidebar栏向右浮动，然后将主内容的右外边距至少设置得和sidebar的宽度相同，这样主内容区和边栏就会分开，但是宽度太宽时，页脚会上移造成重叠 可以利用clear属性解决这个问题，在footer中设置clear: right,代表这个元素右边不允许有浮动元素，此时还有另一个问题，在小的移动设备会看到边栏在最上面，因为我们把sidebar放在了主要内容前 可以采用右紧左松，也就是将主内容向左浮动，设置仿照如上，这样内容的顺序会是对的，但是边栏看起来非常松散 流体与冻结设计 流体布局（liquid layouts），不论浏览器调整到多大的宽度，布局都会扩展，填满整个浏览器，而有时候布局锁定更为重要，这样当用户调整屏幕大小时，你依然可以保持原样，这被称为冻结布局（frozen layouts） 首先，你需要将body内的所有内容放置于一个id为”allcontent”的&lt;div&gt;元素内123456#allcontent&#123; width: 800px; padding-top: 5px; padding-bottom: 5px; background-color: #675c47;&#125; 这样页面宽度将被限制为800px，在页面很宽时，右边很多空白空间 凝胶布局 这是Web上常见的一种设计，介于冻结与流体之间，称为凝胶（Jello），它会锁定页面中内容区的宽度，不过会将它在浏览器中居中12345678#allcontent&#123; width: 800px; padding-top: 5px; padding-bottom: 5px; background-color: #675c47; margin-left: auto; margin-right: auto;&#125; 绝对定位 可以在页面上精确的定位元素，同时采用绝对定位可以实现一些漂亮的效果 一个元素绝对定位时，浏览器首先将它从流中完全删除，然后浏览器将这个元素放置在位置属性所制定的位置上，绝对定位是相对于最近的已定位的祖先元素，例： 123456#sidebar &#123; positon: absolute; top: 100px; right: 200px; width: 280px;&#125; 同时，在绝对定位时，一个元素可有放在另一个绝对定位的元素之上，那么谁在上面？每个定位元素（绝对、相对、固定定位的元素）都有一个名为z-index的属性，将会指定它在一个虚拟z轴上的位置，越上面的，z-index越大，使用：z-index: 1;就可以确保在其他的元素上方，但是有多个需要定位的元素，那需要好好考虑下数值。 position拥有4个值：static， absolute， fixed 和 relative，其中固定（Fixed）定位是将元素放在相对于浏览器窗口的一个位置上（而不是相对与页面），所以固定元素永远不会移动，而相对（Relative）定位会让元素正常流入页面，不过在页面上显示“相对于”自己的起点要进行偏移，相对定位常用于更高级的定位和特殊效果 绝对定位元素不必须指定宽度，但是，会占据浏览器整个宽度，这可能并不是你想要的 指定位置还可以使用百分数，但是位置可能会改变，百分数还常用与制定宽度，可以使主内容区和边栏的大小更为灵活 CSS表格 类似电子表格只包含行和列 为整个表格创建一个块，然后为每行创建块，例： 12345678910&lt;div id = &quot;tableContainer&quot;&gt; &lt;div id = &quot;tableRow&quot;&gt; &lt;div id = &quot;main&quot;&gt; ... &lt;/div&gt; &lt;div id = &quot;siderbar&quot;&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS实现 12345678910111213141516171819202122 div#tableContainer &#123; display: table; border-spacing: 10px; //单元格间距 &#125; div#tableRow &#123; display: table-row; &#125; #main &#123; display: table-cell; background: #efe5d0 url(images/background.gif) top left; font-size: 105%; padding: 15px; vertical-align： top; //单元格上对齐&#125; #sidebar &#123; display: table-cell; background: #efe5d0 url(images/background.gif) bottom right; font-size: 105%; padding: 15px; vertical-align： top;&#125; 开发商特定的CSS属性 首先一个短横线一个开发商标识符在加另一个短横线在加属性，如 1-moz-transform 建立变换与过渡 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS Transforms and Transitions&lt;/title&gt; &lt;style&gt; #box &#123; position: absolute; top: 100px; left: 100px; width: 200px; height: 200px; background-color: red; transition: transform 2s; -webkit-transition: -webkit-transform 2s; -moz-transition: -moz-transform 2s; -o-transition: -o-transform 2s; /* no IE support for transition until possibly IE 10 */ &#125; #box:hover &#123; transform: rotate(45deg); -webkit-transform: rotate(45deg); /* Safari, Chrome, mobile Safari, and Android */ -moz-transform: rotate(45deg); /* Firefox */ -o-transform: rotate(45deg); /* Opera */ -ms-transform: rotate(45deg); /* IE 9 */ &#125; &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://chinti.xyz/tags/CSS/"}]},{"title":"Head First HTML与CSS 阅读笔记（HTML部分）","slug":"Head-First-HTML与CSS-阅读笔记（HTML部分）","date":"2017-12-26T04:56:11.000Z","updated":"2018-01-07T07:18:17.448Z","comments":true,"path":"2017/12/26/Head-First-HTML与CSS-阅读笔记（HTML部分）/","link":"","permalink":"http://chinti.xyz/2017/12/26/Head-First-HTML与CSS-阅读笔记（HTML部分）/","excerpt":"前言&#160; &#160; &#160;&#160;在之前17年6月实习时，负责了管理公司论坛的任务，在此之中初步接触到了HTML和CSS方面的知识，但是学习的不够深入，现在是17年年底，打算重新开始学习这方面的知识，做一些巩固，为之后学习JavaScript与Jquery等打下基础。&#160; &#160; &#160;&#160;《Head First HTML与CSS》是一本对新手友好的前端入门书，虽然废话很多，插画也多的像连环画，但是作为第一本前端书籍是十分合适的，毕竟我认为保持高涨的兴趣才是进步的动力。&#160; &#160; &#160;&#160;本书第一章到第六章介绍了HTML部分（第五章有部分发布的知识，暂且略过），第十二章讲述了HTML5的新特性，而十三到十五章则将HTML与CSS同时进行介绍。本篇博客主要整理HTML部分的知识点。另一篇部分为Head First HTML与CSS阅读笔记（CSS部分）","text":"前言&#160; &#160; &#160;&#160;在之前17年6月实习时，负责了管理公司论坛的任务，在此之中初步接触到了HTML和CSS方面的知识，但是学习的不够深入，现在是17年年底，打算重新开始学习这方面的知识，做一些巩固，为之后学习JavaScript与Jquery等打下基础。&#160; &#160; &#160;&#160;《Head First HTML与CSS》是一本对新手友好的前端入门书，虽然废话很多，插画也多的像连环画，但是作为第一本前端书籍是十分合适的，毕竟我认为保持高涨的兴趣才是进步的动力。&#160; &#160; &#160;&#160;本书第一章到第六章介绍了HTML部分（第五章有部分发布的知识，暂且略过），第十二章讲述了HTML5的新特性，而十三到十五章则将HTML与CSS同时进行介绍。本篇博客主要整理HTML部分的知识点。另一篇部分为Head First HTML与CSS阅读笔记（CSS部分） [注]书中所有代码可在代码地址找到。 概念简称 HTML是HyperText Markup Language的缩写，译为超文本标记语言，用来建立网页的结构。 CSS是Cascading Style Sheets的缩写，译为层叠样式表，用来控制HTML的表现。 常识 由于浏览器会忽略制表符、回车和大部分空格，但是为了提高HTML文档的可读性，利用这些会很有帮助。 按照一定标准编写html，可以减少不同浏览器之间的差异度甚至不兼容。 属性的写法都是一样的：首先是属性名，后面一个等号，然后是双引号括起来的属性值，不严谨的写法可能会出现问题。 文件夹层数没有限制，但是过多的情况下，可能说明网站组织太复杂。 尽可能使用元素告诉浏览器你的内容的含义 web服务器默认文件名为”index.html”或”default.htm”，根据不同服务器。没有斜线的情况下，如果该目录存在，浏览器会自动添加末尾的斜线 端口默认为80 嵌套 根元素，子元素 了解如何嵌套，可以避免标记不匹配，不要越界 元素 块（block）元素：特立独行,&lt;h1&gt;、&lt;h2&gt;、...、&lt;h6&gt;、&lt;p&gt;和&lt;blockquote&gt; 内联（inline）元素：随波逐流,&lt;q&gt;、&lt;a&gt;和&lt;em&gt; void元素：没有实际内容，可以使用简写，提高效率 交互性 html不只是一个被动的文档，它可以拥有可执行的内容，可以使用JavaScript脚本语言来编写程序或脚本 通过JavaScript调用HTML5提供的一些API可以创建许多Web应用 特殊字符 &lt; 可以使用&amp;lt代替 &gt; 可以使用&amp;gt代替 &amp; 可以使用&amp;amp代替 更多常见特殊字符可以在常见字符地址（书上的404了）找到，如果需要更为详尽的字符实体清单可以在详尽字符地址找到。 工具[注]学习环境是Windows10 Notepad（记事本） 主要工具 WebStorm Dreamweaveretc. 浏览器[注]为了在多个浏览器测试效果的细微差别，所以至少要下载并了解两个不同的浏览器。 Chrome Internet Explorer Firefox Opera Safarietc. HTML首部[注]元素=开始标记+内容+结束标记 &lt;html&gt;标签，它总会是一个根元素html 告诉浏览器文件内容是HTML，使用：&lt;html&gt;...&lt;/html&gt;包围你的的HTML 头部head 包含Web页面的有关信息，只能放置&lt;title&gt;&lt;meta&gt;&lt;style&gt;元素。 title 页面标题 meta 关于页面的信息 style 页面样式，例&lt;style type=&quot;text/css&quot;&gt;...&lt;/style&gt;然后在里面可以写body{...}等CSS语法（CSS部分将会整理在另一篇博客）。 [注]编写HTML时要把首部和页面主体分开。 HTML页面主体 主体body web页面的主体元素 标题h1 h2 h3 h4 h5 h6 共六级标题，使用：&lt;h1&gt;标题&lt;/h1&gt; 段落p 块元素，使用：&lt;p&gt;...&lt;/p&gt;small专为极小字体设计，可用于版权信息 超链接 &lt;a href=&quot;链接地址&quot;&gt;链接文本&lt;/a&gt; href是hypertextreference的缩写，意思为超文本引用。 &lt;img&gt;元素也可以放在&lt;a&gt;标记之间 ../dotdot代表向上到父级文件夹 title 提供链接信息 id 用来为目标创建标识符，必须是唯一的，例：&lt;h2 id=&quot;chai&quot;&gt;Chai Tea&lt;/h2&gt;,然后使用方法如下：&lt;a href=&quot;index.html&quot;#chai&gt;See Chai Tea&lt;/a&gt; target属性，使用：target=&quot;_blank&quot;代表在新窗口打开 内部网页采用相对路径，外部网页采用绝对路径 默认的，这个标签具有下划线且可以点击 保证链接标签简洁且有意义（不要使用这里或者这一页的标签），在title属性中提供额外信息，且不要将链接放在一起 强调em内联元素，使用：&lt;em&gt;...&lt;/em&gt; 删除del将某些内容标记为要删除内容（删除线） 插入ins标记要插入的内容（下划线） 换行br用于换行，使用&lt;br&gt;，它是一个void元素，处理XHTML时可以用&lt;/br&gt; 代码code，块元素，用来显示计算机程序代码 加粗strong，内联，用来标记特别强调的文本 原样显示pre，希望浏览器按你输入的方式原样显示文本，使用这个元素指定文本格式 时间time，这个元素告诉浏览器这个内容是个日期或时间 图像img图片 src属性，指定img的源文件地址。可以指定相对地址，该属性必须填写，与href属性类似。 alt属性，指定描述这个图像的一些文字，在图像无法显示时替代显示文本，可用于帮助视力障碍的用户 width属性，指定宽度 height属性，指定高度，高度与宽度都是由像素数指定 图片格式 常见格式为：JPEG、PNG和GIF 照片和复杂图像使用JPEG，单色图像、logo和几何图形使用PNG或GIF 规范 指定长宽，可以使页面在显示图像之前就建立布局 指定长宽可以用于缩放图像，但它会先获取完整图像 浏览器宽度通常被设为800到1280像素之间，所以图像宽度要小于800 可以用photoshop等图像编辑软件调整图片大小 引用 &lt;q&gt; 短引用，不是所有浏览器都会在&lt;q&gt;的内容两边加上引号。去掉双引号用&lt;q&gt;可以让页面更加结构化，更有意义。是一个内联元素。 &lt;blockquote&gt;长引用，需要被单独显示。是一个块元素。 列表 li列表项 ol有序列表，ordered list的简写，由浏览器编号 ul无序列表，unordered list的简写 第一步，每个列表项都要放在单独的&lt;li&gt;元素中，第二步，用&lt;ol&gt;或&lt;ul&gt;包围所有列表项 可以为列表添加一些样式，列表的主要属性是lis-style-type,disc是默认的列表标记类型，circle，提供一个简单的圆形标记，square方块标记，none删除标记 定制标记，list-style-image: url(images/backpack.gif); 文本回绕，list-style-position,inside标记下回绕，outside文本下回绕 容器逻辑区就是页面上一组彼此相关的元素，通过div或者span容器来标记一组元素div块元素容器 在属于一个逻辑区的元素周围放置&lt;div&gt;开始和结束标记 利用&lt;div&gt;为页面增加更多的结构，可以进一步展现页面的底层逻辑结构，帮助别人理解你的页面 有需要的话，可以在结构上增加结构 很多情况下，会创建&lt;div&gt;并把他们放在类中 span内联元素容器 类似div，只是创建的是内联元素 表格 用table标记一个表格的开始，每行tr开始，th代表每列的表头，其余由td标记 1234567891011121314151617181920212223242526&lt;table&gt; &lt;tr&gt; &lt;th&gt;City&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Temperature&lt;/th&gt; &lt;th&gt;Altitude&lt;/th&gt; &lt;th&gt;Population&lt;/th&gt; &lt;th&gt;Diner Rating&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Walla Walla, WA&lt;/td&gt; &lt;td&gt;June 15th&lt;/td&gt; &lt;td&gt;75&lt;/td&gt; &lt;td&gt;1,204 ft&lt;/td&gt; &lt;td&gt;29,686&lt;/td&gt; &lt;td&gt;4/5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Magic City, ID&lt;/td&gt; &lt;td&gt;June 25th&lt;/td&gt; &lt;td&gt;74&lt;/td&gt; &lt;td&gt;5,312 ft&lt;/td&gt; &lt;td&gt;50&lt;/td&gt; &lt;td&gt;3/5&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; caption 标题,放在table下，tr上,可以在CSS指定它的位置，大多数浏览器默认显示在表格上方 12345678910111213141516171819202122&lt;caption&gt; The cities I visited on my Segway&apos;n USA travels&lt;caption&gt;//CSS部分table &#123; margin-left: 20px; margin-right: 20px; border: thin dotted gray; caption-side: bottom; //指定位置&#125;td, th &#123; border: thin dotted gray; padding: 5px;&#125;caption &#123; font-style: italic; padding-top: 8px;&#125; border-spacing 边框间距，每个表格单元的外边距不能被设置，只能设置共同间距，而且可以在垂直方向和水平方向设置不同间距，例如border-spacing: 10px 30px;代表设置了10像素水平边框间距，30像素的垂直边框间距 border-collapse 边框折叠，使用：border-collapse: collapse; 颜色交替，一种通过定义类还有一种通过伪类nth-child这是一种更高级的指定方法 12345678910111213p:nth-child(even) &#123; background-color: red;&#125;p:nth-child(odd) &#123; background-color: green;&#125;//或者可以用表达式 p:nth-child(2n) &#123; background-color: red;&#125;p:nth-child(2n+1) &#123; background-color: green;&#125; 合并单元格，当存在一个单元格跨多行时，可以使用rowspan属性，指定一个表格数据单元格占的行数，然后将这个单元格所跨越的其他行删除相应的表格数据元素,同理，colspan属性可以用来跨多列 12345678910111213141516&lt;tr&gt; &lt;td rowspan = &quot;2&quot;&gt;Truth or Consequences, NM&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;August 9th&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;93&lt;/td&gt; &lt;td rowspan = &quot;2&quot; class = &quot;right&quot;&gt;4,242 ft&lt;/td&gt; &lt;td rowspan = &quot;2&quot; class = &quot;right&quot;&gt;7,289&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;5/5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td class = &quot;center&quot;&gt;August 27th&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;98&lt;/td&gt; &lt;td class = &quot;center&quot;&gt;4/5&lt;/td&gt;&lt;/tr&gt; 表格嵌套，在表格里再放个table 表单 form表单元素，几乎所有块级元素都可以放在里面,action属性包含Web服务器脚本的URL，method属性确定表单数据如何发送到服务器，常用方法POST 1234567&lt;form action=&quot;http://wickedlysmart.com/hfhtmlcss/contest.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;Just type in your name (and click Submit) to enter the contest:&lt;br&gt; First name: &lt;input type=&quot;text&quot; name=&quot;firstname&quot; value=&quot;&quot;&gt;&lt;br&gt; Last name: &lt;input type=&quot;text&quot; name=&quot;lastname&quot; value=&quot;&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/p&gt;&lt;/form&gt; input元素用于输入一行文本，它还有一些可选的属性，允许你为这个控件设置最大字符个数和宽度，void内联元素，其中提交按钮需要指定”submit”作为input元素的type属性值，”radio”可以单选按钮，若有checked布尔属性则默认选中，”checkbox”复选框，相关选框必须共有一个名字，每个框有一个不同的值，可以用maxlength = &quot;100&quot;设置最多输入100字符 textarea元素可以创建一个多行的文本区，输入的文本在文本区中放不下，右边会出现滚动条,row行，cols列 1&lt;textarea name = &quot;comments&quot; rows = &quot;10&quot; cols = &quot;48&quot;&gt;&lt;/textarea&gt; select元素可以创建一个下拉选择的菜单，option元素创建菜单项 123&lt;select name = &quot;characters&quot;&gt; &lt;option value = &quot;Buckaroo&quot;&gt;Buckaroo Banzai&lt;/option&gt;&lt;/select&gt; 以下是HTML5新增的表单元素 数字输入，number用于限制只输入数字，有些浏览器会在右边给一个显示箭头，用于增减 1&lt;input type = &quot;number&quot; min = &quot;0&quot; max = &quot;20&quot;&gt; 范围输入，range，显示一个滑动条而非输入框 1&lt;input type = &quot;range&quot; min = &quot;0&quot; max = &quot;20&quot; step = &quot;5&quot;&gt; 颜色输入，color，用于指定元素 1&lt;input type = &quot;color&quot;&gt; 日期输入，date，用于选择时间，方法同上 email输入，email，同上 tel输入，tel，同上 url输入，url，同上 POST与GET 都是将表单数据发送到服务器，POST会打包表单变量，然后后台发送，GET也会打包，但会把这些数据追加到URL最后，向服务器发送一个请求，用户会可见 关于可访问性 实际上应该用label元素标记那些标签，可以提供页面结构更多的信息，这样可以更容易用css添加样式，另外对于有视力障碍的人也有助于他们使用的屏幕阅读器更准确的标识表单元元素，id可以与name相同，每个id必须唯一，使用：1234&lt;input type = &quot;radio&quot; name = &quot;hotornot&quot; value = &quot;hot&quot; id = &quot;hot&quot;&gt;&lt;label for = &quot;hot&quot;&gt;hot&lt;/label&gt;&lt;input type = &quot;radio&quot; name = &quot;hotornot&quot; value = &quot;not&quot; id = &quot;not&quot;&gt;&lt;label for = &quot;not&quot;&gt;not&lt;/label&gt; fieldset和legend 表单分组，用fieldset将公共元素组织在一起，用legend为这个分组提供一个标签123456&lt;fieldset&gt; &lt;legend&gt;Condiments&lt;/legend&gt; &lt;input ...&gt;...&lt;br&gt; &lt;input ...&gt;...&lt;br&gt; ...&lt;/fieldset&gt; passwords 会为你输入的文本增加掩码，工作与text类似，不过并不会采用一种安全的方式从浏览器到服务器脚本，想要提高安全性，清联系托管公司 file 创建一个文件输入元素，只需将input元素的type属性设置为file，此外运用这个元素必须使用POST方式 多选菜单 为select元素增加布尔属性multiple即可，这样菜单就不再显示下拉，而是得到一个多选菜单 Placeholder 在input元素中增加placeholder属性，可以设置一个提示，告诉别人你希望他填写什么 Required 可用与任何表单元素，是一个布尔属性，加入它，说明这是一个必须填写的表单，必须输入才能提交 HTML5及工业标准HTML5 doctype 文档类型定义 &lt;!doctype html&gt; 从html5开始不再有版本号，是一个动态的标准，且具有向后兼容性。HTML5主要是添加了些新东西，不要为了使用新特性而使用新特性，应当物尽其用，最合适的东西干最适合的活。 字符编码 meta，使用:&lt;meta charset=&quot;utf-8&quot;&gt; 指定doctype以及使用&lt;meta&gt;指定字符编码是义务必须履行 meta放在head中 W3C验证工具 W3C验证工具 重新考虑HTML结构&#160; &#160; &#160;&#160;将div元素替换成一些更加特定的元素，能够更明确地指示其中包含什么类型的内容 新增元素 可以查看http://caniuse.com/#search=new%20elements,了解浏览器是否支持新元素 article 表示页面中一个独立的组成部分，如一个博客帖子、用户论坛帖子或者新闻报道 nav 所包含的内容将作为页面的导航链接 header 放在页面顶部的内容，或者放在页面某个区块的顶部 footer 放在页面底部的内容，或者放在页面某个区块的底部 time 可能包含一个日期或时间，也可能同时包含日期和时间，简要指南如下 1234&lt;time datetime=&quot;2012-02-18&quot;&gt;2/18/2012&lt;/time&gt;//内容中，可以写任何内容，如&quot;February 18,2012&quot;甚至可以是&quot;yesterday&quot;或&quot;now&quot;//若元素内容没有采用日期/时间的格式来写，就必须要datetime属性//（2012-02 2012 2012-02-18 9：00 05：00 2012-02-18 05：00z（utc时间）） aside 包含的内容是对页面内容的补充，如插图或边栏 section 一个主题内容分组，通常包含一个首部（header），可能还有一个底部（footer） video 用来为页面增加视频媒体 mark 用于突出显示某些文本 meter 显示某个范围的度量 progress 显示任务的完成进度 canvas 显示用javaScript绘制的图像和动画 figure 定义类似照片、图标甚至代码清单等独立的内容 视频video 可以将视频看作img元素，可以提供一个src属性引用视频 12&lt;video controls autoplay width = &quot;512&quot; height = &quot;288&quot; src = &quot;video/tweetsip.mp4&quot;&gt; &lt;/video&gt; autoplay 自动播放 control 提供一组控件来控制播放、暂停、调节音量等 视频格式问题，Safari更接受H.264，Chorme更接受WebM autoplay与controls没有值，是一个bool属性，通常用户希望觉得加载页面时是否播放视频，所以是否加这个属性请三思 src 与img的src很相似 preload 用于细粒度（没懂，是指精细么）地控制视频如何加载，来实现优化，可以preload: none代表用户播放前不加载，metadata代表下载元数据，不下载内容，也可以是设置为auto，交给浏览器决定 poster 在视频未播放时，将视频的某一帧显示为“海报”图像，浏览器通常会指定第一帧,这往往是个黑屏 loop 自动循环，bool属性 width height设置视频显示区，有多余就显示黑边 视频格式 &#160; &#160; &#160;&#160;现在主流格式有3种，MP4容器，包含H.264视频和AAC音频，WebM容器，包含VP8视频和Vorbis音频，Ogg容器，包含Theora视频和Vorbis音频，在使用多个格式时可采用source元素，方式如下：12345678 &lt;video controls autoplay width = &quot;512&quot; height = &quot;288&quot;&gt; &lt;source src = &quot;video/tweetsip.mp4&quot;&gt; &lt;source src = &quot;video/tweetsip.webm&quot;&gt; &lt;source src = &quot;video/tweetsip.ogv&quot;&gt; &lt;p&gt;Sorry, your browser doesn&apos;t support the video element.&lt;/p&gt; &lt;/video&gt;``` - 如何更加具体的指定格式 &lt;source src = &quot;video/tweetsip.ogv&quot; type = &apos;video/ogg; codecs = &quot;theora, vorbis&quot;&apos;&gt; //type可选帮助浏览器确定能否播放文件，单引号 &lt;source src = &quot;video/tweetsip.mp4&quot; type = &apos;video/mp4; codecs = &quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt; &lt;source src = &quot;video/tweetsip.webm&quot; type = &apos;video/webm; codecs = &quot;vp8, vorbis&quot;&apos;&gt; ``` 参考http://wiki.whatwg.org/wiki/Video_type_parameters得到有关type参数的更多信息 在video元素中插入object元素，放在source下面，如果浏览器不认识video那么就会用object，最终看到一个flash视频 音频 audio使用方法与video类似","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://chinti.xyz/categories/读书笔记/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://chinti.xyz/tags/HTML/"}]},{"title":"Hexo+GithubPage博客搭建","slug":"Hexo-GithubPage博客搭建","date":"2017-12-24T13:19:26.000Z","updated":"2018-01-04T05:20:53.410Z","comments":true,"path":"2017/12/24/Hexo-GithubPage博客搭建/","link":"","permalink":"http://chinti.xyz/2017/12/24/Hexo-GithubPage博客搭建/","excerpt":"前言&#160; &#160; &#160;&#160;在了解到博客后一直想用它进行一些学习上的记录，但是由于各种各样的原因计划一直搁浅了。不过在接下来的时间，继大半年前接触到一些浅显的前端技术后将进行比较系统的学习，所以借着机会将博客搭建完成。其实网上关于搭建个人博客的教程很多，但是呢作为Markdown程序员的开篇之作还是很适宜的。","text":"前言&#160; &#160; &#160;&#160;在了解到博客后一直想用它进行一些学习上的记录，但是由于各种各样的原因计划一直搁浅了。不过在接下来的时间，继大半年前接触到一些浅显的前端技术后将进行比较系统的学习，所以借着机会将博客搭建完成。其实网上关于搭建个人博客的教程很多，但是呢作为Markdown程序员的开篇之作还是很适宜的。 什么是Hexo，什么是Next&#160; &#160; &#160;&#160;Hexo是一个基于Node.js的快速、简洁且高效的博客框架。Hexo使用Markdown解析文章。Next是一款极简主义的主题，内容强大，使用简便。献上一张Next的图片。 什么是Markdown&#160; &#160; &#160;&#160;Markdown是一种可以使用普通文本编辑器编写的标记语言吗，通过这些简单的标记，实现易读易写，专注于文字本身。 什么是Github，什么是GithubPage&#160; &#160; &#160;&#160;GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git 作为唯一的版本库格式进行托管，故名GitHub。GithubPage是一个用于展示你和你的项目的网页，可用于搭建个人博客。 基础配置部分[注]本文中所使用的Hexo版本为3.4.3，node.js版本为8.9.3，PC环境为Windows101.安装&amp;搭建 安装Git：Git下载地址戳这 安装Node.js：Node下载地址戳这 安装Hexo：Hexo官网&#160; &#160; &#160;&#160;首先打开GitBash（你可以通过右键Git Bash Here方便的打开），接下来的一系列操作都将会在GitBash中实现。附一张GitBash截图。Hexo本体安装： npm install hexo-cli -g新建一个博客文件夹，执行：cd &lt;folder&gt;再执行：hexo init 依赖包安装：npm install指定文件夹内容如下，说明新建完成。 注册Github账号，并新建Github仓库：仓库名字必须为 username.github.io，username就是你的Github用户名。 关联到Github账号：进入博客根目录，执行vim _config.yml翻到最下面，修改为：deploy：type: gitrepo:https://github.com/username/username.github.io.gitbranch: master然后执行： npm install hexo-deployer-git --save 2. 配置SSH&#160; &#160; &#160;&#160;SSH是一种安全协议，我们需要通过SSH将Git与Github进行绑定，才能通过Git向Github提交代码。 生成公钥私钥ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;，然后敲三下回车不用输入密码，之后会生成两个文件，分别为 id_rsa和id_rsa.pub，Windows10环境下，你可以在C:\\Users\\username\\.ssh中找到。 添加公钥到Github用记事本打开id_rsa.pub，将内容复制，然后打开你的Github主页。在右上角头像处——&gt;Setting，进入个人设置界面。进入Setting页面后，点击SSH and GPG keys进入子页面，然后点击New SSH key按钮。最后，将公钥id_rsa.pub的内容粘贴到Key处，点击Add SSH key。 验证在git bash中输入：ssh -T git@github.com，等待提示。 3. NexT主题下载在GitBash下输入：cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/nextyour-hexo-site 就是你的博客文件夹。然后修改，Hexo配置文件启用主题。进入博客根目录，执行：vim _config.yml,找到theme：，将它改为theme: next即可。 使用Hexo部分1. 常用命令 清除生成的文件和缓存：hexo clean 生成静态页面：hexo generate //或 hexo g 本地预览：hexo server //或 hexo s 然后在浏览器中输入localhost：4000即可预览效果，Ctrl+C结束 新建文章：hexo new post &quot;title&quot; 新建页面：hexo new page &quot;title&quot; 部署： hexo d 等待片刻你可以在浏览器输入：username.github.io看看效果。 2. 常用Markdown语法&#160; &#160; &#160;&#160;在新建文章后可以发现在_post文件夹下出现了一个md文件，你可以对它进行编辑。可以采用vim直接编写，也可以通过一些实时观看效果的编辑器进行编写，可以自己百度。本人使用的是Cmd Markdown。这里仅介绍一些常用的Markdown语法。 标题：# 一级标题 ## 二级标题类推可得最多六级标题 列表：无序列表- 文字 有序列表1. 文字 图片与链接：图片为![][] 链接为[][] 前一个方括号是文字内容，后一个方括号是序号，在文章尾部可以[序号]：链接地址的方式。插入外链图片需要一个图床，这里我采用的是一款chrome插件，叫做新浪微博图床，也可以试试其他正规的图床服务。 粗体与斜体：粗体**文字** 斜体*文字* 分割内容：-- == 阅读更多：&lt;!--more--&gt;在这行代码前的可以显示，后面的被隐藏，需要点击阅读更多才能看全文。 空行：&lt;br /&gt; 空格：&amp;#160; &amp;#160; &amp;#160;&amp;#160; &#160; &#160; &#160;&#160;了解以上这些，写出一篇文章应该可以了，更加完全的Markdown语法自行百度。 域名绑定1. 购买域名&#160; &#160; &#160;&#160;既然已经初步搭建好了自己的博客，但是是通过username.github.io进行访问的。我们需要有一个自己独立的域名它看起来逼格高一些（并不会）。域名服务商有很多，国内国外的，我选择了腾讯云。[注]接下来以在腾讯云购买域名为例，其他服务商应该也是大同小异。 2. 绑定域名 登陆腾讯云后台，进入我的域名——&gt;域名解析 添加DNS记录 在博客根目录里的public目录中新建CNAME文本，没有后缀名，可以新建一个txt把后缀删掉，编辑他，输入你的域名，保存并退出。将CNAME文本复制到source目录中一份。 执行代码hexo clean hexo d -g 由于DNS记录需要一定时间生效，稍等片刻，用你的域名访问看看。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://chinti.xyz/categories/博客相关/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://chinti.xyz/tags/Hexo/"}]}]}